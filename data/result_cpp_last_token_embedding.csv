ref,predict,id,code
1,1.0,HumanEval_23_strlen,"
#include<assert.h>
#include<bits/stdc++.h>

// Return length of given string
long string_length(std::string str) {
    return str.length();"
1,1.0,HumanEval_23_strlen,"
long string_length(std::string string) {
    return string.size();"
1,1.0,HumanEval_23_strlen,"
#include<assert.h>
#include<bits/stdc++.h>

// Return length of given string
long string_length(std::string str) {
    return str.length();
"
0,0.0,HumanEval_23_strlen,"
    return string.length();"
0,0.0,HumanEval_23_strlen,"
    return string.length();"
1,1.0,HumanEval_23_strlen,"
long string_length(std::string string) {
    return string.length();"
1,1.0,HumanEval_23_strlen,"
long string_length(std::string string) {
    return string.length();"
1,1.0,HumanEval_23_strlen,"
long string_length(std::string string) {
    return string.length();
"
1,1.0,HumanEval_23_strlen,"
long string_length(std::string string) {
    return string.length();
"
0,0.0,HumanEval_23_strlen,"
    return string.length();"
0,0.0,HumanEval_89_encrypt,"
    std::string result = """";
    for(int i = 0; i < s.length(); i++){
        if(isupper(s[i])){
            result += char(int('A') + (s[i] - 'A' + 2*2) % 26);
        }
        else{
            result += char(int('a') + (s[i] - 'a' + 2*2) % 26);
        }
    }
    return result;"
1,1.0,HumanEval_89_encrypt,"
std::string encrypt(std::string s) {
    std::string result = """";
    for (int i = 0; i < s.length(); i++) {
        if (isupper(s[i])) {
            result += char(((s[i] - 'A' + 2 * 2) % 26) + 'A');
        } else {
            result += char(((s[i] - 'a' + 2 * 2) % 26) + 'a');
        }
    }
    return result;"
1,1.0,HumanEval_89_encrypt,"

std::string encrypt(std::string s) {
    std::string result = """";
    for (int i=0; i<s.length(); i++) {
        if (isupper(s[i]))
            result += char(int(s[i]+4-65)%26 +65);
        else
            result += char(int(s[i]+4-97)%26 +97);
    }
    return result;"
0,1.0,HumanEval_89_encrypt,"
    std::string encrypted_string = """";
    for (char& c : s) {
        if (isupper(c)) {
            encrypted_string += char(((c - 'A' + 2*2) % 26) + 'A');
        } else if (islower(c)) {
            encrypted_string += char(((c - 'a' + 2*2) % 26) + 'a');
        } else {
            encrypted_string += c;
        }
    }
    return encrypted_string;"
0,0.0,HumanEval_89_encrypt,"
    std::string result = """";
    for (int i = 0; i < s.length(); i++) {
        char c = s[i];
        if (isupper(c)) {
            result += char(((c - 'A' + 2*2) % 26) + 'A');
        } else {
            result += char(((c - 'a' + 2*2) % 26) + 'a');
        }
    }
    return result;
"
1,1.0,HumanEval_89_encrypt,"

std::string encrypt(std::string s) {
    std::string encrypted = """";
    for(char& c : s) {
        if(isupper(c)) {
            encrypted += char(((c - 'A' + 2 * 2) % 26) + 'A');
        } else {
            encrypted += char(((c - 'a' + 2 * 2) % 26) + 'a');
        }
    }
    return encrypted;"
1,1.0,HumanEval_89_encrypt,"
std::string encrypt(std::string s) {
    std::string result = """";
    for (int i=0; i<s.length(); i++) {
        char c = s[i];
        if (isupper(c)) {
            result += char(int('A') + (c - 'A' + 2*2) % 26);
        } else {
            result += char(int('a') + (c - 'a' + 2*2) % 26);
        }
    }
    return result;
"
1,1.0,HumanEval_89_encrypt,"
std::string encrypt(std::string s) {
    std::string result = """";
    for (char& c : s) {
        if (isupper(c)) {
            result += char(((c - 'A' + 2 * 2) % 26) + 'A');
        } else {
            result += char(((c - 'a' + 2 * 2) % 26) + 'a');
        }
    }
    return result;"
1,1.0,HumanEval_89_encrypt,"
std::string encrypt(std::string s) {
    std::string result = """";
    for (int i=0; i<s.length(); i++) {
        if (isupper(s[i]))
            result += char(int(s[i]+2*2-65)%26 +65);
        else
            result += char(int(s[i]+2*2-97)%26 +97);
    }
    return result;"
1,1.0,HumanEval_89_encrypt,"

std::string encrypt(std::string s) {
    std::string encrypted_string = """";
    for(char& c : s) {
        if(isupper(c)) {
            encrypted_string += char(int('A') + (c - 'A' + 2*2) % 26);
        } else {
            encrypted_string += char(int('a') + (c - 'a' + 2*2) % 26);
        }
    }
    return encrypted_string;"
0,0.0,HumanEval_95_check_dict_case,"
    if (dict.empty()) {
        return false;
    }
    
    bool all_lower = true;
    bool all_upper = true;
    
    for (auto const& pair: dict) {
        std::string key = pair.first;
        for (char const &c : key) {
            if (std::isupper(c)) {
                all_lower = false;
            } else if (std::islower(c)) {
                all_upper = false;
            } else {
                return false;
            }
        }
    }
    
    return all_lower || all_upper;"
0,0.0,HumanEval_95_check_dict_case,"

bool check_dict_case(std::map<std::string,std::string> dict) {
    if(dict.empty()) {
        return false;
    }

    bool all_lower = true;
    bool all_upper = true;

    for(auto const& pair: dict) {
        std::string key = pair.first;
        for(char c : key) {
            if(!isupper(c)) {
                all_upper = false;
            }
            if(!islower(c)) {
                all_lower = false;
            }
        }
        if(!all_lower && !all_upper) {
            return false;
        }
        all_lower = true;
        all_upper = true;
    }

    return true;"
0,0.0,HumanEval_95_check_dict_case,"
bool check_dict_case(std::map<std::string,std::string> dict) {
    if (dict.empty()) {
        return false;
    }
    bool all_lower = true;
    bool all_upper = true;
    for (auto const& pair: dict) {
        std::string key = pair.first;
        for (char const &c : key) {
            if (!isupper(c)) {
                all_upper = false;
            }
            if (!islower(c)) {
                all_lower = false;
            }
        }
        if (!all_lower && !all_upper) {
            return false;
        }
        all_lower = true;
        all_upper = true;
    }
    return true;"
1,0.0,HumanEval_95_check_dict_case,"
bool check_dict_case(std::map<std::string,std::string> dict) {
    if (dict.empty()) {
        return false;
    }

    bool allLower = true;
    bool allUpper = true;

    for (auto const& pair: dict) {
        std::string key = pair.first;
        for (char c : key) {
            if (std::isupper(c)) {
                allLower = false;
            } else if (std::islower(c)) {
                allUpper = false;
            } else {
                return false;
            }
        }
    }

    return allLower || allUpper;"
0,0.0,HumanEval_95_check_dict_case,"

bool check_dict_case(std::map<std::string,std::string> dict) {
    if(dict.empty())
        return false;

    bool is_lower = true, is_upper = true;

    for(auto const &pair: dict) {
        std::string key = pair.first;
        for(char const &c: key) {
            if(!islower(c))
                is_lower = false;
            if(!isupper(c))
                is_upper = false;
        }
    }

    return is_lower || is_upper;"
0,0.0,HumanEval_95_check_dict_case,"
    // Check if the map is empty
    if (dict.empty()) {
        return false;
    }

    // Initialize two booleans to track if all keys are in lower case or upper case
    bool all_lower = true, all_upper = true;

    // Iterate over the map
    for (const auto& kv : dict) {
        // Check if the key is a string
        if (std::holds_alternative<std::string>(kv.first)) {
            std::string key = std::get<std::string>(kv.first);
            // If any key is not in lower case, set all_lower to false
            if (!std::all_of(key.begin(), key.end(), ::islower)) {
                all_lower = false;
            }
            // If any key is not in upper case, set all_upper to false
            if (!std::all_of(key.begin(), key.end(), ::isupper)) {
                all_upper = false;
            }
        } else {
            // If the key is not a string, return false
            return false;
        }
    }

    // Return true if all keys are in lower case or all keys are in upper case
    return all_lower || all_upper;"
0,0.0,HumanEval_95_check_dict_case,"

bool check_dict_case(std::map<std::string,std::string> dict) {
    if (dict.empty())
        return false;
        
    bool all_lower = true, all_upper = true;
    for (auto const& pair: dict) {
        std::string key = pair.first;
        for (char const &c : key) {
            if (islower(c))
                all_upper = false;
            else if (isupper(c))
                all_lower = false;
        }
        if (!all_lower && !all_upper)
            break;
    }
    return all_lower || all_upper;"
0,0.0,HumanEval_95_check_dict_case,"
bool check_dict_case(std::map<std::string,std::string> dict) {
    if (dict.empty()) {
        return false;
    }

    bool all_lower = true;
    bool all_upper = true;

    for (auto const& pair: dict) {
        std::string key = pair.first;
        for (char c : key) {
            if (islower(c)) {
                all_upper = false;
            } else if (isupper(c)) {
                all_lower = false;
            } else {
                return false;  // Non-alphabetic character found
            }
        }
        if (all_lower == false && all_upper == false) {
            break;
        }
    }

    return all_lower || all_upper;
"
0,0.0,HumanEval_95_check_dict_case,"
bool check_dict_case(std::map<std::string,std::string> dict) {
    if(dict.empty()) {
        return false;
    }

    bool all_lower = true;
    bool all_upper = true;

    for(auto const& pair: dict) {
        std::string key = pair.first;

        for(char c : key) {
            if(!islower(c)) {
                all_lower = false;
            }
            if(!isupper(c)) {
                all_upper = false;
            }
        }

        if(!all_lower && !all_upper) {
            return false;
        }

        all_lower = true;
        all_upper = true;
    }

    return true;"
0,0.0,HumanEval_95_check_dict_case,"
bool check_dict_case(std::map<std::string,std::string> dict) {
    if (dict.empty()) {
        return false;
    }
    
    bool all_lower = true;
    bool all_upper = true;
    
    for (auto const& pair: dict) {
        std::string key = pair.first;
        for (char c : key) {
            if (islower(c)) {
                all_upper = false;
            } else if (isupper(c)) {
                all_lower = false;
            } else {
                return false;
            }
        }
    }
    
    return all_lower || all_upper;
"
0,0.0,HumanEval_85_add,"
    long sum = 0;
    for(int i = 1; i < lst.size(); i += 2) {
        if(lst[i] % 2 == 0) {
            sum += lst[i];
        }
    }
    return sum;"
0,1.0,HumanEval_85_add,"
    long sum = 0;
    for(int i = 1; i < lst.size(); i += 2) {
        if(lst[i] % 2 == 0) {
            sum += lst[i];
        }
    }
    return sum;"
0,0.0,HumanEval_85_add,"
    long sum = 0;
    for (int i = 1; i < lst.size(); i += 2) {
        if (lst[i] % 2 == 0) {
            sum += lst[i];
        }
    }
    return sum;"
1,1.0,HumanEval_85_add,"

long add(std::vector<long> lst) {
    long sum = 0;
    for(int i = 1; i < lst.size(); i += 2) {
        if(lst[i] % 2 == 0) {
            sum += lst[i];
        }
    }
    return sum;"
1,1.0,HumanEval_85_add,"

long add(std::vector<long> lst) {
    long sum = 0;
    for(int i = 1; i < lst.size(); i += 2){
        if(lst[i] % 2 == 0){
            sum += lst[i];
        }
    }
    return sum;
"
0,0.0,HumanEval_85_add,"
    long sum = 0;
    for (size_t i = 0; i < lst.size(); i++) {
        if (i % 2 != 0 && lst[i] % 2 == 0) {
            sum += lst[i];
        }
    }
    return sum;"
1,1.0,HumanEval_85_add,"

long add(std::vector<long> lst) {
    long sum = 0;
    for (int i = 1; i < lst.size(); i += 2) {
        if (lst[i] % 2 == 0) {
            sum += lst[i];
        }
    }
    return sum;
"
1,1.0,HumanEval_85_add,"
long add(std::vector<long> lst) {
    long sum = 0;
    for (size_t i = 1; i < lst.size(); i += 2) {
        if (lst[i] % 2 == 0) {
            sum += lst[i];
        }
    }
    return sum;"
0,0.0,HumanEval_85_add,"
    long sum = 0;
    for(int i = 1; i < lst.size(); i += 2) {
        if(lst[i] % 2 == 0) {
            sum += lst[i];
        }
    }
    return sum;"
1,1.0,HumanEval_85_add,"

long add(std::vector<long> lst) {
    long sum = 0;
    for (size_t i = 1; i < lst.size(); i += 2) {
        if (lst[i] % 2 == 0) {
            sum += lst[i];
        }
    }
    return sum;"
0,0.0,HumanEval_140_fix_spaces,"
    std::string result;
    bool two_spaces_found = false;
    for (char c : text) {
        if (c == ' ') {
            if (two_spaces_found) {
                result.push_back('-');
                two_spaces_found = false;
            } else {
                result.push_back('_');
                two_spaces_found = true;
            }
        } else {
            result.push_back(c);
            two_spaces_found = false;
        }
    }
    return result;"
0,0.0,HumanEval_140_fix_spaces,"

std::string fix_spaces(std::string text) {
    std::string result;
    bool consecutive = false;

    for (char c : text) {
        if (c == ' ') {
            if (consecutive) {
                result.push_back('-');
            } else {
                result.push_back('_');
            }
            consecutive = true;
        } else {
            result.push_back(c);
            consecutive = false;
        }
    }

    return result;
"
0,0.0,HumanEval_140_fix_spaces,"

std::string fix_spaces(std::string text) {
    std::string result = """";
    int count = 0;
    for (char c : text) {
        if (c == ' ') {
            count++;
            if (count == 1) {
                result += '_';
            } else if (count > 2) {
                result.pop_back();
                result += '-';
            }
        } else {
            if (count > 2) {
                result += '_';
            }
            result += c;
            count = 0;
        }
    }
    return result;
"
0,0.0,HumanEval_140_fix_spaces,"
std::string fix_spaces(std::string text) {
    std::string result;
    int count = 0;
    for (char c : text) {
        if (c == ' ') {
            count++;
            if (count == 1) {
                result += '_';
            }
            if (count > 2) {
                result.pop_back();
                result += '-';
            }
        } else {
            if (count > 2) {
                result += '_';
            }
            if (count > 0) {
                count = 0;
            }
            result += c;
        }
    }
    return result;
"
0,0.0,HumanEval_140_fix_spaces,"
std::string fix_spaces(std::string text) {
    std::string result;
    bool consecutive = false;
    for (char c : text) {
        if (c == ' ') {
            if (consecutive) {
                result.push_back('-');
            } else {
                result.push_back('_');
            }
            consecutive = true;
        } else {
            result.push_back(c);
            consecutive = false;
        }
    }
    return result;"
0,0.0,HumanEval_140_fix_spaces,"
    std::string result;
    int count = 0;

    for (char c : text) {
        if (c == ' ') {
            count++;
            if (count == 1) {
                result += '_';
            } else if (count > 2) {
                result.pop_back();
                result += '-';
            }
        } else {
            result += c;
            count = 0;
        }
    }

    return result;
"
0,0.0,HumanEval_140_fix_spaces,"
std::string fix_spaces(std::string text) {
    std::string result;
    bool consecutive = false;
    for (char c : text) {
        if (c == ' ') {
            if (consecutive) {
                result.push_back('-');
            } else {
                result.push_back('_');
            }
            consecutive = true;
        } else {
            result.push_back(c);
            consecutive = false;
        }
    }
    return result;"
0,0.0,HumanEval_140_fix_spaces,"

std::string fix_spaces(std::string text) {
    std::string result;
    int count = 0;
    for(char c : text) {
        if(c == ' ') {
            count++;
            if(count == 1) {
                result += '_';
            }
            else if(count > 2) {
                result.pop_back();
                result += '-';
            }
        }
        else {
            result += c;
            count = 0;
        }
    }
    return result;"
0,0.0,HumanEval_140_fix_spaces,"

std::string fix_spaces(std::string text) {
    std::string result;
    int count = 0;
    for(char c : text) {
        if(c == ' ') {
            count++;
            if(count == 1) {
                result += '_';
            }
            else if(count > 2) {
                result.pop_back();
                result += '-';
            }
        }
        else {
            result += c;
            count = 0;
        }
    }
    return result;
"
0,0.0,HumanEval_140_fix_spaces,"
    std::string result;
    int count = 0;
    for (char c : text) {
        if (c == ' ') {
            count++;
            if (count == 2) {
                result += '-';
                count = 1; // reset count, but don't increment it
            }
        } else {
            if (count > 2) {
                result += '_';
            }
            result += c;
            count = 0; // reset count
        }
    }
    return result;"
1,1.0,HumanEval_63_fibfib,"
long fibfib(long n) {
    if (n == 0) return 0;
    if (n == 1) return 0;
    if (n == 2) return 1;

    long fibfib_values[n+1];
    fibfib_values[0] = 0;
    fibfib_values[1] = 0;
    fibfib_values[2] = 1;

    for (long i = 3; i <= n; i++) {
        fibfib_values[i] = fibfib_values[i-1] + fibfib_values[i-2] + fibfib_values[i-3];
    }

    return fibfib_values[n];
"
1,1.0,HumanEval_63_fibfib,"

long fibfib(long n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 0;
    }
    if (n == 2) {
        return 1;
    }

    long a = 0;
    long b = 0;
    long c = 1;
    long d;

    for (long i = 3; i <= n; i++) {
        d = a + b + c;
        a = b;
        b = c;
        c = d;
    }

    return d;"
1,1.0,HumanEval_63_fibfib,"

long fibfib(long n) {
    if(n == 0) return 0;
    if(n == 1) return 0;
    if(n == 2) return 1;

    long a = 0, b = 0, c = 1;
    for(long i = 3; i <= n; i++) {
        long temp = a + b + c;
        a = b;
        b = c;
        c = temp;
    }
    return c;"
1,1.0,HumanEval_63_fibfib,"
long fibfib(long n) {
    assert(n >= 0);
    if (n == 0 || n == 1)
        return 0;
    if (n == 2)
        return 1;

    std::vector<long> dp(n+1);
    dp[0] = 0;
    dp[1] = 0;
    dp[2] = 1;

    for (long i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
    }

    return dp[n];"
1,1.0,HumanEval_63_fibfib,"

long fibfib(long n) {
    if(n == 0)
        return 0;
    if(n == 1)
        return 0;
    if(n == 2)
        return 1;

    long fibfib_values[n+1];
    fibfib_values[0] = 0;
    fibfib_values[1] = 0;
    fibfib_values[2] = 1;

    for(long i = 3; i <= n; i++) {
        fibfib_values[i] = fibfib_values[i-1] + fibfib_values[i-2] + fibfib_values[i-3];
    }

    return fibfib_values[n];"
1,1.0,HumanEval_63_fibfib,"
long fibfib(long n) {
    if(n == 0)
        return 0;
    if(n == 1)
        return 0;
    if(n == 2)
        return 1;

    long fibfibNMinus1 = 1;
    long fibfibNMinus2 = 0;
    long fibfibNMinus3 = 0;
    long fibfibN = 0;

    for(long i = 3; i <= n; i++) {
        fibfibN = fibfibNMinus1 + fibfibNMinus2 + fibfibNMinus3;
        fibfibNMinus3 = fibfibNMinus2;
        fibfibNMinus2 = fibfibNMinus1;
        fibfibNMinus1 = fibfibN;
    }

    return fibfibN;
"
1,1.0,HumanEval_63_fibfib,"
long fibfib(long n) {
    if (n == 0)
        return 0;
    else if (n == 1)
        return 0;
    else if (n == 2)
        return 1;
    else {
        long a = 0, b = 0, c = 1;
        long result = 0;
        for (long i = 3; i <= n; i++) {
            result = a + b + c;
            a = b;
            b = c;
            c = result;
        }
        return result;
    }
"
1,1.0,HumanEval_63_fibfib,"
long fibfib(long n) {
    if(n == 0)
        return 0;
    if(n == 1)
        return 0;
    if(n == 2)
        return 1;

    long a = 0, b = 0, c = 1;
    long res = 0;
    for(long i = 3; i <= n; i++) {
        res = a + b + c;
        a = b;
        b = c;
        c = res;
    }
    return res;
"
1,1.0,HumanEval_63_fibfib,"

long fibfib(long n) {
    assert(n >= 0);
    
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 0;
    } else if (n == 2) {
        return 1;
    } else {
        long a = 0, b = 0, c = 1;
        for (long i = 3; i <= n; i++) {
            long temp = a + b + c;
            a = b;
            b = c;
            c = temp;
        }
        return c;
    }"
1,1.0,HumanEval_63_fibfib,"

long fibfib(long n) {
    assert(n >= 0);
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 0;
    }
    if (n == 2) {
        return 1;
    }
    std::vector<long> fibfib_sequence(n+1);
    fibfib_sequence[0] = 0;
    fibfib_sequence[1] = 0;
    fibfib_sequence[2] = 1;
    for (long i = 3; i <= n; i++) {
        fibfib_sequence[i] = fibfib_sequence[i-1] + fibfib_sequence[i-2] + fibfib_sequence[i-3];
    }
    return fibfib_sequence[n];"
0,1.0,HumanEval_151_double_the_difference,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

long double double_the_difference(std::vector<float> lst) {
    long long sum = 0;
    for(int i = 0; i < lst.size(); i++){
        if(lst[i] >= 0 && (long)lst[i] == lst[i]){
            sum += pow((long)lst[i], 2);
        }
    }
    return sum;"
0,0.0,HumanEval_151_double_the_difference,"

long double_the_difference(std::vector<float> lst) {
    long long sum = 0;
    for(auto num : lst){
        if(num >= 0 && floor(num) == num && num % 2 != 0){
            sum += pow(num, 2);
        }
    }
    return sum;"
1,0.0,HumanEval_151_double_the_difference,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

long double_the_difference(vector<float> lst) {
    long long sum = 0;
    for(float num : lst){
        if(num >= 0 && floor(num) == num){
            long long n = (long long)num;
            if(n % 2 != 0)
                sum += n*n;
        }
    }
    return sum;
"
0,0.0,HumanEval_151_double_the_difference,"
    long double sum = 0;
    for(auto num : lst) {
        if(num >= 0 && floor(num) == num && num % 2 != 0) {
            sum += num * num;
        }
    }
    return sum;"
0,0.0,HumanEval_151_double_the_difference,"
    long double sum = 0;
    for(int i = 0; i < lst.size(); i++) {
        if(lst[i] > 0 && floor(lst[i]) == lst[i] && (long)lst[i] % 2 != 0) {
            sum += lst[i]*lst[i];
        }
    }
    return sum;"
1,1.0,HumanEval_151_double_the_difference,"
long double_the_difference(std::vector<float> lst) {
    long long int sum_of_squares = 0;
    for(int i=0; i<lst.size(); i++) {
        // Check if the number is a positive integer
        if(lst[i] > 0 && lst[i] == (long)lst[i]) {
            // Check if the number is odd
            if((long)lst[i] % 2 == 1) {
                // Add the square of the number to the sum
                sum_of_squares += (long)lst[i] * (long)lst[i];
            }
        }
    }
    return sum_of_squares;"
1,1.0,HumanEval_151_double_the_difference,"

long double_the_difference(std::vector<float> lst) {
    long sum = 0;
    for(float num : lst){
        // Check if the number is an integer, positive, and odd
        if(num > 0 && floor(num) == num && fmod(num, 2) == 1){
            sum += num * num;
        }
    }
    return sum;"
1,1.0,HumanEval_151_double_the_difference,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

// Given a vector of numbers, return the sum of squares of the numbers
// in the vector that are odd. Ignore numbers that are negative or not integers.
long double_the_difference(vector<float> lst) {
    long long sum = 0;
    for(int i = 0; i < lst.size(); i++) {
        if(lst[i] >= 0 && floor(lst[i]) == lst[i] && lst[i] != (long)lst[i]/2*2) {
            sum += pow((long)lst[i], 2);
        }
    }
    return sum;
"
0,1.0,HumanEval_151_double_the_difference,"

long double_the_difference(std::vector<float> lst) {
    long long sum = 0;

    for(int i = 0; i < lst.size(); i++) {
        if(lst[i] > 0 && floor(lst[i]) == lst[i] && lst[i] % 2 != 0) {
            sum += (long long)pow(lst[i], 2);
        }
    }

    return sum;"
1,1.0,HumanEval_151_double_the_difference,"
long double_the_difference(std::vector<float> lst) {
    long long sum = 0;
    for (float num : lst) {
        if (num > 0 && floor(num) == num && (long)num % 2 != 0) {
            sum += (long)num * (long)num;
        }
    }
    return sum;"
0,1.0,HumanEval_22_filter_integers,"

std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;
    for (const auto& value : values) {
        if (std::any_cast<long>(&value) != nullptr) {
            result.push_back(std::any_cast<long>(value));
        }
    }
    return result;"
0,1.0,HumanEval_22_filter_integers,"
std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;
    for(auto& value : values) {
        if(std::any_cast<long>(&value) != nullptr) {
            result.push_back(std::any_cast<long>(value));
        }
    }
    return result;"
0,0.0,HumanEval_22_filter_integers,"
    std::vector<long> result;
    for (const auto& value : values) {
        if (std::any_cast<std::string>(&value) == nullptr) {
            if (std::any_cast<long>(&value) != nullptr) {
                result.push_back(std::any_cast<long>(value));
            }
        }
    }
    return result;
"
0,1.0,HumanEval_22_filter_integers,"

std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;

    for(auto value : values) {
        if(std::any_cast<long>(&value) != nullptr) {
            result.push_back(std::any_cast<long>(value));
        }
    }

    return result;
"
0,0.0,HumanEval_22_filter_integers,"

std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;
    for(auto& value : values) {
        if(std::any_cast<long>(&value)) {
            result.push_back(std::any_cast<long>(value));
        }
    }
    return result;
"
1,0.0,HumanEval_22_filter_integers,"
std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;
    for (auto &value : values) {
        if (std::any_cast<std::string>(&value) != nullptr) {
            try {
                long val = std::stol(std::any_cast<std::string>(value));
                result.push_back(val);
            } catch (const std::exception&) {
                // Ignore non-integer strings
            }
        } else if (std::any_cast<float>(&value) != nullptr) {
            if (std::floor(std::any_cast<float>(value)) == std::any_cast<float>(value)) {
                result.push_back(static_cast<long>(std::any_cast<float>(value)));
            }
        } else if (std::any_cast<double>(&value) != nullptr) {
            if (std::floor(std::any_cast<double>(value)) == std::any_cast<double>(value)) {
                result.push_back(static_cast<long>(std::any_cast<double>(value)));
            }
        } else if (std::any_cast<long>(&value) != nullptr) {
            result.push_back(std::any_cast<long>(value));
        } else if (std::any_cast<int>(&value) != nullptr) {
            result.push_back(static_cast<long>(std::any_cast<int>(value)));
        } else if (std::any_cast<short>(&value) != nullptr) {
            result.push_back(static_cast<long>(std::any_cast<short>(value)));
        } else if (std::any_cast<char>(&value) != nullptr) {
            result.push_back(static_cast<long>(std::any_cast<char>(value)));
        }
    }
    return result;
"
0,1.0,HumanEval_22_filter_integers,"
std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;
    for (const auto &value : values) {
        if (std::any_cast<long>(&value)) {
            result.push_back(std::any_cast<long>(value));
        }
    }
    return result;"
1,1.0,HumanEval_22_filter_integers,"
std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;
    for (const auto& value : values) {
        if (std::any_cast<std::string>(&value) != nullptr) {
            try {
                long long_value = std::stoll(std::any_cast<std::string>(value));
                result.push_back(long_value);
            } catch (const std::invalid_argument&) {
                // Ignore non-integer strings
            }
        } else if (std::any_cast<long>(&value) != nullptr) {
            result.push_back(std::any_cast<long>(value));
        } else if (std::any_cast<int>(&value) != nullptr) {
            result.push_back(std::any_cast<int>(value));
        } else if (std::any_cast<short>(&value) != nullptr) {
            result.push_back(std::any_cast<short>(value));
        } else if (std::any_cast<char>(&value) != nullptr) {
            result.push_back(std::any_cast<char>(value));
        }
    }
    return result;
"
0,1.0,HumanEval_22_filter_integers,"

std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;
    for(auto val : values) {
        if(std::any_cast<long>(&val) != nullptr) {
            result.push_back(std::any_cast<long>(val));
        }
    }
    return result;"
0,1.0,HumanEval_22_filter_integers,"
std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;
    for (const auto& value : values) {
        try {
            result.push_back(std::any_cast<long>(value));
        } catch (const std::bad_any_cast& e) {
            // ignore values that cannot be cast to long
        }
    }
    return result;"
0,1.0,HumanEval_41_car_race_collision,"

long car_race_collision(long n) {
    return 0;
"
1,1.0,HumanEval_41_car_race_collision,"
long car_race_collision(long n) {
    return n * n;
"
0,0.0,HumanEval_41_car_race_collision,"
long car_race_collision(long n) {
    assert(n >= 0);  // ensure n is non-negative
    return n * (n - 1) / 2;  // calculate number of combinations"
1,1.0,HumanEval_41_car_race_collision,"
long car_race_collision(long n) {
    assert(n > 0);
    return n * n;
"
0,0.0,HumanEval_41_car_race_collision,"
return n * (n - 1) / 2;"
1,1.0,HumanEval_41_car_race_collision,"
long car_race_collision(long n) {
    // The number of collisions will be the product of the number of cars moving in
    // each direction, which is n.
    return n * n;
"
0,0.0,HumanEval_41_car_race_collision,"

long car_race_collision(long n) {
    return n * (n - 1) / 2;
"
0,1.0,HumanEval_41_car_race_collision,"
long car_race_collision(long n) {
    return n;"
0,0.0,HumanEval_41_car_race_collision,"
long car_race_collision(long n) {
    // generate the array of cars moving left to right and right to left
    std::vector<long> left_to_right(n), right_to_left(n);
    for (long i = 0; i < n; i++) {
        left_to_right[i] = i;
        right_to_left[i] = n - i - 1;
    }

    // merge the arrays and count the number of inversions
    std::vector<long> merged(2 * n);
    long inversions = 0;
    long i = 0, j = 0;
    while (i < n && j < n) {
        if (left_to_right[i] <= right_to_left[j]) {
            merged[i + j] = left_to_right[i];
            i++;
        } else {
            merged[i + j] = right_to_left[j];
            inversions += n - i;
            j++;
        }
    }
    while (i < n) {
        merged[i + j] = left_to_right[i];
        i++;
    }
    while (j < n) {
        merged[i + j] = right_to_left[j];
        j++;
    }

    return inversions;"
0,0.0,HumanEval_41_car_race_collision,"
long car_race_collision(long n) {
    return (n * (n - 1)) / 2;
"
0,1.0,HumanEval_17_parse_music,"

std::vector<long> parse_music(std::string music_string) {
    std::vector<long> beats;
    long count = 0;
    for (size_t i = 0; i < music_string.size(); i++) {
        switch (music_string[i]) {
            case 'o':
                count = 4;
                beats.push_back(count);
                break;
            case '|':
                count /= 2;
                break;
            case '.':
                count /= 4;
                break;
            default:
                break;
        }
    }
    return beats;
"
0,1.0,HumanEval_17_parse_music,"

std::vector<long> parse_music(std::string music_string) {
    std::vector<long> beats;
    long current_beat = 0;
    for(size_t i = 0; i < music_string.size(); ++i) {
        switch(music_string[i]) {
            case 'o':
                current_beat = 4;
                break;
            case 'o':
                if(music_string[i+1] == '|') {
                    current_beat = 2;
                    i++;
                }
                break;
            case '.':
                if(music_string[i+1] == '|') {
                    current_beat = 1;
                    i++;
                }
                break;
            default:
                continue;
        }
        beats.push_back(current_beat);
    }
    return beats;
"
0,1.0,HumanEval_17_parse_music,"
std::vector<long> parse_music(std::string music_string) {
    std::vector<long> result;
    long count = 0;
    for (size_t i = 0; i < music_string.size(); ++i) {
        if (music_string[i] == 'o') {
            if (i + 1 < music_string.size() && music_string[i + 1] == '|') {
                count = 4;
                i++;
            } else {
                count = 1;
            }
        } else if (music_string[i] == '.') {
            if (i + 1 < music_string.size() && music_string[i + 1] == '|') {
                count = 1;
                i++;
            }
        }
        result.push_back(count);
    }
    return result;"
1,1.0,HumanEval_17_parse_music,"

std::vector<long> parse_music(std::string music_string) {
    std::vector<long> beats;
    std::istringstream iss(music_string);
    std::string note;

    while (iss >> note) {
        if (note == ""o"") {
            beats.push_back(4);
        } else if (note == ""o|"") {
            beats.push_back(2);
        } else if (note == "".|"") {
            beats.push_back(1);
        }
    }

    return beats;"
1,1.0,HumanEval_17_parse_music,"
std::vector<long> parse_music(std::string music_string) {
    std::vector<long> beats;
    std::stringstream ss(music_string);
    std::string note;

    while (ss >> note) {
        if (note == ""o"") {
            beats.push_back(4);
        } else if (note == ""o|"") {
            beats.push_back(2);
        } else if (note == "".|"") {
            beats.push_back(1);
        } else {
            assert(false);  // Invalid note
        }
    }

    return beats;
"
1,1.0,HumanEval_17_parse_music,"
std::vector<long> parse_music(std::string music_string) {
    std::vector<long> result;
    std::istringstream iss(music_string);
    std::string note;
    while (iss >> note) {
        if (note == ""o"") {
            result.push_back(4);
        } else if (note == ""o|"") {
            result.push_back(2);
        } else if (note == "".|"") {
            result.push_back(1);
        }
    }
    return result;"
1,1.0,HumanEval_17_parse_music,"

std::vector<long> parse_music(std::string music_string) {
    std::vector<long> beats;
    std::stringstream ss(music_string);
    std::string note;

    while (ss >> note) {
        if (note == ""o"") {
            beats.push_back(4);
        } else if (note == ""o|"") {
            beats.push_back(2);
        } else if (note == "".|"") {
            beats.push_back(1);
        }
    }

    return beats;"
1,1.0,HumanEval_17_parse_music,"

std::vector<long> parse_music(std::string music_string) {
    std::vector<long> beats;
    std::stringstream ss(music_string);
    std::string note;
    while (ss >> note) {
        if (note == ""o"") {
            beats.push_back(4);
        } else if (note == ""o|"") {
            beats.push_back(2);
        } else if (note == "".|"") {
            beats.push_back(1);
        }
    }
    return beats;"
1,1.0,HumanEval_17_parse_music,"

std::vector<long> parse_music(std::string music_string) {
    std::vector<long> beats;
    std::stringstream ss(music_string);
    std::string note;
    while (ss >> note) {
        if (note == ""o"") {
            beats.push_back(4);
        } else if (note == ""o|"") {
            beats.push_back(2);
        } else if (note == "".|"") {
            beats.push_back(1);
        } else {
            // This should never happen because the input is guaranteed to be valid.
            assert(false);
        }
    }
    return beats;
"
0,1.0,HumanEval_17_parse_music,"

std::vector<long> parse_music(std::string music_string) {
    std::vector<long> beats;
    std::stringstream ss(music_string);
    char c;
    while (ss >> c) {
        switch (c) {
            case 'o':
                beats.push_back(4);
                break;
            case '|':
                if (ss.peek() == '.') {
                    ss.ignore();
                    beats.push_back(1);
                } else if (ss.peek() == 'o') {
                    ss.ignore();
                    beats.push_back(2);
                }
                break;
            default:
                assert(false);
        }
    }
    return beats;
"
0,1.0,HumanEval_79_decimal_to_binary,"
std::string decimal_to_binary(long decimal) {
    std::string binary = """";
    while (decimal > 0) {
        binary = std::to_string(decimal % 2) + binary;
        decimal /= 2;
    }
    return ""db"" + binary + ""db"";
"
0,1.0,HumanEval_79_decimal_to_binary,"
std::string decimal_to_binary(long decimal) {
    std::string binary = """";
    while (decimal > 0) {
        binary = std::to_string(decimal % 2) + binary;
        decimal /= 2;
    }
    return ""db"" + binary + ""db"";"
0,1.0,HumanEval_79_decimal_to_binary,"

std::string decimal_to_binary(long decimal) {
    std::string binary = """";
    while (decimal > 0) {
        binary = std::to_string(decimal % 2) + binary;
        decimal /= 2;
    }
    while (binary.size() < 8) {
        binary = ""0"" + binary;
    }
    return ""db"" + binary + ""db"";"
0,1.0,HumanEval_79_decimal_to_binary,"
std::string decimal_to_binary(long decimal) {
    std::string binary = """";
    while (decimal > 0) {
        binary = std::to_string(decimal % 2) + binary;
        decimal /= 2;
    }
    return ""db"" + binary + ""db"";
"
0,1.0,HumanEval_79_decimal_to_binary,"

std::string decimal_to_binary(long decimal) {
    std::string binary = """";
    while (decimal > 0) {
        binary = std::to_string(decimal % 2) + binary;
        decimal /= 2;
    }
    // Add leading zeros to make the length a multiple of 4
    while (binary.length() % 4 != 0) {
        binary = ""0"" + binary;
    }
    // Insert 'db' at the beginning and end of the string
    binary = ""db"" + binary + ""db"";
    return binary;"
0,1.0,HumanEval_79_decimal_to_binary,"

std::string decimal_to_binary(long decimal) {
    std::string binary = """";
    while(decimal > 0) {
        binary = std::to_string(decimal % 2) + binary;
        decimal /= 2;
    }
    return ""db"" + binary + ""db"";
"
0,1.0,HumanEval_79_decimal_to_binary,"

std::string decimal_to_binary(long decimal) {
    std::string binary = """";
    while (decimal > 0) {
        binary = std::to_string(decimal % 2) + binary;
        decimal /= 2;
    }
    while (binary.length() < 8) {
        binary = ""0"" + binary;
    }
    return ""db"" + binary + ""db"";"
0,1.0,HumanEval_79_decimal_to_binary,"
std::string decimal_to_binary(long decimal) {
    std::string binary = """";
    while (decimal > 0) {
        binary = std::to_string(decimal % 2) + binary;
        decimal /= 2;
    }
    return ""db"" + binary + ""db"";"
0,1.0,HumanEval_79_decimal_to_binary,"
std::string decimal_to_binary(long decimal) {
    std::string binary = """";
    while(decimal > 0) {
        binary = std::to_string(decimal % 2) + binary;
        decimal /= 2;
    }
    return ""db"" + binary + ""db"";
"
0,1.0,HumanEval_79_decimal_to_binary,"
std::string decimal_to_binary(long decimal) {
    std::string binary = """";
    while (decimal > 0) {
        binary = std::to_string(decimal % 2) + binary;
        decimal /= 2;
    }
    return ""db"" + binary + ""db"";
"
1,1.0,HumanEval_14_all_prefixes,"
#include<assert.h>
#include<bits/stdc++.h>

// Return vector of all prefixes from shortest to longest of the input string
std::vector<std::string> all_prefixes(std::string str) {
    std::vector<std::string> prefixes;
    for (size_t i = 0; i < str.size(); i++) {
        prefixes.push_back(str.substr(0, i + 1));
    }
    return prefixes;
"
0,0.0,HumanEval_14_all_prefixes,"
    std::vector<std::string> prefixes;
    for (size_t i = 0; i < string.size(); i++) {
        prefixes.push_back(string.substr(0, i + 1));
    }
    return prefixes;"
1,1.0,HumanEval_14_all_prefixes,"
#include<assert.h>
#include<bits/stdc++.h>

// Return vector of all prefixes from shortest to longest of the input string
std::vector<std::string> all_prefixes(std::string str) {
    std::vector<std::string> prefixes;
    for (size_t i = 0; i < str.size(); i++) {
        prefixes.push_back(str.substr(0, i+1));
    }
    return prefixes;
"
0,0.0,HumanEval_14_all_prefixes,"
    std::vector<std::string> prefixes;
    for (size_t i = 0; i < string.size(); i++) {
        prefixes.push_back(string.substr(0, i+1));
    }
    return prefixes;"
0,0.0,HumanEval_14_all_prefixes,"
    std::vector<std::string> result;
    for (size_t i = 0; i < string.size(); i++) {
        result.push_back(string.substr(0, i + 1));
    }
    return result;"
0,0.0,HumanEval_14_all_prefixes,"
    std::vector<std::string> result;
    for (int i = 0; i < string.size(); i++) {
        result.push_back(string.substr(0, i + 1));
    }
    return result;"
0,0.0,HumanEval_14_all_prefixes,"
    std::vector<std::string> result;
    for (size_t i = 0; i < string.size(); ++i) {
        result.push_back(string.substr(0, i + 1));
    }
    return result;"
1,1.0,HumanEval_14_all_prefixes,"
#include<assert.h>
#include<bits/stdc++.h>

// Return vector of all prefixes from shortest to longest of the input string
// >>> all_prefixes((""abc""))
// (std::vector<std::string>({(std::string)""a"", (std::string)""ab"", (std::string)""abc""}))
std::vector<std::string> all_prefixes(std::string str) {
    std::vector<std::string> prefixes;
    for (size_t i = 0; i < str.size(); i++) {
        prefixes.push_back(str.substr(0, i + 1));
    }
    return prefixes;
"
1,1.0,HumanEval_14_all_prefixes,"
std::vector<std::string> all_prefixes(std::string str) {
    std::vector<std::string> prefixes;
    for (size_t i = 0; i < str.size(); i++) {
        prefixes.push_back(str.substr(0, i + 1));
    }
    return prefixes;"
1,1.0,HumanEval_14_all_prefixes,"
#include<assert.h>
#include<bits/stdc++.h>

// Return vector of all prefixes from shortest to longest of the input string
std::vector<std::string> all_prefixes(std::string str) {
    std::vector<std::string> prefixes;
    for (int i = 0; i < str.size(); i++) {
        prefixes.push_back(str.substr(0, i + 1));
    }
    return prefixes;
"
1,1.0,HumanEval_53_add,"
long add(long x, long y) {
    return x + y;
"
0,0.0,HumanEval_53_add,"
    return x + y;"
0,0.0,HumanEval_53_add,"
    return x + y;"
1,1.0,HumanEval_53_add,"
long add(long x, long y) {
    return x + y;"
0,0.0,HumanEval_53_add,"
    return x + y;"
1,1.0,HumanEval_53_add,"

long add(long x, long y) {
    return x + y;
"
1,1.0,HumanEval_53_add,"
long add(long x, long y) {
    return x + y;"
0,0.0,HumanEval_53_add,"
    return x+y;"
0,0.0,HumanEval_53_add,"
    return x + y;"
1,1.0,HumanEval_53_add,"
long add(long x, long y) {
    return x + y;
"
1,1.0,HumanEval_159_eat,"
std::vector<long> eat(long number, long need, long remaining) {
    assert(0 <= number && number <= 1000);
    assert(0 <= need && need <= 1000);
    assert(0 <= remaining && remaining <= 1000);

    long total_eaten = number;
    long eaten = std::min(need, remaining);
    total_eaten += eaten;
    long left = remaining - eaten;

    return {total_eaten, left};"
1,1.0,HumanEval_159_eat,"
std::vector<long> eat(long number, long need, long remaining) {
    assert(0 <= number && number <= 1000);
    assert(0 <= need && need <= 1000);
    assert(0 <= remaining && remaining <= 1000);

    long total_eaten = number;
    if (need <= remaining) {
        total_eaten += need;
        remaining -= need;
    } else {
        total_eaten += remaining;
        remaining = 0;
    }

    return {total_eaten, remaining};"
1,1.0,HumanEval_159_eat,"
std::vector<long> eat(long number, long need, long remaining) {
    if(remaining >= need) {
        return {number + need, remaining - need};
    } else {
        return {number + remaining, 0};
    }"
0,0.0,HumanEval_159_eat,"
    // Calculate the total number of carrots eaten
    long total = number + need;

    // Calculate the number of carrots left after meals
    long left = total <= remaining ? 0 : total - remaining;

    // Return the result as a vector
    return {total, left};"
1,1.0,HumanEval_159_eat,"
std::vector<long> eat(long number, long need, long remaining) {
    assert(0 <= number && number <= 1000);
    assert(0 <= need && need <= 1000);
    assert(0 <= remaining && remaining <= 1000);

    long total = number;
    if (need <= remaining) {
        total += need;
        remaining -= need;
    } else {
        total += remaining;
        remaining = 0;
    }
    return {total, remaining};
"
1,1.0,HumanEval_159_eat,"
std::vector<long> eat(long number, long need, long remaining) {
    assert(0 <= number && number <= 1000);
    assert(0 <= need && need <= 1000);
    assert(0 <= remaining && remaining <= 1000);

    long total_eaten = number;
    if (need < remaining) {
        total_eaten += need;
        remaining -= need;
    } else {
        total_eaten += remaining;
        remaining = 0;
    }

    return std::vector<long>{total_eaten, remaining};"
1,1.0,HumanEval_159_eat,"

std::vector<long> eat(long number, long need, long remaining) {
    assert(0 <= number && number <= 1000);
    assert(0 <= need && need <= 1000);
    assert(0 <= remaining && remaining <= 1000);

    long total = number;

    if(need <= remaining) {
        total += need;
        remaining -= need;
    } else {
        total += remaining;
        remaining = 0;
    }

    return {total, remaining};
"
1,1.0,HumanEval_159_eat,"
std::vector<long> eat(long number, long need, long remaining) {
    assert(0 <= number && number <= 1000);
    assert(0 <= need && need <= 1000);
    assert(0 <= remaining && remaining <= 1000);

    long total = number;
    if (need <= remaining) {
        total += need;
        remaining -= need;
    } else {
        total += remaining;
        remaining = 0;
    }

    return {total, remaining};
"
1,1.0,HumanEval_159_eat,"
std::vector<long> eat(long number, long need, long remaining) {
    assert(0 <= number && number <= 1000);
    assert(0 <= need && need <= 1000);
    assert(0 <= remaining && remaining <= 1000);

    long total = number;
    if (need <= remaining) {
        total += need;
        remaining -= need;
    } else {
        total += remaining;
        remaining = 0;
    }
    return {total, remaining};
"
1,1.0,HumanEval_159_eat,"
std::vector<long> eat(long number, long need, long remaining) {
    assert(0 <= number && number <= 1000);
    assert(0 <= need && need <= 1000);
    assert(0 <= remaining && remaining <= 1000);

    long total_eaten = number;
    if (need <= remaining) {
        total_eaten += need;
        remaining -= need;
    } else {
        total_eaten += remaining;
        remaining = 0;
    }

    return {total_eaten, remaining};"
0,0.0,HumanEval_115_max_fill,"
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
    long rows = grid.size();
    long cols = grid[0].size();
    long count = 0;

    for (long i = 0; i < rows; i++) {
        for (long j = 0; j < cols; j++) {
            if (grid[i][j] == 1) {
                count += capacity;
            }
        }
    }

    return count;"
0,0.0,HumanEval_115_max_fill,"

long max_fill(std::vector<std::vector<long>> grid, long capacity) {
    long count = 0;
    for (long i = 0; i < grid.size(); i++) {
        for (long j = 0; j < grid[i].size(); j++) {
            if (grid[i][j] == 1) {
                count += capacity;
            }
        }
    }
    return count;"
0,0.0,HumanEval_115_max_fill,"
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
    long drops = 0;
    for (auto& row : grid) {
        for (auto& cell : row) {
            if (cell == 1) {
                capacity -= 1;
                if (capacity == 0) {
                    drops += 1;
                    capacity = capacity;
                }
            }
        }
    }
    return drops;"
0,0.0,HumanEval_115_max_fill,"

long max_fill(std::vector<std::vector<long>> grid, long capacity) {
    long rows = grid.size();
    long cols = grid[0].size();
    long count = 0;

    for (long i = 0; i < rows; i++) {
        for (long j = 0; j < cols; j++) {
            if (grid[i][j] == 1) {
                count += capacity;
            }
        }
    }

    return count;
"
0,0.0,HumanEval_115_max_fill,"
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
    long n = grid.size();
    long m = grid[0].size();
    long count = 0;
    for (long i = 0; i < n; i++) {
        for (long j = 0; j < m; j++) {
            if (grid[i][j] == 1) {
                count += capacity;
            }
        }
    }
    return count;"
0,0.0,HumanEval_115_max_fill,"
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
    long count = 0;
    for (int i = 0; i < grid.size(); i++) {
        for (int j = 0; j < grid[i].size(); j++) {
            if (grid[i][j] == 1) {
                count += capacity;
            }
        }
    }
    return count;
"
0,0.0,HumanEval_115_max_fill,"
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
    long total_wells = 0;
    for(auto row : grid) {
        total_wells += std::count(row.begin(), row.end(), 1);
    }
    return (total_wells + capacity - 1) / capacity;
"
0,0.0,HumanEval_115_max_fill,"

long max_fill(std::vector<std::vector<long>> grid, long capacity) {
    long total_wells = 0;
    long total_water = 0;
    long total_buckets = 0;
    long filled_wells = 0;
    long filled_buckets = 0;

    for (auto row : grid) {
        for (auto well : row) {
            if (well == 1) {
                total_wells++;
                total_water++;
            }
        }
    }

    total_buckets = total_water / capacity;
    if (total_water % capacity != 0) total_buckets++;

    for (auto row : grid) {
        for (auto well : row) {
            if (well == 1 && filled_buckets > 0) {
                filled_buckets--;
                filled_wells++;
            }
        }
    }

    return total_wells - filled_wells;"
0,1.0,HumanEval_115_max_fill,"

long max_fill(std::vector<std::vector<long>> grid, long capacity) {
    long count = 0;
    for (long i = 0; i < grid.size(); i++) {
        for (long j = 0; j < grid[i].size(); j++) {
            if (grid[i][j] == 1) {
                count += (capacity - 1);
            }
        }
    }
    return count;
"
0,0.0,HumanEval_115_max_fill,"
    long count = 0;
    for (long i = 0; i < grid.size(); i++) {
        for (long j = 0; j < grid[i].size(); j++) {
            if (grid[i][j] == 1) {
                count += (capacity - 1) / 2 + 1;
            }
        }
    }
    return count;"
0,0.0,HumanEval_160_do_algebra,"
long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    assert(op.size() == operand.size() - 1);
    assert(op.size() > 0);
    assert(operand.size() > 1);

    long result = operand[0];
    for (size_t i = 1; i < operand.size(); ++i) {
        if (op[i-1] == ""+"") {
            result += operand[i];
        } else if (op[i-1] == ""-"") {
            result -= operand[i];
        } else if (op[i-1] == ""*"") {
            result *= operand[i];
        } else if (op[i-1] == ""//"") {
            result /= operand[i];
        } else if (op[i-1] == ""**"") {
            result = pow(result, operand[i]);
        }
    }
    return result;
"
0,0.0,HumanEval_160_do_algebra,"

long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    assert(op.size() == operand.size() - 1);
    assert(op.size() >= 1);
    assert(operand.size() >= 2);

    std::string operations = ""+-*/"";

    std::stack<long> nums;
    std::stack<char> ops;

    nums.push(operand[0]);

    for (int i = 1; i < operand.size(); i++) {
        while (!ops.empty() && operations.find(ops.top()) > operations.find(op[i-1])) {
            char op = ops.top(); ops.pop();
            long num2 = nums.top(); nums.pop();
            long num1 = nums.top(); nums.pop();
            switch (op) {
                case '+': nums.push(num1 + num2); break;
                case '-': nums.push(num1 - num2); break;
                case '*': nums.push(num1 * num2); break;
                case '/': nums.push(num1 / num2); break;
            }
        }
        ops.push(op[i-1]);
        nums.push(operand[i]);
    }

    while (!ops.empty()) {
        char op = ops.top(); ops.pop();
        long num2 = nums.top(); nums.pop();
        long num1 = nums.top(); nums.pop();
        switch (op) {
            case '+': nums.push(num1 + num2); break;
            case '-': nums.push(num1 - num2); break;
            case '*': nums.push(num1 * num2); break;
            case '/': nums.push(num1 / num2); break;
        }
    }

    return nums.top();
"
0,0.0,HumanEval_160_do_algebra,"
long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    assert(op.size() == operand.size() - 1);

    long result = operand[0];
    for (size_t i = 1; i < operand.size(); ++i) {
        if (op[i-1] == ""+"") {
            result += operand[i];
        } else if (op[i-1] == ""-"") {
            result -= operand[i];
        } else if (op[i-1] == ""*"") {
            result *= operand[i];
        } else if (op[i-1] == ""/"") {
            assert(operand[i] != 0);
            result /= operand[i];
        } else if (op[i-1] == ""**"") {
            result = std::pow(result, operand[i]);
        } else {
            assert(false);
        }
    }

    return result;"
0,0.0,HumanEval_160_do_algebra,"

long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    assert(op.size() == operand.size() - 1);
    long result = operand[0];
    for (int i = 1; i < operand.size(); i++) {
        if (op[i-1] == ""+"") {
            result += operand[i];
        } else if (op[i-1] == ""-"") {
            result -= operand[i];
        } else if (op[i-1] == ""*"") {
            result *= operand[i];
        } else if (op[i-1] == ""//"") {
            result /= operand[i];
        } else if (op[i-1] == ""**"") {
            result = pow(result, operand[i]);
        }
    }
    return result;"
0,0.0,HumanEval_160_do_algebra,"
long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    assert(op.size() == operand.size() - 1);
    assert(operand.size() >= 2);

    std::stack<long> stk;
    for (size_t i = 0; i < operand.size(); ++i) {
        stk.push(operand[i]);
    }

    for (size_t i = 0; i < op.size(); ++i) {
        long rhs = stk.top();
        stk.pop();
        long lhs = stk.top();
        stk.pop();

        if (op[i] == ""+"") {
            stk.push(lhs + rhs);
        } else if (op[i] == ""-"") {
            stk.push(lhs - rhs);
        } else if (op[i] == ""*"") {
            stk.push(lhs * rhs);
        } else if (op[i] == ""/"") {
            stk.push(lhs / rhs);
        } else if (op[i] == ""**"") {
            stk.push(pow(lhs, rhs));
        } else {
            assert(false);  // Invalid operator
        }
    }

    assert(stk.size() == 1);
    return stk.top();"
0,0.0,HumanEval_160_do_algebra,"

long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    assert(op.size() == operand.size() - 1);
    assert(op.size() >= 1);
    assert(operand.size() >= 2);

    std::string operations = ""+-*/"";
    std::stack<long> nums;
    std::stack<char> ops;

    for (int i = 0; i < operand.size(); i++) {
        nums.push(operand[i]);
        if (i < op.size()) {
            while (!ops.empty() && operations.find(ops.top()) != std::string::npos && operations.find(op[i]) <= operations.find(ops.top())) {
                long num2 = nums.top();
                nums.pop();
                long num1 = nums.top();
                nums.pop();
                char operation = ops.top();
                ops.pop();
                if (operation == '+') nums.push(num1 + num2);
                else if (operation == '-') nums.push(num1 - num2);
                else if (operation == '*') nums.push(num1 * num2);
                else if (operation == '/') nums.push(num1 / num2);
            }
            ops.push(op[i][0]);
        }
    }

    while (!ops.empty()) {
        long num2 = nums.top();
        nums.pop();
        long num1 = nums.top();
        nums.pop();
        char operation = ops.top();
        ops.pop();
        if (operation == '+') nums.push(num1 + num2);
        else if (operation == '-') nums.push(num1 - num2);
        else if (operation == '*') nums.push(num1 * num2);
        else if (operation == '/') nums.push(num1 / num2);
    }

    return nums.top();"
0,0.0,HumanEval_160_do_algebra,"
long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    assert(op.size() == operand.size() - 1);
    assert(op.size() >= 1);
    assert(operand.size() >= 2);

    long result = operand[0];
    for (int i = 1; i < operand.size(); i++) {
        if (op[i-1] == ""+"") {
            result += operand[i];
        } else if (op[i-1] == ""-"") {
            result -= operand[i];
        } else if (op[i-1] == ""*"") {
            result *= operand[i];
        } else if (op[i-1] == ""//"") {
            result /= operand[i];
        } else if (op[i-1] == ""**"") {
            result = std::pow(result, operand[i]);
        }
    }
    return result;"
0,0.0,HumanEval_160_do_algebra,"
long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    assert(op.size() == operand.size() - 1);
    assert(op.size() >= 1);
    assert(operand.size() >= 2);

    long result = operand[0];

    for (int i = 1; i < operand.size(); i++) {
        if (op[i-1] == ""+"") {
            result += operand[i];
        } else if (op[i-1] == ""-"") {
            result -= operand[i];
        } else if (op[i-1] == ""*"") {
            result *= operand[i];
        } else if (op[i-1] == ""/"") {
            result /= operand[i];
        } else if (op[i-1] == ""**"") {
            result = pow(result, operand[i]);
        }
    }

    return result;
"
0,0.0,HumanEval_160_do_algebra,"

long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    assert(op.size() == operand.size() - 1);
    assert(op.size() >= 1);
    assert(operand.size() >= 2);

    std::string operators = ""+-*/"";

    for (int i = 0; i < op.size(); i++) {
        assert(operators.find(op[i]) != std::string::npos);
    }

    long result = operand[0];

    for (int i = 1; i < operand.size(); i++) {
        if (op[i-1] == ""+"") {
            result += operand[i];
        } else if (op[i-1] == ""-"") {
            result -= operand[i];
        } else if (op[i-1] == ""*"") {
            result *= operand[i];
        } else if (op[i-1] == ""/"") {
            assert(operand[i] != 0);
            result /= operand[i];
        } else if (op[i-1] == ""**"") {
            result = pow(result, operand[i]);
        }
    }

    return result;"
0,0.0,HumanEval_160_do_algebra,"

long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    assert(op.size() == operand.size() - 1);
    assert(op.size() >= 1);
    assert(operand.size() >= 2);

    long result = operand[0];

    for (int i = 0; i < op.size(); i++) {
        if (op[i] == ""+"") {
            result += operand[i + 1];
        } else if (op[i] == ""-"") {
            result -= operand[i + 1];
        } else if (op[i] == ""*"") {
            result *= operand[i + 1];
        } else if (op[i] == ""/"") {
            assert(operand[i + 1] != 0);
            result /= operand[i + 1];
        } else if (op[i] == ""**"") {
            assert(operand[i + 1] >= 0);
            result = std::pow(result, operand[i + 1]);
        } else {
            assert(false);
        }
    }

    return result;"
0,0.0,HumanEval_27_flip_case,"
    for(int i = 0; i < string.size(); i++) {
        if(islower(string[i])) {
            string[i] = toupper(string[i]);
        } else if(isupper(string[i])) {
            string[i] = tolower(string[i]);
        }
    }
    return string;
"
0,0.0,HumanEval_27_flip_case,"
    for(int i=0; i<string.length(); i++){
        if(islower(string[i])){
            string[i] = toupper(string[i]);
        }
        else if(isupper(string[i])){
            string[i] = tolower(string[i]);
        }
    }
    return string;
"
0,0.0,HumanEval_27_flip_case,"
    for(int i = 0; i < string.length(); i++) {
        if(islower(string[i])) {
            string[i] = toupper(string[i]);
        } else if(isupper(string[i])) {
            string[i] = tolower(string[i]);
        }
    }
    return string;
"
0,0.0,HumanEval_27_flip_case,"
    for(int i=0; i<string.size(); i++) {
        if(islower(string[i])) {
            string[i] = toupper(string[i]);
        } else if(isupper(string[i])) {
            string[i] = tolower(string[i]);
        }
    }
    return string;
"
0,0.0,HumanEval_27_flip_case,"
    for(int i = 0; i < string.size(); i++) {
        if(islower(string[i]))
            string[i] = toupper(string[i]);
        else if(isupper(string[i]))
            string[i] = tolower(string[i]);
    }
    return string;
"
0,0.0,HumanEval_27_flip_case,"
    for(int i = 0; i < string.size(); i++) {
        if(isupper(string[i]))
            string[i] = tolower(string[i]);
        else if(islower(string[i]))
            string[i] = toupper(string[i]);
    }
    return string;
"
0,0.0,HumanEval_27_flip_case,"
    for(int i = 0; i < string.length(); i++) {
        if(islower(string[i])) {
            string[i] = toupper(string[i]);
        } else if(isupper(string[i])) {
            string[i] = tolower(string[i]);
        }
    }
    return string;
"
0,0.0,HumanEval_27_flip_case,"
    for(int i = 0; i < string.size(); i++) {
        if(isupper(string[i])) {
            string[i] = tolower(string[i]);
        } else if(islower(string[i])) {
            string[i] = toupper(string[i]);
        }
    }
    return string;
"
0,0.0,HumanEval_27_flip_case,"
    for(int i = 0; i < string.size(); i++) {
        if(islower(string[i])) {
            string[i] = toupper(string[i]);
        } else if(isupper(string[i])) {
            string[i] = tolower(string[i]);
        }
    }
    return string;
"
1,1.0,HumanEval_27_flip_case,"
#include<assert.h>
#include<bits/stdc++.h>

// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
std::string flip_case(std::string str) {
    for(int i=0; str[i]; i++){
        // Check if the character is uppercase
        if(isupper(str[i])){
            // Convert to lowercase
            str[i] = tolower(str[i]);
        }
        else if(islower(str[i])){
            // Convert to uppercase
            str[i] = toupper(str[i]);
        }
    }
    return str;
"
0,0.0,HumanEval_105_by_length,"

std::vector<std::string> by_length(std::vector<long> arr) {
    std::vector<std::string> num_names = {"""", ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""};
    std::vector<std::string> res;

    for(long num : arr) {
        if(num >= 1 && num <= 9) {
            res.push_back(num_names[num]);
        }
    }

    std::reverse(res.begin(), res.end());

    return res;"
0,0.0,HumanEval_105_by_length,"
std::vector<std::string> by_length(std::vector<long> arr) {
    std::vector<std::string> numbers = {""Zero"", ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""};
    std::vector<std::string> res;

    for (long num : arr) {
        if (num >= 1 && num <= 9) {
            res.push_back(numbers[num]);
        }
    }

    std::reverse(res.begin(), res.end());
    return res;"
0,1.0,HumanEval_105_by_length,"
std::vector<std::string> by_length(std::vector<long> arr) {
    std::map<long, std::string> num_map = {{1, ""One""}, {2, ""Two""}, {3, ""Three""}, {4, ""Four""}, {5, ""Five""}, {6, ""Six""}, {7, ""Seven""}, {8, ""Eight""}, {9, ""Nine""}};
    std::vector<long> filtered;
    for (long num : arr) {
        if (num_map.count(num) > 0) {
            filtered.push_back(num);
        }
    }
    std::reverse(filtered.begin(), filtered.end());
    std::vector<std::string> result;
    for (long num : filtered) {
        result.push_back(num_map[num]);
    }
    return result;"
0,0.0,HumanEval_105_by_length,"
std::vector<std::string> by_length(std::vector<long> arr) {
    std::vector<std::string> result;
    std::map<long, std::string> num_to_name = {{1, ""One""}, {2, ""Two""}, {3, ""Three""}, {4, ""Four""}, {5, ""Five""}, {6, ""Six""}, {7, ""Seven""}, {8, ""Eight""}, {9, ""Nine""}};

    for (long num : arr) {
        if (num_to_name.find(num) != num_to_name.end()) {
            result.push_back(num_to_name[num]);
        }
    }

    std::reverse(result.begin(), result.end());
    return result;"
0,1.0,HumanEval_105_by_length,"
std::vector<std::string> by_length(std::vector<long> arr) {
    std::vector<std::string> names = {""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""};
    std::vector<long> numbers;
    for (long num : arr) {
        if (num >= 1 && num <= 9) {
            numbers.push_back(num);
        }
    }
    std::reverse(numbers.begin(), numbers.end());
    std::vector<std::string> result;
    for (long num : numbers) {
        result.push_back(names[num - 1]);
    }
    return result;"
0,1.0,HumanEval_105_by_length,"
std::vector<std::string> by_length(std::vector<long> arr) {
    std::vector<std::string> num_names = {"""", ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""};
    std::vector<std::string> result;

    for(long num : arr) {
        if(num >= 1 && num <= 9) {
            result.push_back(num_names[num]);
        }
    }

    std::reverse(result.begin(), result.end());
    return result;
"
0,0.0,HumanEval_105_by_length,"
    std::vector<std::string> by_length(std::vector<long> arr) {
        std::vector<std::string> result;
        std::map<long, std::string> num_map = {{1, ""One""}, {2, ""Two""}, {3, ""Three""}, {4, ""Four""}, {5, ""Five""}, {6, ""Six""}, {7, ""Seven""}, {8, ""Eight""}, {9, ""Nine""}};

        for (long num : arr) {
            if (num >= 1 && num <= 9) {
                result.push_back(num_map[num]);
            }
        }

        std::reverse(result.begin(), result.end());
        return result;
"
0,1.0,HumanEval_105_by_length,"

std::vector<std::string> by_length(std::vector<long> arr) {
    std::vector<std::string> num_to_str = {"""", ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""};
    std::vector<int> nums;
    for(long num : arr) {
        if(num >= 1 && num <= 9) {
            nums.push_back(num);
        }
    }
    std::reverse(nums.begin(), nums.end());
    std::vector<std::string> result;
    for(int num : nums) {
        result.push_back(num_to_str[num]);
    }
    return result;
"
0,1.0,HumanEval_105_by_length,"
std::vector<std::string> by_length(std::vector<long> arr) {
    std::vector<std::string> num_names {"""", ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""};
    std::vector<std::string> result;

    for (long num : arr) {
        if (num >= 1 && num <= 9) {
            result.push_back(num_names[num]);
        }
    }

    std::reverse(result.begin(), result.end());
    return result;"
0,1.0,HumanEval_105_by_length,"

std::vector<std::string> by_length(std::vector<long> arr) {
    std::vector<std::string> numbers = {""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""};
    std::vector<std::string> result;

    for (long num : arr) {
        if (num >= 1 && num <= 9) {
            result.push_back(numbers[num - 1]);
        }
    }

    std::reverse(result.begin(), result.end());
    return result;"
1,1.0,HumanEval_25_factorize,"

std::vector<long> factorize(long n) {
    std::vector<long> factors;
    // Divide n by 2 until n is odd
    while (n % 2 == 0) {
        factors.push_back(2);
        n = n / 2;
    }

    // n must be odd at this point, so we can skip one element (Note i = i +2)
    for (long i = 3; i * i <= n; i = i + 2) {
        // While i divides n, append i and divide n
        while (n % i == 0) {
            factors.push_back(i);
            n = n / i;
        }
    }

    // This condition is to handle the case when n is a prime number
    // greater than 2
    if (n > 2)
        factors.push_back(n);
    
    return factors;
"
1,1.0,HumanEval_25_factorize,"
std::vector<long> factorize(long n) {
    std::vector<long> factors;

    // Divide n by 2 until n becomes odd
    while (n % 2 == 0) {
        factors.push_back(2);
        n /= 2;
    }

    // n is now odd, so we can skip one element (note i = i + 2)
    for (long i = 3; i * i <= n; i += 2) {
        // While i divides n, append i and divide n
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }

    // This condition is to handle the case when n is a prime number
    // greater than 2
    if (n > 2)
        factors.push_back(n);

    return factors;"
1,1.0,HumanEval_25_factorize,"
std::vector<long> factorize(long n) {
    std::vector<long> factors;
    for (long i = 2; i * i <= n; ++i) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) {
        factors.push_back(n);
    }
    return factors;"
1,1.0,HumanEval_25_factorize,"

std::vector<long> factorize(long n) {
    std::vector<long> factors;
    for (long i = 2; i * i <= n; ++i) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) {
        factors.push_back(n);
    }
    return factors;"
1,1.0,HumanEval_25_factorize,"
std::vector<long> factorize(long n) {
    std::vector<long> factors;
    for (long i = 2; i * i <= n; ++i) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) {
        factors.push_back(n);
    }
    return factors;"
1,1.0,HumanEval_25_factorize,"
std::vector<long> factorize(long n) {
    std::vector<long> factors;
    // Factor 2
    while (n % 2 == 0) {
        factors.push_back(2);
        n = n / 2;
    }

    // Factor odd numbers upto sqrt(n)
    for (long i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            factors.push_back(i);
            n = n / i;
        }
    }

    // If n is a prime number and n > 2
    if (n > 2)
        factors.push_back(n);

    return factors;
"
1,1.0,HumanEval_25_factorize,"
std::vector<long> factorize(long n) {
    std::vector<long> factors;
    // Divide n by 2 until it can no longer be divided
    while (n % 2 == 0) {
        factors.push_back(2);
        n /= 2;
    }

    // n must be odd at this point, so we can skip one element (Note i = i +2)
    for (long i = 3; i * i <= n; i += 2) {
        // While i divides n, append i and divide n
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }

    // This condition is to handle the case when n is a prime number
    // greater than 2
    if (n > 2)
        factors.push_back(n);
    
    return factors;"
1,1.0,HumanEval_25_factorize,"

std::vector<long> factorize(long n) {
    std::vector<long> factors;
    // Divide n by 2 until it's odd
    while (n % 2 == 0) {
        factors.push_back(2);
        n = n / 2;
    }

    // n is odd at this point, so start from 3
    for (long i = 3; i * i <= n; i = i + 2) {
        // While i divides n, append i and divide n
        while (n % i == 0) {
            factors.push_back(i);
            n = n / i;
        }
    }

    // This condition is to handle the case when n is a prime number
    // greater than 2
    if (n > 2)
        factors.push_back(n);

    return factors;"
1,1.0,HumanEval_25_factorize,"
std::vector<long> factorize(long n) {
    std::vector<long> factors;
    for (long i = 2; i * i <= n; ++i) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) {
        factors.push_back(n);
    }
    return factors;
"
1,1.0,HumanEval_25_factorize,"

std::vector<long> factorize(long n) {
    std::vector<long> factors;
    // Divide n by 2 until n becomes odd
    while (n % 2 == 0) {
        factors.push_back(2);
        n = n / 2;
    }

    // n must be odd at this point so a skip of 2 can be used
    for (long i = 3; i * i <= n; i += 2) {
        // while i divides n, append i and divide n
        while (n % i == 0) {
            factors.push_back(i);
            n = n / i;
        }
    }

    // This condition is to handle the case when n is a prime number greater than 2
    if (n > 2)
        factors.push_back(n);

    return factors;"
1,1.0,HumanEval_96_count_up_to,"
std::vector<long> count_up_to(long n) {
    std::vector<bool> prime(n+1, true);
    prime[0] = prime[1] = false;
    for (long p=2; p*p<=n; p++) {
        if (prime[p] == true) {
            for (long i=p*p; i<=n; i += p)
                prime[i] = false;
        }
    }

    std::vector<long> result;
    for (long i=2; i<n; i++)
        if (prime[i])
            result.push_back(i);

    return result;"
1,1.0,HumanEval_96_count_up_to,"
std::vector<long> count_up_to(long n) {
    std::vector<bool> prime(n+1, true);
    prime[0] = prime[1] = false;
    for (long p = 2; p*p <= n; p++) {
        if (prime[p] == true) {
            for (long i = p*p; i <= n; i += p) {
                prime[i] = false;
            }
        }
    }

    std::vector<long> result;
    for (long i = 2; i < n; i++) {
        if (prime[i]) {
            result.push_back(i);
        }
    }
    return result;"
0,1.0,HumanEval_96_count_up_to,"

std::vector<long> count_up_to(long n) {
    std::vector<long> result;
    for(long i = 2; i < n; i++) {
        if(isPrime(i)) {
            result.push_back(i);
        }
    }
    return result;"
1,1.0,HumanEval_96_count_up_to,"
std::vector<long> count_up_to(long n) {
    std::vector<bool> prime(n+1, true);
    prime[0] = prime[1] = false;
    for (long p=2; p*p<=n; p++) {
        if (prime[p] == true) {
            for (long i=p*p; i<=n; i += p)
                prime[i] = false;
        }
    }
    std::vector<long> result;
    for (long i = 2; i < n; i++)
        if (prime[i])
            result.push_back(i);
    return result;
"
1,1.0,HumanEval_96_count_up_to,"
std::vector<long> count_up_to(long n) {
    std::vector<bool> prime(n+1, true);
    prime[0] = prime[1] = false;
    for (long p=2; p*p<=n; p++) {
        if (prime[p] == true) {
            for (long i=p*p; i<=n; i += p)
                prime[i] = false;
        }
    }
    std::vector<long> primes;
    for (long i = 2; i < n; i++)
        if (prime[i])
            primes.push_back(i);
    return primes;"
1,1.0,HumanEval_96_count_up_to,"
std::vector<long> count_up_to(long n) {
    // Create a vector to store the prime numbers
    std::vector<long> primes;

    // Create a boolean array ""prime[0..n]"" and initialize all entries it as true.
    // A value in prime[i] will finally be false if i is Not a prime, otherwise true.
    std::vector<bool> prime(n+1, true);

    prime[0] = prime[1] = false;
    for (long p=2; p*p<=n; p++) {
        // If prime[p] is not changed, then it is a prime
        if (prime[p] == true) {
            // Update all multiples of p
            for (long i=p*p; i<=n; i += p)
                prime[i] = false;
        }
    }

    // Collect all prime numbers less than n
    for (long i=2; i<n; i++) {
        if (prime[i]) {
            primes.push_back(i);
        }
    }

    return primes;
"
1,0.0,HumanEval_96_count_up_to,"
std::vector<long> count_up_to(long n) {
    std::vector<long> primes;
    if (n < 2) {
        return primes;
    }
    std::vector<bool> prime(n+1, true);
    prime[0] = prime[1] = false;
    for (long p=2; p*p<=n; p++) {
        if (prime[p] == true) {
            for (long i=p*p; i<=n; i += p) {
                prime[i] = false;
            }
        }
    }
    for (long i=2; i<n; i++) {
        if (prime[i]) {
            primes.push_back(i);
        }
    }
    return primes;"
1,1.0,HumanEval_96_count_up_to,"
std::vector<long> count_up_to(long n) {
    std::vector<bool> prime(n+1, true);
    prime[0] = prime[1] = false;
    for (long p=2; p*p<=n; p++) {
        if (prime[p] == true) {
            for (long i=p*p; i<=n; i += p)
                prime[i] = false;
        }
    }

    std::vector<long> result;
    for (long i=2; i<n; i++)
        if (prime[i])
            result.push_back(i);

    return result;
"
0,1.0,HumanEval_96_count_up_to,"
std::vector<long> count_up_to(long n) {
    std::vector<bool> is_prime(n+1, true);
    std::vector<long> primes;

    if (n < 2) {
        return primes;
    }

    is_prime[0] = is_prime[1] = false;
    for (long i = 2; i <= n; ++i) {
        if (is_prime[i]) {
            primes.push_back(i);
            for (long j = i*2; j <= n; j += i) {
                is_prime[j] = false;
            }
        }
    }

    return primes;"
0,1.0,HumanEval_96_count_up_to,"
std::vector<long> count_up_to(long n) {
    std::vector<long> primes;
    if (n < 2) {
        return primes;
    }
    std::vector<bool> sieve(n+1, true);
    for (long i = 2; i <= n; ++i) {
        if (sieve[i]) {
            primes.push_back(i);
            for (long j = i*i; j <= n; j += i) {
                sieve[j] = false;
            }
        }
    }
    return primes;
"
0,0.0,HumanEval_34_unique,"
    // Sort the vector
    std::sort(l.begin(), l.end());

    // Remove duplicates
    l.erase(std::unique(l.begin(), l.end()), l.end());

    return l;
"
1,1.0,HumanEval_34_unique,"

std::vector<long> unique(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    l.erase(std::unique(l.begin(), l.end()), l.end());
    return l;"
1,1.0,HumanEval_34_unique,"
std::vector<long> unique(std::vector<long> l) {
    std::set<long> s(l.begin(), l.end());
    std::vector<long> result(s.begin(), s.end());
    std::sort(result.begin(), result.end());
    return result;
"
0,0.0,HumanEval_34_unique,"
    // sort the vector
    std::sort(l.begin(), l.end());

    // remove duplicates
    l.erase(std::unique(l.begin(), l.end()), l.end());

    return l;
"
1,1.0,HumanEval_34_unique,"
std::vector<long> unique(std::vector<long> l) {
    // Sort the vector
    std::sort(l.begin(), l.end());

    // Use unique function to remove duplicates
    l.erase(std::unique(l.begin(), l.end()), l.end());

    return l;"
0,0.0,HumanEval_34_unique,"
    // Sort the vector
    std::sort(l.begin(), l.end());

    // Remove duplicates
    l.erase(std::unique(l.begin(), l.end()), l.end());

    return l;
"
1,1.0,HumanEval_34_unique,"
std::vector<long> unique(std::vector<long> l) {
    // Sort the vector
    std::sort(l.begin(), l.end());

    // Remove duplicates
    l.erase(std::unique(l.begin(), l.end()), l.end());

    return l;"
0,0.0,HumanEval_34_unique,"
    // Sort the vector
    sort(l.begin(), l.end());

    // Remove duplicates
    l.erase(unique(l.begin(), l.end()), l.end());

    return l;
"
1,1.0,HumanEval_34_unique,"
std::vector<long> unique(std::vector<long> l) {
    std::set<long> s(l.begin(), l.end());
    return std::vector<long>(s.begin(), s.end());"
1,1.0,HumanEval_34_unique,"

std::vector<long> unique(std::vector<long> l) {
    std::set<long> s(l.begin(), l.end());
    std::vector<long> result(s.begin(), s.end());
    return result;"
1,1.0,HumanEval_74_total_match,"

std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
    int sum1 = 0, sum2 = 0;
    for(auto& str : lst1) sum1 += str.size();
    for(auto& str : lst2) sum2 += str.size();
    return sum1 <= sum2 ? lst1 : lst2;"
1,1.0,HumanEval_74_total_match,"
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
    int count1 = 0;
    int count2 = 0;

    for(const auto& str : lst1) {
        count1 += str.size();
    }

    for(const auto& str : lst2) {
        count2 += str.size();
    }

    if(count1 < count2) {
        return lst1;
    } else if(count2 < count1) {
        return lst2;
    } else {
        return lst1;
    }
"
0,1.0,HumanEval_74_total_match,"
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
    int total1 = 0, total2 = 0;
    for(std::string s : lst1) total1 += s.size();
    for(std::string s : lst2) total2 += s.size();
    return total1 < total2 ? lst1 : lst2;
"
0,0.0,HumanEval_74_total_match,"

std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
    int total1 = 0, total2 = 0;
    for(auto& str : lst1) total1 += str.size();
    for(auto& str : lst2) total2 += str.size();
    return total1 < total2 ? lst1 : lst2;
"
1,1.0,HumanEval_74_total_match,"
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
    int count1 = 0, count2 = 0;
    for(auto& s : lst1)
        count1 += s.size();
    for(auto& s : lst2)
        count2 += s.size();

    if(count1 < count2)
        return lst1;
    else if(count1 > count2)
        return lst2;
    else
        return lst1;
"
1,1.0,HumanEval_74_total_match,"
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
    int sum1 = 0;
    int sum2 = 0;
    for(std::string s : lst1) {
        sum1 += s.length();
    }
    for(std::string s : lst2) {
        sum2 += s.length();
    }
    if(sum1 < sum2) {
        return lst1;
    } else if(sum2 < sum1) {
        return lst2;
    } else {
        return lst1;
    }"
1,0.0,HumanEval_74_total_match,"

std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
    int count1 = 0, count2 = 0;
    for(auto &str : lst1) {
        count1 += str.size();
    }
    for(auto &str : lst2) {
        count2 += str.size();
    }
    return count1 <= count2 ? lst1 : lst2;"
1,1.0,HumanEval_74_total_match,"
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
    int count1 = 0, count2 = 0;
    for(auto &str : lst1) {
        count1 += str.size();
    }
    for(auto &str : lst2) {
        count2 += str.size();
    }
    if(count1 < count2) {
        return lst1;
    } else if(count1 > count2) {
        return lst2;
    } else {
        return lst1;
    }
"
1,1.0,HumanEval_74_total_match,"
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
    int total1 = 0;
    int total2 = 0;

    for(auto &s : lst1)
        total1 += s.size();
    for(auto &s : lst2)
        total2 += s.size();

    if(total1 < total2)
        return lst1;
    else if(total1 == total2)
        return lst1;
    else
        return lst2;
"
0,1.0,HumanEval_74_total_match,"
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
    int sum1 = 0, sum2 = 0;
    for(auto &s : lst1) sum1 += s.size();
    for(auto &s : lst2) sum2 += s.size();
    return (sum1 < sum2) ? lst1 : lst2;"
1,1.0,HumanEval_35_max_element,"

long max_element(std::vector<long> l) {
    assert(!l.empty()); // Ensure the vector is not empty
    long max_val = l[0]; // Initialize max_val as the first element
    for(long i=1; i<l.size(); i++) { // Start iterating from the second element
        if(l[i] > max_val) { // If the current element is greater than max_val
            max_val = l[i]; // Update max_val
        }
    }
    return max_val; // Return the maximum element"
1,1.0,HumanEval_35_max_element,"
long max_element(std::vector<long> l) {
    assert(!l.empty()); // ensure the vector is not empty
    long max = l[0]; // initialize max to the first element
    for (size_t i = 1; i < l.size(); i++) {
        if (l[i] > max) {
            max = l[i]; // update max if current element is greater
        }
    }
    return max; // return the maximum element
"
1,1.0,HumanEval_35_max_element,"
long max_element(std::vector<long> l) {
    assert(!l.empty()); // Ensure the vector is not empty
    long max = l[0]; // Initialize max with the first element
    for(long i : l) {
        if(i > max) {
            max = i; // Update max if the current element is greater
        }
    }
    return max; // Return the maximum element"
1,1.0,HumanEval_35_max_element,"

long max_element(std::vector<long> l) {
    assert(!l.empty()); // Ensure the vector is not empty
    long max_val = l[0]; // Initialize max_val with the first element
    for(size_t i = 1; i < l.size(); ++i) {
        if(l[i] > max_val) {
            max_val = l[i]; // Update max_val if current element is greater
        }
    }
    return max_val; // Return the maximum element
"
1,1.0,HumanEval_35_max_element,"
long max_element(std::vector<long> l) {
    assert(!l.empty()); // Ensure the vector is not empty
    long max_val = l[0]; // Initialize max_val as the first element of the vector
    for(long i = 1; i < l.size(); i++) {
        if(l[i] > max_val) {
            max_val = l[i]; // Update max_val if the current element is greater
        }
    }
    return max_val; // Return the maximum element
"
0,0.0,HumanEval_35_max_element,"
    assert(l.size() > 0);
    long max = l[0];
    for (int i = 1; i < l.size(); i++) {
        if (l[i] > max) {
            max = l[i];
        }
    }
    return max;"
1,1.0,HumanEval_35_max_element,"
long max_element(std::vector<long> l) {
    assert(!l.empty()); // Ensure that the vector is not empty
    long max_val = l[0]; // Initialize the maximum value with the first element
    for(long i = 1; i < l.size(); i++) { // Start from the second element
        if(l[i] > max_val) { // If the current element is greater than the maximum value
            max_val = l[i]; // Update the maximum value
        }
    }
    return max_val; // Return the maximum value
"
1,1.0,HumanEval_35_max_element,"
long max_element(std::vector<long> l) {
    assert(!l.empty()); // Ensure the vector is not empty
    long max = l[0]; // Start with the first element as the maximum
    for(long i : l) { // Iterate over the vector
        if(i > max) { // If the current element is greater than the maximum
            max = i; // Update the maximum
        }
    }
    return max; // Return the maximum element
"
1,1.0,HumanEval_35_max_element,"
long max_element(std::vector<long> l) {
    assert(!l.empty());
    long max_val = l[0];
    for(size_t i = 1; i < l.size(); ++i) {
        if(l[i] > max_val) {
            max_val = l[i];
        }
    }
    return max_val;
"
1,1.0,HumanEval_35_max_element,"
long max_element(std::vector<long> l) {
    assert(!l.empty());
    long max_val = l[0];
    for (const auto& num : l) {
        if (num > max_val) {
            max_val = num;
        }
    }
    return max_val;
"
0,0.0,HumanEval_132_is_nested,"
#include<assert.h>
#include<bits/stdc++.h>

bool is_nested(std::string s) {
    std::stack<char> stack;
    for(char c : s) {
        if(c == '[') {
            stack.push(c);
        } else {
            if(stack.empty()) {
                return false;
            }
            if(stack.top() == '[') {
                stack.pop();
            } else {
                return false;
            }
        }
    }
    return !stack.empty();"
0,0.0,HumanEval_132_is_nested,"
#include<assert.h>
#include<bits/stdc++.h>

bool is_nested(std::string str) {
    std::stack<char> stack;
    for(char c : str) {
        if(c == '[') {
            stack.push(c);
        } else if(!stack.empty() && stack.top() == '[') {
            stack.pop();
            return true;
        } else {
            return false;
        }
    }
    return stack.empty();"
0,0.0,HumanEval_132_is_nested,"
#include<assert.h>
#include<bits/stdc++.h>

bool is_nested(std::string str) {
    std::stack<char> s;
    for(int i=0; i<str.length(); i++) {
        if(str[i] == '[') {
            s.push(str[i]);
        } else {
            if(s.empty()) {
                return false;
            }
            if(s.top() == '[') {
                s.pop();
            } else {
                return false;
            }
        }
    }
    return s.empty();
"
0,0.0,HumanEval_132_is_nested,"
    std::stack<char> stack;
    for(char& c : string) {
        if(c == '[') {
            stack.push(c);
        } else {
            if(stack.empty() || stack.top() != '[') {
                return false;
            }
            stack.pop();
        }
    }
    return stack.empty();"
0,0.0,HumanEval_132_is_nested,"
bool is_nested(std::string str) {
    std::stack<char> stack;
    for (char c : str) {
        if (c == '[') {
            stack.push(c);
        } else {
            if (stack.empty() || stack.top() != '[') {
                return false;
            }
            stack.pop();
        }
    }
    return !stack.empty();"
0,0.0,HumanEval_132_is_nested,"
bool is_nested(std::string string) {
    std::stack<char> stack;
    for (char c : string) {
        if (c == '[') {
            stack.push(c);
        } else {
            if (stack.empty()) {
                return false;
            }
            if (stack.top() == '[') {
                stack.pop();
            } else {
                return false;
            }
        }
    }
    return !stack.empty();"
0,0.0,HumanEval_132_is_nested,"
bool is_nested(std::string str) {
    int count = 0;
    for (char c : str) {
        if (c == '[') {
            count++;
        } else if (c == ']') {
            count--;
            if (count < 0) {
                return false;
            }
        }
    }
    return count != 0;
"
0,0.0,HumanEval_132_is_nested,"
bool is_nested(std::string string) {
    std::stack<char> stack;

    for (char c : string) {
        if (c == '[') {
            stack.push(c);
        } else {
            if (stack.empty() || stack.top() != '[') {
                return false;
            }
            stack.pop();
        }
    }

    return !stack.empty();"
0,0.0,HumanEval_132_is_nested,"
bool is_nested(std::string s) {
    std::stack<char> stack;
    for (char c : s) {
        if (c == '[') {
            stack.push(c);
        } else {
            if (stack.empty() || stack.top() != '[') {
                return false;
            }
            stack.pop();
        }
    }
    return !stack.empty();"
0,0.0,HumanEval_132_is_nested,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

bool is_nested(string s) {
    stack<char> stk;
    for(char c : s) {
        if(c == '[') {
            stk.push(c);
        } else {
            if(stk.empty()) {
                return false;
            }
            if(stk.top() == '[') {
                stk.pop();
            } else {
                return false;
            }
        }
    }
    return !stk.empty();"
0,0.0,HumanEval_103_rounded_avg,"
Union_std_string_long rounded_avg(long n, long m) {
    if (n > m) {
        return Union_std_string_long(-1);
    } else {
        long avg = (n + m) / 2;
        avg = round((float)avg);
        std::string binary = std::bitset<64>(avg).to_string();
        binary = binary.substr(binary.find_first_not_of('0'));
        return Union_std_string_long(binary);
    }"
0,0.0,HumanEval_103_rounded_avg,"
Union_std_string_long rounded_avg(long n, long m) {
    if(n > m) {
        return Union_std_string_long(-1);
    }
    long avg = (n + m) / 2;
    std::string binary = std::bitset<64>(avg).to_string();
    // Remove leading zeros
    binary = binary.substr(binary.find_first_not_of('0'));
    return Union_std_string_long(binary);"
0,0.0,HumanEval_103_rounded_avg,"
    if (n > m) {
        return Union_std_string_long(-1);
    } else {
        long avg = (n + m) / 2;
        std::string binary = std::bitset<64>(avg).to_string();
        return Union_std_string_long(binary);
    }"
0,0.0,HumanEval_103_rounded_avg,"

Union_std_string_long rounded_avg(long n, long m) {
    if (n > m) {
        return Union_std_string_long(-1);
    }
    long avg = (n + m) / 2;
    std::string binary = std::bitset<64>(avg).to_string();
    return Union_std_string_long(binary);"
0,0.0,HumanEval_103_rounded_avg,"
Union_std_string_long rounded_avg(long n, long m) {
    if (n > m) {
        return Union_std_string_long(-1);
    }

    long avg = (n + m) / 2;
    long rounded_avg = (n + m) % 2 == 0 ? avg : avg + 1;

    std::string binary = std::bitset<32>(rounded_avg).to_string();
    binary = binary.substr(binary.find_first_not_of('0'));

    return Union_std_string_long(binary);"
0,0.0,HumanEval_103_rounded_avg,"

Union_std_string_long rounded_avg(long n, long m) {
    if (n > m) {
        return Union_std_string_long(-1);
    } else {
        long avg = std::round((n + m) / 2.0);
        std::string binary = """";
        while (avg > 0) {
            binary = std::to_string(avg % 2) + binary;
            avg /= 2;
        }
        return Union_std_string_long(binary);
    }
"
0,0.0,HumanEval_103_rounded_avg,"

Union_std_string_long rounded_avg(long n, long m) {
    if(n > m) {
        return Union_std_string_long(-1);
    }
    long avg = (n + m) / 2;
    avg = round(avg);
    std::string binary = std::bitset<64>(avg).to_string();
    binary = binary.substr(binary.find_first_not_of('0'));
    return Union_std_string_long(binary);"
0,0.0,HumanEval_103_rounded_avg,"

Union_std_string_long rounded_avg(long n, long m) {
    if(n > m) {
        return Union_std_string_long(-1);
    }
    long avg = std::round((n + m) / 2.0);
    std::string binary = std::bitset<64>(avg).to_string();
    // Remove leading zeros
    binary = binary.substr(binary.find_first_not_of('0'));
    return Union_std_string_long(binary);"
0,0.0,HumanEval_103_rounded_avg,"

Union_std_string_long rounded_avg(long n, long m) {
    if(n > m) {
        return Union_std_string_long(-1);
    }
    long avg = (n + m) / 2;
    std::string binary = std::bitset<32>(avg).to_string();
    // remove leading zeros
    binary = binary.substr(binary.find_first_not_of('0'));
    return Union_std_string_long(binary);
"
0,0.0,HumanEval_103_rounded_avg,"
Union_std_string_long rounded_avg(long n, long m) {
    if (n > m) {
        return Union_std_string_long(-1);
    } else {
        long avg = (n + m) / 2;
        std::string binary = std::bitset<64>(avg).to_string();
        // Remove leading zeros
        binary = binary.substr(binary.find_first_not_of('0'));
        return Union_std_string_long(""0b"" + binary);
    }"
0,1.0,HumanEval_113_odd_count,"

std::vector<std::string> odd_count(std::vector<std::string> lst) {
    std::vector<std::string> result;
    for (const auto& str : lst) {
        int count = 0;
        for (char c : str) {
            if ((c - '0') % 2 != 0) {
                count++;
            }
        }
        std::string res = ""the number of odd elements in the string "";
        res += std::to_string(count);
        res += "" of the input."";
        result.push_back(res);
    }
    return result;
"
0,1.0,HumanEval_113_odd_count,"

std::vector<std::string> odd_count(std::vector<std::string> lst) {
    std::vector<std::string> result;
    for (const auto& str : lst) {
        int count = 0;
        for (char c : str) {
            if ((c - '0') % 2 != 0) {
                count++;
            }
        }
        std::string output = ""the number of odd elements in the string "" + std::to_string(count) + "" of the input."";
        result.push_back(output);
    }
    return result;"
0,1.0,HumanEval_113_odd_count,"

std::vector<std::string> odd_count(std::vector<std::string> lst) {
    std::vector<std::string> result;
    for(const auto& str : lst) {
        int count = 0;
        for(char c : str) {
            if((c - '0') % 2 != 0) count++;
        }
        std::string temp = ""the number of odd elements in the string "";
        temp += std::to_string(count);
        temp += "" of the input."";
        result.push_back(temp);
    }
    return result;
"
1,1.0,HumanEval_113_odd_count,"

std::vector<std::string> odd_count(std::vector<std::string> lst) {
    std::vector<std::string> result;
    for(const auto& str : lst) {
        int count = 0;
        for(char c : str) {
            if((c - '0') % 2 != 0) {
                count++;
            }
        }
        std::string temp = ""the number of odd elements "" + std::to_string(count) + ""n the str"" + std::to_string(count) + ""ng "" + std::to_string(count) + "" of the "" + std::to_string(count) + ""nput."";
        result.push_back(temp);
    }
    return result;
"
0,1.0,HumanEval_113_odd_count,"

std::vector<std::string> odd_count(std::vector<std::string> lst) {
    std::vector<std::string> result;
    for(auto& str : lst){
        int count = 0;
        for(char& c : str){
            if((c - '0') % 2 != 0) count++;
        }
        std::string new_str = ""the number of odd elements in the string "" + std::to_string(count) + "" of the input."";
        result.push_back(new_str);
    }
    return result;
"
0,1.0,HumanEval_113_odd_count,"
std::vector<std::string> odd_count(std::vector<std::string> lst) {
    std::vector<std::string> result;
    for (const auto& str : lst) {
        int count = 0;
        for (char c : str) {
            if ((c - '0') % 2 != 0) {
                count++;
            }
        }
        std::string res_str = ""the number of odd elements in the string "" + 
                              std::to_string(count) + "" of the input."";
        result.push_back(res_str);
    }
    return result;
"
1,1.0,HumanEval_113_odd_count,"

std::vector<std::string> odd_count(std::vector<std::string> lst) {
    std::vector<std::string> result;
    for(auto& str : lst) {
        int count = 0;
        for(char& c : str) {
            if((c - '0') % 2 != 0) count++;
        }
        std::string res = ""the number of odd elements "" + std::to_string(count) + ""n the str"" + std::to_string(count) + ""ng "" + std::to_string(count) + "" of the "" + std::to_string(count) + ""nput."";
        result.push_back(res);
    }
    return result;
"
1,1.0,HumanEval_113_odd_count,"

std::vector<std::string> odd_count(std::vector<std::string> lst) {
    std::vector<std::string> result;
    for (const auto& str : lst) {
        int count = 0;
        for (char c : str) {
            if ((c - '0') % 2 != 0) {
                count++;
            }
        }
        std::string output = ""the number of odd elements "" + std::to_string(count) + ""n the str"" + std::to_string(count) + ""ng "" + std::to_string(count) + "" of the "" + std::to_string(count) + ""nput."";
        result.push_back(output);
    }
    return result;
"
0,1.0,HumanEval_113_odd_count,"

std::vector<std::string> odd_count(std::vector<std::string> lst) {
    std::vector<std::string> result;
    for(const auto& str : lst) {
        int count = 0;
        for(char c : str) {
            if((c - '0') % 2 != 0) {
                count++;
            }
        }
        std::string output = ""the number of odd elements in the string "";
        output += std::to_string(count);
        output += "" of the input."";
        result.push_back(output);
    }
    return result;
"
0,1.0,HumanEval_113_odd_count,"
std::vector<std::string> odd_count(std::vector<std::string> lst) {
    std::vector<std::string> result;
    for (auto &str : lst) {
        int count = 0;
        for (char c : str) {
            if ((c - '0') % 2 != 0) {
                count++;
            }
        }
        std::string res_str = ""the number of odd elements in the string "" + std::to_string(count) + "" of the input."";
        result.push_back(res_str);
    }
    return result;
"
1,1.0,HumanEval_109_move_one_ball,"
bool move_one_ball(std::vector<long> arr) {
    int n = arr.size();
    if(n == 0) return true;
    int count = 0;
    for(int i = 0; i < n - 1; i++) {
        if(arr[i] > arr[i+1]) {
            count++;
        }
    }
    if(arr[n-1] > arr[0]) count++;
    return count <= 1;"
1,1.0,HumanEval_109_move_one_ball,"
bool move_one_ball(std::vector<long> arr) {
    int n = arr.size();
    if (n == 0)
        return true;

    int shift_point = -1;
    for (int i = 0; i < n - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            if (shift_point != -1)
                return false;
            shift_point = i;
        }
    }

    if (shift_point == -1)
        return true;

    if (arr[n - 1] <= arr[0])
        return true;

    return false;
"
0,0.0,HumanEval_109_move_one_ball,"
    if (arr.empty())
        return true;

    int n = arr.size();
    int count = 0;

    for (int i = 0; i < n; i++) {
        if (arr[i] > arr[(i + 1) % n])
            count++;
    }

    return count <= 1;
"
1,0.0,HumanEval_109_move_one_ball,"
bool move_one_ball(std::vector<long> arr) {
    if(arr.size() == 0)
        return true;
        
    int count = 0;
    for(int i = 0; i < arr.size()-1; i++) {
        if(arr[i] > arr[i+1])
            count++;
    }
    if(arr[arr.size()-1] > arr[0])
        count++;

    return count <= 1;"
1,0.0,HumanEval_109_move_one_ball,"
bool move_one_ball(std::vector<long> arr) {
    if(arr.empty())
        return true;

    int n = arr.size();
    int count = 0;

    for(int i = 0; i < n; i++) {
        if(arr[i] > arr[(i+1)%n])
            count++;
    }

    return count <= 1;"
1,1.0,HumanEval_109_move_one_ball,"
bool move_one_ball(std::vector<long> arr) {
    int n = arr.size();
    if (n == 0) return true;

    int count = 0;
    for (int i = 0; i < n - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            count++;
        }
    }
    if (arr[n - 1] > arr[0]) {
        count++;
    }

    return count <= 1;
"
1,1.0,HumanEval_109_move_one_ball,"

bool move_one_ball(std::vector<long> arr) {
    int n = arr.size();
    if (n == 0) return true;

    int i = 0;
    while (i < n && arr[i] <= arr[i+1]) i++;

    if (i == n-1) return true;

    int j = i+1;
    while (j < n && arr[j] <= arr[(j+1)%n]) j++;

    if (j == n) return true;

    return false;"
1,1.0,HumanEval_109_move_one_ball,"
bool move_one_ball(std::vector<long> arr) {
    int n = arr.size();
    if(n == 0) return true;
    int count = 0;
    for(int i = 0; i < n - 1; i++) {
        if(arr[i] > arr[i+1]) count++;
    }
    if(arr[n-1] > arr[0]) count++;
    return count <= 1;
"
1,1.0,HumanEval_109_move_one_ball,"
bool move_one_ball(std::vector<long> arr) {
    int n = arr.size();
    if (n == 0) return true;
    int count = 0;
    for (int i = 0; i < n - 1; i++) {
        if (arr[i] > arr[i + 1]) count++;
    }
    if (arr[n - 1] > arr[0]) count++;
    return count <= 1;"
1,1.0,HumanEval_109_move_one_ball,"
bool move_one_ball(std::vector<long> arr) {
    int n = arr.size();
    if(n == 0)
        return true;
    int count = 0;
    for(int i = 0; i < n - 1; i++) {
        if(arr[i] > arr[i + 1]) {
            count++;
        }
    }
    if(arr[n - 1] > arr[0]) {
        count++;
    }
    return count <= 1;
"
0,1.0,HumanEval_107_even_odd_palindrome,"

std::tuple<long, long> even_odd_palindrome(long n) {
    assert(1 <= n && n <= std::pow(10, 3));

    long even = 0;
    long odd = 0;

    for (long i = 1; i <= n; i++) {
        if (isPalindrome(i)) {
            if (i % 2 == 0) {
                even++;
            } else {
                odd++;
            }
        }
    }

    return std::make_tuple(even, odd);"
1,1.0,HumanEval_107_even_odd_palindrome,"
std::tuple<long, long> even_odd_palindrome(long n) {
    assert(1 <= n && n <= std::pow(10, 3));

    long even_count = 0;
    long odd_count = 0;

    for (long i = 1; i <= n; i++) {
        if (i % 10 == 0) continue;  // Skip numbers ending with 0
        std::string s = std::to_string(i);
        std::string r = s;
        std::reverse(r.begin(), r.end());
        if (s == r) {
            if (i % 2 == 0) {
                even_count++;
            } else {
                odd_count++;
            }
        }
    }

    return std::make_tuple(even_count, odd_count);"
0,0.0,HumanEval_107_even_odd_palindrome,"
    long evenCount = 0;
    long oddCount = 0;

    for (long i = 1; i <= n; i++) {
        if (i < 10) {
            if (i % 2 == 0) evenCount++;
            else oddCount++;
        } else if (i < 100) {
            if (i / 10 == i % 10) {
                if (i % 2 == 0) evenCount++;
                else oddCount++;
            }
        } else {
            if (i / 100 == i % 10) {
                if ((i / 10) % 10 == (i % 100) / 10) {
                    if (i % 2 == 0) evenCount++;
                    else oddCount++;
                }
            }
        }
    }

    return std::make_tuple(evenCount, oddCount);
"
0,1.0,HumanEval_107_even_odd_palindrome,"

std::tuple<long, long> even_odd_palindrome(long n) {
    return countPalindromes(n);"
0,0.0,HumanEval_107_even_odd_palindrome,"
    long even_count = 0;
    long odd_count = 0;
    for (long i = 1; i <= n; i++) {
        if (i < 10) {
            even_count++;
        } else if (i < 100) {
            if (i / 10 == i % 10) {
                even_count++;
            }
            odd_count++;
        } else {
            if (i / 100 == i % 10) {
                if ((i / 10) % 10 == (i / 100)) {
                    even_count++;
                } else {
                    odd_count++;
                }
            } else if ((i / 10) % 10 == (i % 10)) {
                odd_count++;
            }
        }
    }
    return std::make_tuple(even_count, odd_count);
"
1,0.0,HumanEval_107_even_odd_palindrome,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

bool isPalindrome(long num) {
    long rev = 0;
    long temp = num;
    while (temp != 0) {
        rev = rev * 10 + temp % 10;
        temp = temp / 10;
    }
    return (num == rev);
}

tuple<long, long> even_odd_palindrome(long n) {
    assert(1 <= n && n <= pow(10, 3));
    long evenCount = 0, oddCount = 0;
    for (long i = 1; i <= n; i++) {
        if (isPalindrome(i)) {
            if (i % 2 == 0)
                evenCount++;
            else
                oddCount++;
        }
    }
    return make_tuple(evenCount, oddCount);
"
0,1.0,HumanEval_107_even_odd_palindrome,"
std::tuple<long, long> even_odd_palindrome(long n) {
    assert(1 <= n && n <= std::pow(10, 3));
    
    long even_count = 0, odd_count = 0;
    for (long i = 1; i <= n; i++) {
        std::string s = std::to_string(i);
        if (s == std::string(s.rbegin(), s.rend())) {
            if (s.length() % 2 == 0) {
                even_count++;
            } else {
                odd_count++;
            }
        }
    }
    return std::make_tuple(even_count, odd_count);"
0,0.0,HumanEval_107_even_odd_palindrome,"
    long even_count = 0, odd_count = 0;
    for (long i = 1; i <= n; i++) {
        std::string str = std::to_string(i);
        if (str == std::string(str.rbegin(), str.rend())) {
            if (str.length() % 2 == 0) {
                even_count++;
            } else {
                odd_count++;
            }
        }
    }
    return std::make_tuple(even_count, odd_count);"
0,1.0,HumanEval_107_even_odd_palindrome,"

std::tuple<long, long> even_odd_palindrome(long n) {
    long even_count = 0, odd_count = 0;
    for (long i = 1; i <= n; i++) {
        std::string str = std::to_string(i);
        std::string str_rev = std::string(str.rbegin(), str.rend());
        if (str == str_rev) {
            if (str.length() % 2 == 0) {
                even_count++;
            } else {
                odd_count++;
            }
        }
    }
    return std::make_tuple(even_count, odd_count);
"
1,1.0,HumanEval_107_even_odd_palindrome,"
std::tuple<long, long> even_odd_palindrome(long n) {
    long even_count = 0, odd_count = 0;
    for (long i = 1; i <= n; i++) {
        if (i < 10) {
            if (i % 2 == 0) even_count++;
            else odd_count++;
        } else {
            std::string str = std::to_string(i);
            std::string str_reverse = std::string(str.rbegin(), str.rend());
            if (str == str_reverse) {
                if (i % 2 == 0) even_count++;
                else odd_count++;
            }
        }
    }
    return std::make_tuple(even_count, odd_count);"
0,1.0,HumanEval_138_is_equal_to_sum_even,"
bool is_equal_to_sum_even(long n) {
    // If the number is less than 8, it cannot be written as the sum of 4 positive even numbers
    if (n < 8) {
        return false;
    }
    // If the number is even, it can be written as the sum of 4 positive even numbers
    if (n % 2 == 0) {
        return true;
    }
    // If the number is odd, it can be written as the sum of 4 positive even numbers if it is greater than 10
    if (n > 10) {
        return true;
    }
    // If none of the above conditions are met, it cannot be written as the sum of 4 positive even numbers
    return false;"
0,1.0,HumanEval_138_is_equal_to_sum_even,"
bool is_equal_to_sum_even(long n) {
    if (n < 4) {
        return false;
    }
    if (n % 2 != 0) {
        return false;
    }
    n -= 4; // Subtract 4 from n to ensure that the remaining number can be evenly divided by 2
    return n % 2 == 0;"
0,0.0,HumanEval_138_is_equal_to_sum_even,"
    // If the number is less than 10, it cannot be written as the sum of exactly 4 positive even numbers
    if (n < 10) {
        return false;
    }

    // If the number is even, it can be written as the sum of 4 even numbers
    if (n % 2 == 0) {
        return true;
    }

    // If the number is odd, it can be written as the sum of 4 even numbers if and only if it is one more than a multiple of 4.
    // This is because we can subtract 2 from the number to get an even number, and then add 2 to the result to get another even number.
    // We can repeat this process 3 more times to get 4 even numbers.
    return (n - 2) % 4 == 0;"
0,0.0,HumanEval_138_is_equal_to_sum_even,"

bool is_equal_to_sum_even(long n) {
    // The function is_equal_to_sum_even checks if a given number n can be written as the sum of exactly 4 positive even numbers.
    // This function is incomplete and will not work for most practical purposes.

    // If n is even, then it can be written as the sum of 4 positive even numbers.
    if (n % 2 == 0) {
        return true;
    }

    // If n is odd, then it can be written as the sum of 4 positive even numbers if and only if n is of the form 4m+1 or 4m-1 for some integer m.
    // However, this is not a known algorithmic solution and it's not practical for large inputs.
    return false;"
0,1.0,HumanEval_138_is_equal_to_sum_even,"
bool is_equal_to_sum_even(long n) {
    if(n < 10) {
        return false;
    }
    std::vector<long> evenNumbers;
    for(long i = 2; i <= n; i += 2) {
        evenNumbers.push_back(i);
    }
    for(long i = 0; i < evenNumbers.size(); i++) {
        for(long j = i + 1; j < evenNumbers.size(); j++) {
            for(long k = j + 1; k < evenNumbers.size(); k++) {
                for(long l = k + 1; l < evenNumbers.size(); l++) {
                    if(evenNumbers[i] + evenNumbers[j] + evenNumbers[k] + evenNumbers[l] == n) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
"
0,0.0,HumanEval_138_is_equal_to_sum_even,"
    if (n < 10) {
        return false;
    }
    if (n % 2 != 0) {
        return false;
    }
    if (n % 4 == 0) {
        return true;
    }
    return false;"
1,1.0,HumanEval_138_is_equal_to_sum_even,"
bool is_equal_to_sum_even(long n) {
    // Check if the given number is even
    if (n % 2 != 0) {
        return false;
    }

    // Check if the given number can be written as the sum of exactly 4 positive even numbers
    for (long i = 2; i <= n / 4; i += 2) {
        if ((n - i) % 2 == 0) {
            return true;
        }
    }

    return false;"
0,1.0,HumanEval_138_is_equal_to_sum_even,"
bool is_equal_to_sum_even(long n) {
    if (n < 4) {
        return false;
    }
    if (n % 2 != 0) {
        return false;
    }
    if ((n / 2) % 2 == 0) {
        return true;
    }
    return false;"
0,1.0,HumanEval_138_is_equal_to_sum_even,"
bool is_equal_to_sum_even(long n) {
    if(n % 4 == 0) {
        return true;
    } else {
        return false;
    }
"
0,1.0,HumanEval_138_is_equal_to_sum_even,"

bool is_equal_to_sum_even(long n) {
    if (n < 10) {
        return false;
    }
    if (n % 2 != 0) {
        return false;
    }
    if (n % 4 == 0) {
        return true;
    }
    if (n % 6 == 0) {
        return true;
    }
    if (n % 8 == 0) {
        return true;
    }
    return false;"
1,1.0,HumanEval_62_derivative,"

std::vector<long> derivative(std::vector<long> xs) {
    std::vector<long> derivative;
    for (size_t i = 1; i < xs.size(); i++) {
        derivative.push_back(xs[i] * i);
    }
    return derivative;"
0,0.0,HumanEval_62_derivative,"
    // Implement the function to calculate the derivative of the polynomial
    for (size_t i = 1; i < xs.size(); i++) {
        xs[i] = xs[i] * (long)i;
    }
    xs.erase(xs.begin());
    return xs;"
1,1.0,HumanEval_62_derivative,"

std::vector<long> derivative(std::vector<long> xs) {
    // If the input vector is empty or contains only one element, return an empty vector
    if(xs.size() <= 1) return std::vector<long>();

    // Create a new vector to store the derivative coefficients
    std::vector<long> derivative;

    // Loop through the input vector, starting from the second element
    for(size_t i = 1; i < xs.size(); ++i) {
        // Multiply the coefficient by its power and add it to the derivative vector
        derivative.push_back(xs[i] * i);
    }

    return derivative;"
1,1.0,HumanEval_62_derivative,"
std::vector<long> derivative(std::vector<long> xs) {
    for (size_t i = 1; i < xs.size(); i++) {
        xs[i] *= i;
    }
    xs.erase(xs.begin());
    return xs;"
1,1.0,HumanEval_62_derivative,"
std::vector<long> derivative(std::vector<long> xs) {
    // Create a new vector to store the derivative coefficients
    std::vector<long> derivative_coefficients;

    // Loop through the coefficients
    for (int i = 1; i < xs.size(); i++) {
        // The derivative of x^n is n*x^(n-1)
        // So we multiply the coefficient by n (which is i)
        derivative_coefficients.push_back(xs[i] * i);
    }

    return derivative_coefficients;"
1,1.0,HumanEval_62_derivative,"
std::vector<long> derivative(std::vector<long> xs) {
    // Create a new vector to store the coefficients of the derivative
    std::vector<long> derivative_coefficients;

    // Loop through the coefficients of the polynomial
    for (int i = 1; i < xs.size(); i++) {
        // Multiply the coefficient by its power and add it to the new vector
        derivative_coefficients.push_back(xs[i] * i);
    }

    // Return the new vector of coefficients
    return derivative_coefficients;
"
0,0.0,HumanEval_62_derivative,"
    // The derivative of a constant is 0.
    if(xs.size() == 1) {
        return {0};
    }

    std::vector<long> derivative_coefficients;

    // The derivative of x^n is n*x^(n-1).
    // So we start from the second coefficient and multiply each coefficient by its index.
    for(size_t i = 1; i < xs.size(); ++i) {
        derivative_coefficients.push_back(xs[i] * i);
    }

    return derivative_coefficients;"
0,0.0,HumanEval_62_derivative,"
    // Initialize an empty vector to store the derivative coefficients.
    std::vector<long> derivative;

    // Loop over the input vector from the second element (index 1) to the end.
    // The derivative of a constant is 0, so we start from the second term.
    for (size_t i = 1; i < xs.size(); ++i) {
        // The derivative of a term x^n is n * x^(n-1).
        // So we multiply the coefficient by the power (n-1), and push it to the derivative vector.
        derivative.push_back(xs[i] * i);
    }

    return derivative;
"
1,1.0,HumanEval_62_derivative,"
std::vector<long> derivative(std::vector<long> xs) {
    for (size_t i = 1; i < xs.size(); i++) {
        xs[i] = xs[i] * (long)i;
    }
    xs.erase(xs.begin());
    return xs;"
1,1.0,HumanEval_62_derivative,"
std::vector<long> derivative(std::vector<long> xs) {
    // If the input vector is empty, return an empty vector
    if(xs.empty()) return xs;

    // Create a new vector to store the derivative
    std::vector<long> derivative;

    // Loop through the input vector from the second element
    for(size_t i = 1; i < xs.size(); ++i) {
        // Multiply the coefficient by its power and add it to the derivative vector
        derivative.push_back(xs[i] * i);
    }

    return derivative;"
0,0.0,HumanEval_126_is_sorted,"
bool is_sorted(std::vector<long> lst) {
    for(unsigned int i = 1; i < lst.size(); i++) {
        if (lst[i] < lst[i-1]) {
            return false;
        }
    }
    return true;
"
0,0.0,HumanEval_126_is_sorted,"
bool is_sorted(std::vector<long> lst) {
    for(size_t i = 1; i < lst.size(); i++) {
        if(lst[i - 1] >= lst[i]) {
            return false;
        }
    }
    return true;
"
0,0.0,HumanEval_126_is_sorted,"
    // Check if the vector is empty or contains only one element
    if (lst.size() <= 1) {
        return true;
    }

    // Iterate over the vector and check if each element is greater than or equal to the next one
    for (size_t i = 0; i < lst.size() - 1; ++i) {
        if (lst[i] >= lst[i + 1]) {
            return false;
        }
    }

    // If no elements were found that were not in ascending order, return true
    return true;"
0,0.0,HumanEval_126_is_sorted,"
bool is_sorted(std::vector<long> lst) {
    for (size_t i = 1; i < lst.size(); i++) {
        if (lst[i-1] > lst[i]) {
            return false;
        }
    }
    return true;
"
0,0.0,HumanEval_126_is_sorted,"
bool is_sorted(std::vector<long> lst) {
    for (size_t i = 1; i < lst.size(); i++) {
        if (lst[i] < lst[i - 1]) {
            return false;
        }
    }
    return true;"
0,1.0,HumanEval_126_is_sorted,"
bool is_sorted(std::vector<long> lst) {
    if (lst.size() == 1 || lst.size() == 0) {
        return true;
    }
    for (size_t i = 0; i < lst.size() - 1; i++) {
        if (lst[i] >= lst[i + 1]) {
            return false;
        }
    }
    return true;"
0,0.0,HumanEval_126_is_sorted,"
bool is_sorted(std::vector<long> lst) {
    for(int i = 0; i < lst.size()-1; i++) {
        if(lst[i] > lst[i+1]) {
            return false;
        }
    }
    return true;
"
0,1.0,HumanEval_126_is_sorted,"
bool is_sorted(std::vector<long> lst) {
    for (unsigned int i = 0; i < lst.size() - 1; i++) {
        if (lst[i] >= lst[i + 1]) {
            return false;
        }
    }
    return true;
"
0,0.0,HumanEval_126_is_sorted,"
bool is_sorted(std::vector<long> lst) {
    for (size_t i = 1; i < lst.size(); i++) {
        if (lst[i] < lst[i-1]) {
            return false;
        }
    }
    return true;"
0,0.0,HumanEval_126_is_sorted,"
    if (lst.size() <= 1) {
        return true;
    }
    for (size_t i = 1; i < lst.size(); ++i) {
        if (lst[i] < lst[i - 1]) {
            return false;
        }
    }
    return true;
"
0,0.0,HumanEval_161_solve,"
    std::string result = """";
    for(char& c : s) {
        if(isalpha(c)) {
            if(islower(c)) {
                result += toupper(c);
            } else {
                result += tolower(c);
            }
        } else {
            result = s + result;
            break;
        }
    }
    if(result == """") {
        std::reverse(s.begin(), s.end());
        return s;
    }
    return result;"
1,0.0,HumanEval_161_solve,"
std::string solve(std::string s) {
    bool hasLetter = false;
    for (char & c: s) {
        if (isalpha(c)) {
            hasLetter = true;
            if (islower(c)) {
                c = toupper(c);
            } else {
                c = tolower(c);
            }
        }
    }
    if (!hasLetter) {
        std::reverse(s.begin(), s.end());
    }
    return s;
"
1,1.0,HumanEval_161_solve,"

std::string solve(std::string s) {
    bool hasLetters = false;
    for(char c : s) {
        if(std::isalpha(c)) {
            hasLetters = true;
            break;
        }
    }

    if(!hasLetters) {
        std::reverse(s.begin(), s.end());
        return s;
    }

    for(int i = 0; i < s.size(); i++) {
        if(std::isalpha(s[i])) {
            if(std::islower(s[i])) {
                s[i] = std::toupper(s[i]);
            } else {
                s[i] = std::tolower(s[i]);
            }
        }
    }

    return s;
"
1,0.0,HumanEval_161_solve,"

std::string solve(std::string s) {
    bool hasLetter = false;
    for(char& c : s) {
        if(isalpha(c)) {
            hasLetter = true;
            if(islower(c)) {
                c = toupper(c);
            } else {
                c = tolower(c);
            }
        }
    }
    if(!hasLetter) {
        std::reverse(s.begin(), s.end());
    }
    return s;"
0,0.0,HumanEval_161_solve,"
    std::string result = """";
    for(char& c : s) {
        if(isalpha(c)) {
            if(islower(c)) {
                result += toupper(c);
            } else {
                result += tolower(c);
            }
        } else {
            result = s + result;
            break;
        }
    }
    if(result == """") {
        std::reverse(s.begin(), s.end());
        return s;
    }
    return result;"
1,0.0,HumanEval_161_solve,"
std::string solve(std::string s) {
    bool hasLetter = false;
    for (char & c : s) {
        if (std::isalpha(c)) {
            hasLetter = true;
            if (std::islower(c)) {
                c = std::toupper(c);
            } else {
                c = std::tolower(c);
            }
        }
    }
    if (!hasLetter) {
        std::reverse(s.begin(), s.end());
    }
    return s;"
1,1.0,HumanEval_161_solve,"
std::string solve(std::string s) {
    bool hasLetter = false;
    for (char& c : s) {
        if (isalpha(c)) {
            hasLetter = true;
            if (islower(c)) {
                c = toupper(c);
            } else {
                c = tolower(c);
            }
        }
    }
    if (!hasLetter) {
        reverse(s.begin(), s.end());
    }
    return s;
"
0,0.0,HumanEval_161_solve,"
    std::string result;
    for (char c : s) {
        if (isalpha(c)) {
            if (islower(c)) {
                result += toupper(c);
            } else {
                result += tolower(c);
            }
        } else {
            result = s + result;
            break;
        }
    }
    return result;"
0,0.0,HumanEval_161_solve,"
    if (s.find_first_of(""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"") == std::string::npos) {
        std::reverse(s.begin(), s.end());
        return s;
    }

    for (int i = 0; i < s.length(); i++) {
        if (islower(s[i])) {
            s[i] = toupper(s[i]);
        } else if (isupper(s[i])) {
            s[i] = tolower(s[i]);
        }
    }

    return s;
"
1,1.0,HumanEval_161_solve,"
std::string solve(std::string s) {
    bool isLetter = false;
    for(int i=0; i<s.length(); i++) {
        if(isalpha(s[i])) {
            isLetter = true;
            if(islower(s[i]))
                s[i] = toupper(s[i]);
            else
                s[i] = tolower(s[i]);
        }
    }
    if(!isLetter)
        std::reverse(s.begin(), s.end());
    return s;"
0,1.0,HumanEval_130_tri,"
std::vector<long> tri(long n) {
    std::vector<long> result(n + 1);
    result[0] = 3;
    if (n > 0)
        result[1] = 3;
    if (n > 1)
        result[2] = 2;
    for (long i = 3; i <= n; i++) {
        if (i % 2 == 0)
            result[i] = 1 + i / 2;
        else
            result[i] = result[i - 1] + result[i - 2] + result[i - 3];
    }
    return result;
"
0,0.0,HumanEval_130_tri,"
std::vector<long> tri(long n) {
    std::vector<long> result(n + 1);
    result[0] = 3;
    if (n > 0) {
        result[1] = 3;
    }
    if (n > 1) {
        result[2] = 2;
    }
    for (long i = 3; i <= n; ++i) {
        if (i % 2 == 0) {
            result[i] = 1 + i / 2;
        } else {
            result[i] = result[i - 1] + result[i - 2] + result[i + 1];
        }
    }
    return result;"
0,0.0,HumanEval_130_tri,"
std::vector<long> tri(long n) {
    std::vector<long> result(n + 1);
    result[0] = 3;
    if (n > 0) {
        result[1] = 3;
    }
    if (n > 1) {
        result[2] = 2;
    }
    for (long i = 3; i <= n; i++) {
        if (i % 2 == 0) {
            result[i] = 1 + i / 2;
        } else {
            result[i] = result[i - 1] + result[i - 2] + result[i - 3];
        }
    }
    return result;"
0,1.0,HumanEval_130_tri,"
std::vector<long> tri(long n) {
    std::vector<long> result(n + 1);
    result[0] = 3;
    if (n > 0) {
        result[1] = 3;
    }
    if (n > 1) {
        result[2] = 2;
    }
    for (long i = 3; i <= n; i++) {
        if (i % 2 == 0) {
            result[i] = 1 + i / 2;
        } else {
            result[i] = result[i - 1] + result[i - 2] + result[i - 3];
        }
    }
    return result;"
0,0.0,HumanEval_130_tri,"
    std::vector<long> result(n + 1);
    result[0] = 3;
    if (n > 0) {
        result[1] = 3;
    }
    if (n > 1) {
        result[2] = 2;
        for (long i = 3; i <= n; i++) {
            if (i % 2 == 0) {
                result[i] = 1 + i / 2;
            } else {
                result[i] = result[i - 1] + result[i - 2] + result[i + 1];
            }
        }
    }
    return result;"
0,0.0,HumanEval_130_tri,"
    std::vector<long> result(n + 1);
    result[0] = 0;
    if(n > 0){
        result[1] = 1;
    }
    if(n > 1){
        result[2] = 1;
    }
    for(long i = 3; i <= n; i++){
        if(i % 2 == 0){
            result[i] = 1 + i / 2;
        }
        else{
            result[i] = result[i - 1] + result[i - 2] + result[i - 3];
        }
    }
    return result;"
0,0.0,HumanEval_130_tri,"
std::vector<long> tri(long n) {
    std::vector<long> result(n + 1);
    if(n >= 0)
        result[0] = 3;
    if(n >= 1)
        result[1] = 3;
    if(n >= 2)
        result[2] = 2;
    for(long i = 3; i <= n; i++) {
        if(i % 2 == 0)
            result[i] = 1 + i / 2;
        else
            result[i] = result[i - 1] + result[i - 2] + result[i + 1];
    }
    return result;
"
0,1.0,HumanEval_130_tri,"
std::vector<long> tri(long n) {
    std::vector<long> result(n + 1);
    if (n >= 0) result[0] = 3;
    if (n >= 1) result[1] = 3;
    if (n >= 2) result[2] = 2;
    for (long i = 3; i <= n; i++) {
        if (i % 2 == 0) {
            result[i] = 1 + i / 2;
        } else {
            result[i] = result[i - 1] + result[i - 2] + result[i - 3];
        }
    }
    return result;
"
0,1.0,HumanEval_130_tri,"
std::vector<long> tri(long n) {
    std::vector<long> result(n + 1);
    if (n >= 0) {
        result[0] = 3;
    }
    if (n >= 1) {
        result[1] = 3;
    }
    if (n >= 2) {
        result[2] = 2;
    }
    for (long i = 3; i <= n; i++) {
        if (i % 2 == 0) {
            result[i] = 1 + i / 2;
        } else {
            result[i] = result[i - 1] + result[i - 2] + result[i - 3];
        }
    }
    return result;"
0,0.0,HumanEval_130_tri,"
    std::vector<long> result(n + 1);
    result[0] = 3;
    if (n > 0) {
        result[1] = 3;
    }
    if (n > 1) {
        result[2] = 2;
    }
    for (long i = 3; i <= n; i++) {
        if (i % 2 == 0) {
            result[i] = 1 + i / 2;
        } else {
            result[i] = result[i - 1] + result[i - 2] + result[i - 3];
        }
    }
    return result;
"
0,1.0,HumanEval_36_fizz_buzz,"
long fizz_buzz(long n) {
    long count = 0;
    for (long i = 11; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            stringstream ss;
            ss << i;
            string str = ss.str();
            count += count(str.begin(), str.end(), '7');
        }
    }
    return count;"
0,0.0,HumanEval_36_fizz_buzz,"
long fizz_buzz(long n) {
    long count = 0;
    for (long i = 11; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            string s = to_string(i);
            count += count(s.begin(), s.end(), '7');
        }
    }
    return count;
"
0,1.0,HumanEval_36_fizz_buzz,"
long fizz_buzz(long n) {
    long count = 0;
    for (long i = 11; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            string s = to_string(i);
            count += count(s.begin(), s.end(), '7');
        }
    }
    return count;"
0,1.0,HumanEval_36_fizz_buzz,"
long fizz_buzz(long n) {
    long count = 0;
    for(long i = 11; i < n; i++) {
        if(i % 11 == 0 || i % 13 == 0) {
            string s = to_string(i);
            count += count_if(s.begin(), s.end(), [](char c){ return c == '7'; });
        }
    }
    return count;"
0,0.0,HumanEval_36_fizz_buzz,"
long fizz_buzz(long n) {
    long count = 0;
    for (long i = 11; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            string num_str = to_string(i);
            count += count(num_str.begin(), num_str.end(), '7');
        }
    }
    return count;
"
1,1.0,HumanEval_36_fizz_buzz,"
long fizz_buzz(long n) {
    long count = 0;
    for (long i = 11; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            std::string s = std::to_string(i);
            count += std::count(s.begin(), s.end(), '7');
        }
    }
    return count;"
0,0.0,HumanEval_36_fizz_buzz,"
long fizz_buzz(long n) {
    long count = 0;
    for (long i = 11; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            stringstream ss;
            ss << i;
            string str = ss.str();
            count += count(str.begin(), str.end(), '7');
        }
    }
    return count;"
0,1.0,HumanEval_36_fizz_buzz,"
long fizz_buzz(long n) {
    long count = 0;
    for (long i = 11; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            string str = to_string(i);
            count += count(str.begin(), str.end(), '7');
        }
    }
    return count;"
0,1.0,HumanEval_36_fizz_buzz,"
long fizz_buzz(long n) {
    long count = 0;
    for (long i = 11; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            count += std::to_string(i).find('7') != std::string::npos;
        }
    }
    return count;"
0,1.0,HumanEval_36_fizz_buzz,"
long fizz_buzz(long n) {
    long count = 0;
    for (long i = 11; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            count += count_if(to_string(i).begin(), to_string(i).end(), [](char c){ return c == '7'; });
        }
    }
    return count;"
1,1.0,HumanEval_29_filter_by_prefix,"
std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;

    for (const auto& str : strings) {
        if (str.substr(0, prefix.size()) == prefix) {
            result.push_back(str);
        }
    }

    return result;"
1,1.0,HumanEval_29_filter_by_prefix,"

std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.rfind(prefix, 0) == 0) {
            result.push_back(str);
        }
    }
    return result;
"
1,1.0,HumanEval_29_filter_by_prefix,"

std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.substr(0, prefix.size()) == prefix) {
            result.push_back(str);
        }
    }
    return result;
"
1,1.0,HumanEval_29_filter_by_prefix,"

std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> filtered_strings;
    for (std::string s : strings) {
        if (s.substr(0, prefix.size()) == prefix) {
            filtered_strings.push_back(s);
        }
    }
    return filtered_strings;"
1,1.0,HumanEval_29_filter_by_prefix,"

std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;
    for(const auto& str : strings) {
        if(str.substr(0, prefix.size()) == prefix) {
            result.push_back(str);
        }
    }
    return result;"
1,1.0,HumanEval_29_filter_by_prefix,"
std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.substr(0, prefix.size()) == prefix) {
            result.push_back(str);
        }
    }
    return result;
"
1,1.0,HumanEval_29_filter_by_prefix,"
std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.substr(0, prefix.size()) == prefix) {
            result.push_back(str);
        }
    }
    return result;
"
1,1.0,HumanEval_29_filter_by_prefix,"

std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.find(prefix) == 0) {
            result.push_back(str);
        }
    }
    return result;
"
1,1.0,HumanEval_29_filter_by_prefix,"
std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;
    for(const auto& str : strings) {
        if(str.substr(0, prefix.size()) == prefix) {
            result.push_back(str);
        }
    }
    return result;
"
1,0.0,HumanEval_29_filter_by_prefix,"
std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.substr(0, prefix.size()) == prefix) {
            result.push_back(str);
        }
    }
    return result;"
0,1.0,HumanEval_84_solve,"

std::string solve(long N) {
    assert(0 <= N && N <= 10000);
    std::string binary = """";
    while (N > 0) {
        binary = std::to_string(N % 2) + binary;
        N /= 2;
    }
    return binary;
"
0,0.0,HumanEval_84_solve,"

std::string solve(long N) {
    // Convert the number to binary
    std::string binary = std::bitset<32>(N).to_string();

    // Remove leading zeros
    const auto pos = binary.find('1');
    if (pos != std::string::npos) {
        binary = binary.substr(pos);
    }

    // Return the binary string
    return binary;"
0,0.0,HumanEval_84_solve,"

std::string solve(long N) {
    std::string binary = """";
    while (N > 0) {
        binary = std::to_string(N % 2) + binary;
        N /= 2;
    }
    return binary;
"
0,0.0,HumanEval_84_solve,"

std::string solve(long N) {
    std::string binary = """";
    while (N > 0) {
        binary = std::to_string(N % 2) + binary;
        N /= 2;
    }
    return binary;
"
0,0.0,HumanEval_84_solve,"

std::string solve(long N) {
    std::string binary = """";
    while (N > 0) {
        binary = std::to_string(N % 2) + binary;
        N /= 2;
    }
    return binary;"
0,0.0,HumanEval_84_solve,"

std::string solve(long N) {
    std::string binary = """";
    while (N > 0) {
        binary = std::to_string(N % 2) + binary;
        N /= 2;
    }
    return binary;
"
0,0.0,HumanEval_84_solve,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

string solve(long N) {
    // Convert the number to binary and then to string
    string binary = bitset<32>(N).to_string();

    // Remove leading zeros
    const auto pos = binary.find('1');
    if (pos != string::npos)
        binary = binary.substr(pos);
    else
        binary = ""0"";

    return binary;"
0,0.0,HumanEval_84_solve,"

std::string solve(long N) {
    std::string binary = """";
    while (N > 0) {
        binary = std::to_string(N % 2) + binary;
        N /= 2;
    }
    return binary;
"
0,0.0,HumanEval_84_solve,"

std::string solve(long N) {
    // Convert the number to binary
    std::string binary = std::bitset<32>(N).to_string();
    
    // Remove leading zeros
    const auto pos = binary.find('1');
    if (pos != std::string::npos) {
        binary = binary.substr(pos);
    }

    return binary;"
0,0.0,HumanEval_84_solve,"

std::string solve(long N) {
    std::string binary = """";
    while (N > 0) {
        binary = std::to_string(N % 2) + binary;
        N /= 2;
    }
    return binary;"
0,0.0,HumanEval_129_minPath,"

std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
    long N = grid.size();
    std::vector<long> result(k);
    std::vector<std::vector<long>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
    std::vector<std::vector<long>> dp(N, std::vector<long>(N, LONG_MAX));
    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;

    pq.push({grid[0][0], 0, 0});
    dp[0][0] = grid[0][0];

    while(!pq.empty()){
        auto cur = pq.top(); pq.pop();
        long dist = cur[0], x = cur[1], y = cur[2];

        if(dist > dp[x][y]) continue;

        if(x * y * 2 == k - 1){
            result[k - 1] = dist;
            return result;
        }

        for(auto& dir : directions){
            long nx = x + dir[0], ny = y + dir[1];
            if(nx < 0 || nx >= N || ny < 0 || ny >= N) continue;
            if(dist + grid[nx][ny] < dp[nx][ny]){
                dp[nx][ny] = dist + grid[nx][ny];
                pq.push({dp[nx][ny], nx, ny});
            }
        }
    }

    return result;"
0,0.0,HumanEval_129_minPath,"
    std::vector<std::vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int n = grid.size();
    std::priority_queue<std::tuple<long, int, int, std::vector<long>>, 
                        std::vector<std::tuple<long, int, int, std::vector<long>>>, 
                        std::greater<std::tuple<long, int, int, std::vector<long>>>> pq;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            pq.push({grid[i][j], i, j, {grid[i][j]}});
        }
    }
    while (!pq.empty()) {
        long len; int x, y; std::vector<long> path;
        std::tie(len, x, y, path) = pq.top(); pq.pop();
        if (path.size() == k) {
            return path;
        }
        for (auto &dir : directions) {
            int nx = x + dir[0], ny = y + dir[1];
            if (nx >= 0 && nx < n && ny >= 0 && ny < n) {
                std::vector<long> np = path;
                np.push_back(grid[nx][ny]);
                pq.push({len + grid[nx][ny], nx, ny, np});
            }
        }
    }
    return {};"
0,0.0,HumanEval_129_minPath,"

std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
    int n = grid.size();
    std::vector<std::vector<long>> dp(n, std::vector<long>(n, std::numeric_limits<long>::max()));
    std::vector<std::vector<int>> moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    std::priority_queue<std::tuple<long, int, int>, std::vector<std::tuple<long, int, int>>, std::greater<>> pq;

    dp[0][0] = grid[0][0];
    pq.push({dp[0][0], 0, 0});

    while(!pq.empty()) {
        auto [cost, x, y] = pq.top();
        pq.pop();

        if(cost > dp[x][y]) continue;

        for(auto &move : moves) {
            int nx = x + move[0], ny = y + move[1];

            if(nx < 0 || ny < 0 || nx >= n || ny >= n) continue;

            if(dp[nx][ny] > cost + grid[nx][ny]) {
                dp[nx][ny] = cost + grid[nx][ny];
                pq.push({dp[nx][ny], nx, ny});
            }
        }
    }

    std::vector<long> result;
    int i = n - 1, j = n - 1;
    result.push_back(grid[i][j]);
    k--;

    while(k--) {
        for(auto &move : moves) {
            int ni = i + move[0], nj = j + move[1];
            if(ni < 0 || nj < 0 || ni >= n || nj >= n) continue;
            if(dp[ni][nj] + grid[i][j] == dp[i][j]) {
                i = ni;
                j = nj;
                result.push_back(grid[i][j]);
                break;
            }
        }
    }

    std::reverse(result.begin(), result.end());
    return result;"
0,0.0,HumanEval_129_minPath,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

vector<long> minPath(vector<vector<long>> grid, long k) {
    long n = grid.size();
    vector<vector<long>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    vector<vector<long>> dp(n, vector<long>(n, LONG_MAX));
    vector<vector<bool>> visited(n, vector<bool>(n, false));
    priority_queue<tuple<long, long, long>, vector<tuple<long, long, long>>, greater<tuple<long, long, long>>> pq;

    dp[0][0] = grid[0][0];
    pq.push({dp[0][0], 0, 0});

    while(!pq.empty() && k > 0) {
        auto [val, i, j] = pq.top();
        pq.pop();
        if(visited[i][j]) continue;
        visited[i][j] = true;
        k--;
        for(auto &dir : directions) {
            long x = i + dir[0], y = j + dir[1];
            if(x < 0 || x >= n || y < 0 || y >= n || visited[x][y]) continue;
            dp[x][y] = min(dp[x][y], val + grid[x][y]);
            pq.push({dp[x][y], x, y});
        }
    }

    vector<long> result;
    for(long i = 0; i < n; i++) {
        for(long j = 0; j < n; j++) {
            if(visited[i][j]) result.push_back(grid[i][j]);
        }
    }

    return result;"
0,0.0,HumanEval_129_minPath,"
std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
    long n = grid.size();
    std::vector<long> result(k);
    std::vector<std::vector<long>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    std::vector<std::vector<long>> dp(n, std::vector<long>(n, LONG_MAX));
    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;

    pq.push({grid[0][0], 0, 0});
    dp[0][0] = grid[0][0];

    while (!pq.empty()) {
        auto cur = pq.top();
        pq.pop();
        long dist = cur[0], x = cur[1], y = cur[2];
        if (dist != dp[x][y]) continue;
        if (dist == k) {
            result = {grid[x][y]};
            return result;
        }
        for (auto& dir : directions) {
            long nx = x + dir[0], ny = y + dir[1];
            if (nx >= 0 && nx < n && ny >= 0 && ny < n && dist + 1 <= k && dist + 1 < dp[nx][ny]) {
                dp[nx][ny] = dist + 1;
                pq.push({dp[nx][ny], nx, ny});
            }
        }
    }

    return result;"
0,0.0,HumanEval_129_minPath,"
#include <queue>
#include <vector>
#include <cstring>

using namespace std;

typedef pair<long, long> pll;

vector<long> minPath(vector<vector<long>> grid, long k) {
    long n = grid.size();
    long dx[4] = {0, 1, 0, -1};
    long dy[4] = {1, 0, -1, 0};

    // Convert 2D grid into 1D array
    vector<long> arr;
    for (long i = 0; i < n; i++) {
        for (long j = 0; j < n; j++) {
            arr.push_back(grid[i][j]);
        }
    }

    // Initialize distance and visited array
    vector<long> dist(n * n, LONG_MAX);
    vector<bool> visited(n * n, false);

    // Dijkstra's algorithm
    priority_queue<pll, vector<pll>, greater<pll>> pq;
    pq.push({0, 0});
    dist[0] = 0;

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();

        if (visited[u]) {
            continue;
        }
        visited[u] = true;

        for (long i = 0; i < 4; i++) {
            long x = u % n + dx[i];
            long y = u / n + dy[i];
            long v = y * n + x;

            if (x >= 0 && x < n && y >= 0 && y < n && !visited[v] && dist[u] + 1 < dist[v]) {
                dist[v] = dist[u] + 1;
                pq.push({dist[v], v});
            }
        }
    }

    // Find the minimum path of length k
    vector<long> path;
    for (long i = 0; i < k; i++) {
        long min_val = LONG_MAX;
        long min_idx = -1;
        for (long j = 0; j < n * n; j++) {
            if (dist[j] == i && arr[j] < min_val) {
                min_val = arr[j];
                min_idx = j;
            }
        }
        path.push_back(min_val);
        dist[min_idx] = LONG_MAX;
    }

    return path;"
0,0.0,HumanEval_129_minPath,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

vector<long> minPath(vector<vector<long>> grid, long k) {
    int n = grid.size();
    vector<vector<long>> dist(n, vector<long>(n, LONG_MAX));
    priority_queue<tuple<long, long, long>, vector<tuple<long, long, long>>, greater<tuple<long, long, long>>> pq;
    pq.emplace(grid[0][0], 0, 0);
    dist[0][0] = grid[0][0];
    vector<vector<int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    while (!pq.empty()) {
        auto [d, x, y] = pq.top();
        pq.pop();
        if (d > dist[x][y]) continue;
        for (auto& dd : dir) {
            int nx = x + dd[0], ny = y + dd[1];
            if (nx < 0 || ny < 0 || nx >= n || ny >= n) continue;
            if (dist[nx][ny] > d + grid[nx][ny]) {
                dist[nx][ny] = d + grid[nx][ny];
                pq.emplace(dist[nx][ny], nx, ny);
            }
        }
    }
    vector<long> res;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            if (dist[i][j] <= k) res.push_back(dist[i][j]);
    sort(res.begin(), res.end());
    return res;
"
0,0.0,HumanEval_129_minPath,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

vector<long> minPath(vector<vector<long>> grid, long k) {
    long n = grid.size();
    vector<vector<long>> dp(k, vector<long>(n * n, LONG_MAX));
    vector<vector<pair<long, long>>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    vector<vector<long>> index(n, vector<long>(n));
    for (long i = 0; i < n; i++)
        for (long j = 0; j < n; j++)
            index[i][j] = i * n + j;
    
    for (long i = 0; i < n; i++)
        for (long j = 0; j < n; j++)
            dp[0][index[i][j]] = grid[i][j];
    
    for (long len = 1; len < k; len++)
        for (long i = 0; i < n; i++)
            for (long j = 0; j < n; j++)
                for (auto& dir : dirs) {
                    long x = i + dir[0], y = j + dir[1];
                    if (x >= 0 && x < n && y >= 0 && y < n)
                        dp[len][index[i][j]] = min(dp[len][index[i][j]], dp[len - 1][index[x][y]] + grid[i][j]);
                }
    
    long min_val = *min_element(dp[k - 1].begin(), dp[k - 1].end());
    long min_index = find(dp[k - 1].begin(), dp[k - 1].end(), min_val) - dp[k - 1].begin();
    vector<long> result(k);
    result[k - 1] = min_val;
    for (long len = k - 1; len > 0; len--) {
        min_val -= grid[min_index / n][min_index % n];
        result[len - 1] = min_val;
        for (auto& dir : dirs) {
            long x = min_index / n + dir[0], y = min_index % n + dir[1];
            if (x >= 0 && x < n && y >= 0 && y < n && dp[len - 1][index[x][y]] == min_val) {
                min_index = index[x][y];
                break;
            }
        }
    }
    return result;"
0,0.0,HumanEval_129_minPath,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

vector<long> minPath(vector<vector<long>> grid, long k) {
    long n = grid.size();
    vector<vector<long>> dist(n, vector<long>(n, LONG_MAX));
    vector<vector<pair<long, long>>> dirs{{{0, 1}, {1, 0}}, {{0, -1}, {1, 0}}, {{-1, 0}, {0, 1}}, {{0, 1}, {-1, 0}}};
    priority_queue<tuple<long, long, long>, vector<tuple<long, long, long>>, greater<tuple<long, long, long>>> pq;
    pq.push({grid[0][0], 0, 0});
    dist[0][0] = grid[0][0];

    while (!pq.empty()) {
        auto [d, x, y] = pq.top();
        pq.pop();
        if (d > dist[x][y]) continue;
        for (auto &dir : dirs) {
            long nx = x + dir[0].first, ny = y + dir[0].second;
            if (nx < 0 || ny < 0 || nx >= n || ny >= n) continue;
            long nd = d + grid[nx][ny];
            if (nd < dist[nx][ny]) {
                dist[nx][ny] = nd;
                pq.push({nd, nx, ny});
            }
        }
    }

    vector<long> res;
    for (long i = 0; i < n; i++) {
        for (long j = 0; j < n; j++) {
            if (dist[i][j] <= k) {
                res.push_back(dist[i][j]);
            }
        }
    }
    sort(res.begin(), res.end());
    return res;"
0,0.0,HumanEval_129_minPath,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

vector<long> minPath(vector<vector<long>> grid, long k) {
    long n = grid.size();
    vector<vector<long>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    priority_queue<pair<long, pair<long, long>>, vector<pair<long, pair<long, long>>>, greater<pair<long, pair<long, long>>>> pq;
    vector<vector<long>> dist(n, vector<long>(n, LONG_MAX));
    pq.push({grid[0][0], {0, 0}});
    dist[0][0] = grid[0][0];

    while (!pq.empty()) {
        long cost = pq.top().first;
        long x = pq.top().second.first;
        long y = pq.top().second.second;
        pq.pop();

        if (cost > dist[x][y]) {
            continue;
        }

        for (auto dir : directions) {
            long newX = x + dir[0];
            long newY = y + dir[1];
            if (newX >= 0 && newX < n && newY >= 0 && newY < n) {
                long newDist = cost + grid[newX][newY];
                if (newDist < dist[newX][newY]) {
                    dist[newX][newY] = newDist;
                    pq.push({newDist, {newX, newY}});
                }
            }
        }
    }

    vector<long> result;
    for (long i = 0; i < k; i++) {
        for (long j = 0; j < k; j++) {
            result.push_back(dist[i][j]);
        }
    }
    sort(result.begin(), result.end());
    return result;
"
0,1.0,HumanEval_98_count_upper,"

long count_upper(std::string s) {
    long count = 0;
    for (int i = 0; i < s.length(); i += 2) {
        if (s[i] == toupper(s[i])) {
            count++;
        }
    }
    return count;
"
0,0.0,HumanEval_98_count_upper,"
    long count = 0;
    for (int i = 0; i < s.length(); i += 2) {
        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {
            count++;
        }
    }
    return count;"
0,0.0,HumanEval_98_count_upper,"
    long count = 0;
    for (int i = 0; i < s.length(); i += 2) {
        if (isupper(s[i])) {
            switch (s[i]) {
                case 'A':
                case 'E':
                case 'I':
                case 'O':
                case 'U':
                    count++;
            }
        }
    }
    return count;"
1,1.0,HumanEval_98_count_upper,"
long count_upper(std::string s) {
    long count = 0;
    for (int i = 0; i < s.length(); i += 2) {
        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {
            count++;
        }
    }
    return count;
"
0,0.0,HumanEval_98_count_upper,"
    long count = 0;
    for (int i = 0; i < s.length(); i += 2) {
        if (isupper(s[i])) {
            if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {
                count++;
            }
        }
    }
    return count;
"
1,1.0,HumanEval_98_count_upper,"

long count_upper(std::string s) {
    long count = 0;
    for (int i = 0; i < s.length(); i += 2) {
        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {
            count++;
        }
    }
    return count;"
1,1.0,HumanEval_98_count_upper,"
long count_upper(std::string s) {
    long count = 0;
    for (int i = 0; i < s.size(); i += 2) {
        if (s[i] == toupper(s[i])) {
            if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {
                count++;
            }
        }
    }
    return count;
"
0,1.0,HumanEval_98_count_upper,"

long count_upper(std::string s) {
    long count = 0;
    for (int i = 0; i < s.size(); i += 2) {
        if (s[i] == toupper(s[i])) {
            count++;
        }
    }
    return count;
"
1,1.0,HumanEval_98_count_upper,"
long count_upper(std::string s) {
    long count = 0;
    for (int i = 0; i < s.length(); i += 2) {
        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {
            count++;
        }
    }
    return count;"
1,1.0,HumanEval_98_count_upper,"
long count_upper(std::string s) {
    long count = 0;
    for (int i = 0; i < s.size(); i += 2) {
        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {
            count++;
        }
    }
    return count;"
0,0.0,HumanEval_120_maximum,"
    // Create a priority queue to store the k maximum numbers.
    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;
    for (long i = 0; i < k; i++) {
        pq.push(arr[i]);
    }

    // Iterate through the rest of the array.
    for (long i = k; i < arr.size(); i++) {
        // If the current number is greater than the smallest number in the queue,
        // remove the smallest number and add the current number.
        if (arr[i] > pq.top()) {
            pq.pop();
            pq.push(arr[i]);
        }
    }

    // Convert the queue to a vector and return it.
    std::vector<long> result(pq.cbegin(), pq.cend());
    return result;"
0,0.0,HumanEval_120_maximum,"
std::vector<long> maximum(std::vector<long> arr, long k) {
    // Create a max heap of size k
    std::priority_queue<long> max_heap;

    // Push the first k elements into the max heap
    for(long i = 0; i < k; i++) {
        max_heap.push(arr[i]);
    }

    // Push the remaining elements into the max heap and pop the maximum element
    for(long i = k; i < arr.size(); i++) {
        if(arr[i] > max_heap.top()) {
            max_heap.pop();
            max_heap.push(arr[i]);
        }
    }

    // Create a vector to store the result
    std::vector<long> result;

    // Pop the elements from the max heap and push them into the result vector
    while(!max_heap.empty()) {
        result.push_back(max_heap.top());
        max_heap.pop();
    }

    // Reverse the result vector to get the maximum k numbers in ascending order
    std::reverse(result.begin(), result.end());

    return result;
"
0,0.0,HumanEval_120_maximum,"
    // Create a max heap to store the k maximum elements.
    std::priority_queue<long> max_heap;

    // Push the first k elements into the max heap.
    for (long i = 0; i < k; i++) {
        max_heap.push(arr[i]);
    }

    // Push the remaining elements into the max heap and pop the maximum element 
    // if the current element is greater than the maximum element in the heap.
    for (long i = k; i < arr.size(); i++) {
        if (arr[i] > max_heap.top()) {
            max_heap.pop();
            max_heap.push(arr[i]);
        }
    }

    // Create a vector to store the k maximum elements.
    std::vector<long> result(k);

    // Pop the elements from the max heap and store them in the result vector.
    for (long i = k - 1; i >= 0; i--) {
        result[i] = max_heap.top();
        max_heap.pop();
    }

    // Sort the result vector in ascending order.
    std::sort(result.begin(), result.end());

    return result;"
0,0.0,HumanEval_120_maximum,"
    // Create a priority queue to store the k maximum numbers
    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;

    // Push the first k elements into the priority queue
    for(long i = 0; i < k; i++) {
        pq.push(arr[i]);
    }

    // Push the remaining elements into the priority queue and pop the smallest one
    for(long i = k; i < arr.size(); i++) {
        if(arr[i] > pq.top()) {
            pq.pop();
            pq.push(arr[i]);
        }
    }

    // Create a vector to store the result
    std::vector<long> result(k);

    // Pop the elements from the priority queue and store them in the result vector
    for(long i = k - 1; i >= 0; i--) {
        result[i] = pq.top();
        pq.pop();
    }

    // Sort the result vector
    std::sort(result.begin(), result.end());

    return result;"
0,1.0,HumanEval_120_maximum,"

std::vector<long> maximum(std::vector<long> arr, long k) {
    // Create a max heap of size k
    std::priority_queue<long> pq;
    
    // Push the first k elements into the heap
    for(long i = 0; i < k; i++) {
        pq.push(arr[i]);
    }
    
    // Push the remaining elements into the heap and pop the maximum element
    for(long i = k; i < arr.size(); i++) {
        pq.push(arr[i]);
        pq.pop();
    }
    
    // Create a result vector with the maximum k numbers
    std::vector<long> result;
    while(!pq.empty()) {
        result.push_back(pq.top());
        pq.pop();
    }
    
    // Sort the result vector in ascending order
    std::sort(result.begin(), result.end());
    
    return result;
"
0,1.0,HumanEval_120_maximum,"

std::vector<long> maximum(std::vector<long> arr, long k) {
    // create a priority queue to store the k maximum numbers
    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;

    // push the first k elements into the priority queue
    for(long i = 0; i < k; i++) {
        pq.push(arr[i]);
    }

    // push the remaining elements into the priority queue
    for(long i = k; i < arr.size(); i++) {
        if(arr[i] > pq.top()) {
            pq.pop();
            pq.push(arr[i]);
        }
    }

    // create a vector to store the k maximum numbers
    std::vector<long> result(k);

    // pop the elements from the priority queue and store them in the result vector
    for(long i = k - 1; i >= 0; i--) {
        result[i] = pq.top();
        pq.pop();
    }

    // sort the result vector in ascending order
    std::sort(result.begin(), result.end());

    return result;"
0,0.0,HumanEval_120_maximum,"
    // Create a max heap from the given array
    std::priority_queue<long> pq(arr.begin(), arr.end());

    // Create a vector to store the maximum k numbers
    std::vector<long> result;

    // Pop the maximum k numbers from the heap and push them into the result vector
    for (long i = 0; i < k; i++) {
        result.push_back(pq.top());
        pq.pop();
    }

    // Sort the result vector in ascending order
    std::sort(result.begin(), result.end());

    // Return the result vector
    return result;
"
0,0.0,HumanEval_120_maximum,"
    // Create a priority queue to store the maximum k numbers
    std::priority_queue<long> pq;

    // Push the first k elements into the priority queue
    for (long i = 0; i < k; i++) {
        pq.push(arr[i]);
    }

    // Push the remaining elements into the priority queue and pop the smallest one if the priority queue is full
    for (long i = k; i < arr.size(); i++) {
        if (arr[i] > pq.top()) {
            pq.pop();
            pq.push(arr[i]);
        }
    }

    // Create a vector to store the result
    std::vector<long> result(k);

    // Pop the elements from the priority queue and push them into the result vector
    for (long i = k - 1; i >= 0; i--) {
        result[i] = pq.top();
        pq.pop();
    }

    // Sort the result vector in ascending order
    std::sort(result.begin(), result.end());

    // Return the result vector
    return result;"
0,0.0,HumanEval_120_maximum,"
std::vector<long> maximum(std::vector<long> arr, long k) {
    // Create a max heap
    std::priority_queue<long> pq;

    // Push the first k elements into the max heap
    for(long i = 0; i < k; i++) {
        pq.push(arr[i]);
    }

    // Push the remaining elements into the max heap and pop the maximum element
    for(long i = k; i < arr.size(); i++) {
        if(arr[i] > pq.top()) {
            pq.pop();
            pq.push(arr[i]);
        }
    }

    // Create a vector to store the k maximum elements
    std::vector<long> result(k);

    // Pop the elements from the max heap and store them in the result vector
    for(long i = k - 1; i >= 0; i--) {
        result[i] = pq.top();
        pq.pop();
    }

    // Return the result vector
    return result;"
0,1.0,HumanEval_120_maximum,"

std::vector<long> maximum(std::vector<long> arr, long k) {
    // Create a priority queue to store the maximum k numbers
    std::priority_queue<long> pq;

    // Push the first k numbers into the priority queue
    for(long i=0; i<k; i++) {
        pq.push(arr[i]);
    }

    // Push the remaining numbers into the priority queue and pop the smallest number
    for(long i=k; i<arr.size(); i++) {
        if(arr[i] > pq.top()) {
            pq.pop();
            pq.push(arr[i]);
        }
    }

    // Create a vector to store the result
    std::vector<long> result;

    // Pop the numbers from the priority queue and push them into the result vector
    while(!pq.empty()) {
        result.push_back(pq.top());
        pq.pop();
    }

    // Reverse the result vector to get the maximum k numbers in ascending order
    reverse(result.begin(), result.end());

    // Return the result vector
    return result;"
0,0.0,HumanEval_24_largest_divisor,"
    assert(n > 1);
    for (long i = n - 1; i > 0; --i) {
        if (n % i == 0)
            return i;
    }
    return -1; // should never reach here
"
0,0.0,HumanEval_24_largest_divisor,"
    assert(n > 1);
    for (long i = n - 1; i > 0; --i) {
        if (n % i == 0) {
            return i;
        }
    }
    return 0;
"
0,0.0,HumanEval_24_largest_divisor,"
    assert(n > 1);
    for (long i = n - 1; i > 0; --i) {
        if (n % i == 0) {
            return i;
        }
    }
    return -1;  // This will never be reached, but is required to compile"
1,1.0,HumanEval_24_largest_divisor,"
long largest_divisor(long n) {
    assert(n > 0);
    for(long i = n - 1; i > 0; --i) {
        if(n % i == 0) {
            return i;
        }
    }
    return -1; // This will never be returned because n is always divisible by itself and 1"
0,0.0,HumanEval_24_largest_divisor,"
    assert(n > 1);
    for (long i = n - 1; i > 0; --i) {
        if (n % i == 0) {
            return i;
        }
    }
    return -1;  // This should never be reached, but is included for completeness"
1,1.0,HumanEval_24_largest_divisor,"
long largest_divisor(long n) {
    assert(n > 1);
    for (long i = n - 1; i > 0; --i) {
        if (n % i == 0) {
            return i;
        }
    }
    return -1; // This should never be reached, but it's good to have a default return value"
0,0.0,HumanEval_24_largest_divisor,"
    assert(n > 1);
    for (long i = n - 1; i > 0; --i) {
        if (n % i == 0) {
            return i;
        }
    }
    return -1;  // This should never be reached"
1,1.0,HumanEval_24_largest_divisor,"
long largest_divisor(long n) {
    assert(n > 1);
    for (long i = n - 1; i > 0; --i) {
        if (n % i == 0) {
            return i;
        }
    }
    return -1; // This should never be reached, but it's a good practice to return a value in case of an error
"
0,1.0,HumanEval_24_largest_divisor,"

long largest_divisor(long n) {
    assert(n > 1);
    for (long i = sqrt(n); i > 0; --i) {
        if (n % i == 0) {
            return i;
        }
    }
    return -1;  // Return -1 if no divisor found"
0,0.0,HumanEval_24_largest_divisor,"
    assert(n > 0);
    for (long i = n - 1; i > 0; --i) {
        if (n % i == 0) {
            return i;
        }
    }
    return -1; // This should never be reached, but it's a good practice to return something in case the loop does not find a divisor.
"
1,1.0,HumanEval_88_sort_array,"
std::vector<long> sort_array(std::vector<long> array) {
    if (array.size() == 0 || array.size() == 1) {
        return array;
    }

    long first = array[0];
    long last = array[array.size() - 1];

    if ((first + last) % 2 == 0) {
        std::sort(array.begin(), array.end(), std::greater<long>());
    } else {
        std::sort(array.begin(), array.end());
    }

    return array;
"
1,1.0,HumanEval_88_sort_array,"

std::vector<long> sort_array(std::vector<long> array) {
    if(array.size() == 0 || array.size() == 1)
        return array;

    std::vector<long> result(array);
    long sum = array[0] + array[array.size() - 1];

    if(sum % 2 == 0)
        std::sort(result.begin(), result.end(), std::greater<long>());
    else
        std::sort(result.begin(), result.end());

    return result;
"
0,0.0,HumanEval_88_sort_array,"
    // Check if the first and last elements of the vector exist
    if(array.empty() || array.size() == 1)
        return array;

    // Calculate the sum of the first and last elements
    long sum = array[0] + array[array.size()-1];

    // If the sum is even, sort the vector in descending order
    if(sum % 2 == 0)
        std::sort(array.begin(), array.end(), std::greater<long>());
    // If the sum is odd, sort the vector in ascending order
    else
        std::sort(array.begin(), array.end());

    return array;
"
1,1.0,HumanEval_88_sort_array,"
std::vector<long> sort_array(std::vector<long> array) {
    if (array.size() == 0) return array;
    if (array.size() == 1) return array;
    
    std::vector<long> result(array);
    long sum = array[0] + array[array.size() - 1];
    
    if (sum % 2 == 0) {
        std::sort(result.begin(), result.end(), std::greater<long>());
    } else {
        std::sort(result.begin(), result.end());
    }
    
    return result;
"
1,1.0,HumanEval_88_sort_array,"
std::vector<long> sort_array(std::vector<long> array) {
    // Check if the array is empty
    if (array.empty()) {
        return array;
    }

    // Calculate the sum of the first and last elements
    long sum = array[0] + array[array.size() - 1];

    // Sort the array in ascending order if the sum is odd,
    // or in descending order if the sum is even
    if (sum % 2 == 1) {
        std::sort(array.begin(), array.end());
    } else {
        std::sort(array.begin(), array.end(), std::greater<>());
    }

    return array;
"
1,1.0,HumanEval_88_sort_array,"
std::vector<long> sort_array(std::vector<long> array) {
    if (array.size() == 0 || array.size() == 1) {
        return array;
    }

    long sum = array[0] + array[array.size() - 1];
    std::vector<long> result(array);

    if (sum % 2 == 0) {
        // If sum is even, sort in descending order
        std::sort(result.begin(), result.end(), std::greater<long>());
    } else {
        // If sum is odd, sort in ascending order
        std::sort(result.begin(), result.end());
    }

    return result;"
0,1.0,HumanEval_88_sort_array,"
std::vector<long> sort_array(std::vector<long> array) {
    assert(!array.empty());

    long sum = array.front() + array.back();
    std::vector<long> result(array);
    std::sort(result.begin(), result.end());

    if (sum % 2 == 0) {
        std::reverse(result.begin(), result.end());
    }

    return result;"
1,1.0,HumanEval_88_sort_array,"
std::vector<long> sort_array(std::vector<long> array) {
    if (array.size() == 0 || array.size() == 1) {
        return array;
    }
    long first = array[0];
    long last = array[array.size() - 1];
    if ((first + last) % 2 == 0) {
        std::sort(array.begin(), array.end(), std::greater<long>());
    } else {
        std::sort(array.begin(), array.end());
    }
    return array;
"
0,0.0,HumanEval_88_sort_array,"
std::vector<long> sort_array(std::vector<long> array) {
    long first = array[0];
    long last = array[array.size() - 1];

    if ((first + last) % 2 == 0) {
        std::sort(array.begin(), array.end(), std::greater<long>());
    } else {
        std::sort(array.begin(), array.end());
    }

    return array;"
1,1.0,HumanEval_88_sort_array,"
std::vector<long> sort_array(std::vector<long> array) {
    // Check if the array is empty
    if(array.empty())
        return array;

    // Calculate the sum of the first and last elements
    long sum = array[0] + array[array.size() - 1];

    // If the sum is odd, sort the array in ascending order
    if(sum % 2 == 1)
        std::sort(array.begin(), array.end());
    // If the sum is even, sort the array in descending order
    else
        std::sort(array.rbegin(), array.rend());

    return array;
"
0,1.0,HumanEval_106_f,"

std::vector<long> f(long n) {
    std::vector<long> result(n);
    for(long i = 0; i < n; i++) {
        long index = i + 1;
        if(index % 2 == 0) {
            result[i] = factorial(index);
        } else {
            result[i] = sum_till_n(index);
        }
    }
    return result;"
1,1.0,HumanEval_106_f,"
std::vector<long> f(long n) {
    std::vector<long> result(n);
    for (long i = 1; i <= n; i++) {
        if (i % 2 == 0) {
            result[i-1] = 1;
            for (long j = 2; j <= i; j++) {
                result[i-1] *= j;
            }
        } else {
            result[i-1] = 0;
            for (long j = 1; j <= i; j++) {
                result[i-1] += j;
            }
        }
    }
    return result;"
0,1.0,HumanEval_106_f,"

std::vector<long> f(long n) {
    std::vector<long> result(n);
    for(long i = 0; i < n; i++) {
        if(i % 2 == 0) {
            result[i] = factorial(i + 1);
        } else {
            result[i] = sum_till_n(i + 1);
        }
    }
    return result;"
0,1.0,HumanEval_106_f,"

std::vector<long> f(long n) {
    std::vector<long> result(n);
    for(long i = 1; i <= n; i++) {
        if(i % 2 == 0) {
            result[i - 1] = factorial(i);
        } else {
            result[i - 1] = sum_to_n(i);
        }
    }
    return result;
"
0,1.0,HumanEval_106_f,"

std::vector<long> f(long n) {
    std::vector<long> result(n);
    for(long i = 1; i <= n; i++) {
        if(i % 2 == 0) {
            result[i - 1] = factorial(i);
        } else {
            result[i - 1] = sum_to_n(i);
        }
    }
    return result;
"
0,0.0,HumanEval_106_f,"
    std::vector<long> result(n);
    for (long i = 1; i <= n; i++) {
        if (i % 2 == 0) {
            long factorial = 1;
            for (long j = 1; j <= i; j++) {
                factorial *= j;
            }
            result[i-1] = factorial;
        } else {
            long sum = 0;
            for (long j = 1; j <= i; j++) {
                sum += j;
            }
            result[i-1] = sum;
        }
    }
    return result;"
0,1.0,HumanEval_106_f,"

std::vector<long> f(long n) {
    std::vector<long> result(n);
    for(long i = 0; i < n; i++) {
        long index = i + 1;
        if(index % 2 == 0) {
            result[i] = factorial(index);
        } else {
            result[i] = sum_to_n(index);
        }
    }
    return result;"
0,1.0,HumanEval_106_f,"

std::vector<long> f(long n) {
    std::vector<long> result(n);
    for(long i = 0; i < n; i++) {
        if(i % 2 == 0) {
            result[i] = factorial(i+1);
        } else {
            result[i] = sum_till_n(i+1);
        }
    }
    return result;
"
0,1.0,HumanEval_106_f,"

std::vector<long> f(long n) {
    std::vector<long> result(n);
    for(long i = 0; i < n; i++) {
        if(i % 2 == 0) {
            result[i] = factorial(i + 1);
        } else {
            result[i] = sum(i + 1);
        }
    }
    return result;
"
1,1.0,HumanEval_106_f,"
std::vector<long> f(long n) {
    std::vector<long> result(n);
    for (long i = 1; i <= n; i++) {
        if (i % 2 == 0) {
            long factorial = 1;
            for (long j = 1; j <= i; j++) {
                factorial *= j;
            }
            result[i-1] = factorial;
        } else {
            long sum = 0;
            for (long j = 1; j <= i; j++) {
                sum += j;
            }
            result[i-1] = sum;
        }
    }
    return result;
"
1,1.0,HumanEval_77_iscube,"
bool iscube(long a) {
    long left = 0;
    long right = abs(a);

    while (left <= right) {
        long mid = left + (right - left) / 2;
        long cube = mid * mid * mid;

        if (cube == abs(a)) {
            return true;
        } else if (cube < abs(a)) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return false;"
1,1.0,HumanEval_77_iscube,"

bool iscube(long a) {
    long left = 0;
    long right = abs(a);
    while (left <= right) {
        long mid = (left + right) / 2;
        long cube = mid * mid * mid;
        if (cube == abs(a)) {
            return true;
        } else if (cube < abs(a)) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return false;"
1,1.0,HumanEval_77_iscube,"

bool iscube(long a) {
    long start = 0;
    long end = abs(a);

    while (start <= end) {
        long mid = start + (end - start) / 2;
        long cube = mid * mid * mid;

        if (cube == abs(a)) {
            return true;
        }
        else if (cube < abs(a)) {
            start = mid + 1;
        }
        else {
            end = mid - 1;
        }
    }
    return false;
"
1,1.0,HumanEval_77_iscube,"

bool iscube(long a) {
    long start = 0;
    long end = abs(a);

    while (start <= end) {
        long mid = (start + end) / 2;
        long cube = mid * mid * mid;

        if (cube == abs(a)) {
            return true;
        }
        else if (cube < abs(a)) {
            start = mid + 1;
        }
        else {
            end = mid - 1;
        }
    }

    return false;
"
1,1.0,HumanEval_77_iscube,"
bool iscube(long a) {
    long start = 0, end = abs(a);

    while (start <= end) {
        long mid = (start + end) / 2;
        long cube = mid * mid * mid;

        if (cube == abs(a)) {
            return true;
        } else if (cube < abs(a)) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }

    return false;"
1,1.0,HumanEval_77_iscube,"
bool iscube(long a) {
    long start = 0;
    long end = abs(a);
    while (start <= end) {
        long mid = start + (end - start) / 2;
        long cube = mid * mid * mid;
        if (cube == abs(a)) {
            return true;
        } else if (cube < abs(a)) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    return false;
"
0,0.0,HumanEval_77_iscube,"
    long low = 0;
    long high = abs(a);

    while (low <= high) {
        long mid = (low + high) / 2;
        long cube = mid * mid * mid;

        if (cube == abs(a)) {
            return true;
        } else if (cube < abs(a)) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return false;
"
1,1.0,HumanEval_77_iscube,"

bool iscube(long a) {
    long start = 0, end = abs(a);
    while (start <= end) {
        long mid = start + (end - start) / 2;
        long pow = mid * mid * mid;
        if (pow == abs(a)) {
            return true;
        }
        else if (pow < abs(a)) {
            start = mid + 1;
        }
        else {
            end = mid - 1;
        }
    }
    return false;"
1,1.0,HumanEval_77_iscube,"
bool iscube(long a) {
    long start = 0, end = abs(a);
    while (start <= end) {
        long mid = start + (end - start) / 2;
        long cube = mid * mid * mid;
        if (cube == abs(a)) {
            return true;
        } else if (cube < abs(a)) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    return false;
"
1,1.0,HumanEval_77_iscube,"

bool iscube(long a) {
    long start = 0, end = abs(a);

    while (start <= end) {
        long mid = start + (end - start) / 2;
        long cube = mid * mid * mid;

        if (cube == abs(a)) {
            return true;
        } else if (cube < abs(a)) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }

    return false;"
0,0.0,HumanEval_93_encode,"
    std::string result = """";
    for (char& c : message) {
        if (std::isalpha(c)) {
            if (std::islower(c)) {
                result += std::toupper(c);
            } else {
                result += std::tolower(c);
            }
        } else {
            result += c;
        }
    }
    for (char& c : result) {
        if (std::isalpha(c)) {
            if (c == 'A' || c == 'a') {
                c = 'C';
            } else if (c == 'E' || c == 'e') {
                c = 'G';
            } else if (c == 'I' || c == 'i') {
                c = 'K';
            } else if (c == 'O' || c == 'o') {
                c = 'Q';
            } else if (c == 'U' || c == 'u') {
                c = 'W';
            }
        }
    }
    return result;
"
0,0.0,HumanEval_93_encode,"
std::string encode(std::string message) {
    std::string vowels = ""aeiouAEIOU"";
    for (int i = 0; i < message.length(); i++) {
        // Swap case of the character
        if (islower(message[i]))
            message[i] = toupper(message[i]);
        else if (isupper(message[i]))
            message[i] = tolower(message[i]);
        
        // Replace vowels with the letter that appears 2 places ahead
        if (vowels.find(message[i]) != std::string::npos) {
            if (islower(message[i])) {
                message[i] = 'c';
            } else {
                message[i] = 'C';
            }
        }
    }
    return message;"
0,0.0,HumanEval_93_encode,"

std::string encode(std::string message) {
    std::string vowels = ""aeiouAEIOU"";
    std::string result = """";
    for (char& c : message) {
        if (isalpha(c)) {
            if (vowels.find(c) != std::string::npos) {
                if (islower(c)) {
                    result += char(c - 'a' + 'c' - 'b');
                } else {
                    result += char(c - 'A' + 'C' - 'B');
                }
            } else {
                if (islower(c)) {
                    result += char(c - 'a' + 'a' + 2);
                } else {
                    result += char(c - 'A' + 'A' + 2);
                }
            }
        } else {
            result += c;
        }
    }
    return result;"
0,0.0,HumanEval_93_encode,"
    std::string result = """";
    for(char& c : message) {
        if(isupper(c)) {
            result += tolower(c);
        } else if(islower(c)) {
            result += toupper(c);
        }
        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || 
           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {
            if(islower(c)) {
                result += 'E';
            } else {
                result += 'e';
            }
        } else {
            result += c;
        }
    }
    return result;
"
0,0.0,HumanEval_93_encode,"
std::string encode(std::string message) {
    std::string result = """";
    for (char& c : message) {
        if (isalpha(c)) {
            if (islower(c)) {
                result += toupper(c);
            } else {
                result += tolower(c);
            }
        } else {
            result += c;
        }
    }
    for (char& c : result) {
        if (isalpha(c)) {
            if (tolower(c) == 'a') {
                c = 'c';
            } else if (tolower(c) == 'e') {
                c = 'g';
            } else if (tolower(c) == 'i') {
                c = 'k';
            } else if (tolower(c) == 'o') {
                c = 'q';
            } else if (tolower(c) == 'u') {
                c = 'w';
            }
        }
    }
    return result;"
0,0.0,HumanEval_93_encode,"
std::string encode(std::string message) {
    for(int i = 0; i < message.size(); i++){
        // Swap case
        if(islower(message[i])){
            message[i] = toupper(message[i]);
        }
        else if(isupper(message[i])){
            message[i] = tolower(message[i]);
        }

        // Replace vowels
        if(message[i] == 'A' || message[i] == 'E' || message[i] == 'I' || 
           message[i] == 'O' || message[i] == 'U'){
            message[i] = 'E';
        }
        else if(message[i] == 'a' || message[i] == 'e' || message[i] == 'i' || 
                message[i] == 'o' || message[i] == 'u'){
            message[i] = 'i';
        }
    }
    return message;"
1,0.0,HumanEval_93_encode,"

std::string encode(std::string message) {
    std::string encoded_message = """";
    for(char& c : message) {
        if(isalpha(c)) {
            if(islower(c)) {
                encoded_message += toupper(c);
            } else {
                encoded_message += tolower(c);
            }
        } else {
            encoded_message += c;
        }
        if(encoded_message.back() == 'a' || encoded_message.back() == 'e' || encoded_message.back() == 'i' || encoded_message.back() == 'o' || encoded_message.back() == 'u' || encoded_message.back() == 'A' || encoded_message.back() == 'E' || encoded_message.back() == 'I' || encoded_message.back() == 'O' || encoded_message.back() == 'U') {
            if(islower(encoded_message.back())) {
                encoded_message.back() = char(encoded_message.back() + 2);
            } else {
                encoded_message.back() = char(encoded_message.back() + 2);
            }
        }
    }
    return encoded_message;"
1,0.0,HumanEval_93_encode,"

std::string encode(std::string message) {
    std::string vowels = ""aeiouAEIOU"";
    for (int i = 0; i < message.size(); i++) {
        if (isalpha(message[i])) {
            if (islower(message[i])) {
                message[i] = toupper(message[i]);
            }
            else {
                message[i] = tolower(message[i]);
            }
        }
        if (vowels.find(message[i]) != std::string::npos) {
            switch (message[i]) {
                case 'A':
                    message[i] = 'C';
                    break;
                case 'E':
                    message[i] = 'G';
                    break;
                case 'I':
                    message[i] = 'K';
                    break;
                case 'O':
                    message[i] = 'Q';
                    break;
                case 'U':
                    message[i] = 'W';
                    break;
                case 'a':
                    message[i] = 'c';
                    break;
                case 'e':
                    message[i] = 'g';
                    break;
                case 'i':
                    message[i] = 'k';
                    break;
                case 'o':
                    message[i] = 'q';
                    break;
                case 'u':
                    message[i] = 'w';
                    break;
            }
        }
    }
    return message;
"
1,0.0,HumanEval_93_encode,"
std::string encode(std::string message) {
    std::string result = """";
    for (char& c : message) {
        if (std::isalpha(c)) {
            if (std::islower(c)) {
                result += std::toupper(c);
            } else {
                result += std::tolower(c);
            }
        } else {
            result += c;
        }
    }
    for (char& c : result) {
        if (std::isalpha(c)) {
            if (c == 'A') c = 'C';
            else if (c == 'E') c = 'G';
            else if (c == 'I') c = 'K';
            else if (c == 'O') c = 'Q';
            else if (c == 'U') c = 'W';
            else if (c == 'a') c = 'c';
            else if (c == 'e') c = 'g';
            else if (c == 'i') c = 'k';
            else if (c == 'o') c = 'q';
            else if (c == 'u') c = 'w';
        }
    }
    return result;"
1,0.0,HumanEval_93_encode,"
std::string encode(std::string message) {
    std::string encoded_message = """";
    for (char &c : message) {
        if (isalpha(c)) {
            if (isupper(c)) {
                encoded_message += tolower(c);
            } else {
                encoded_message += toupper(c);
            }
        } else {
            encoded_message += c;
        }
    }
    for (char &c : encoded_message) {
        if (isalpha(c)) {
            if (tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' || tolower(c) == 'o' || tolower(c) == 'u') {
                if (isupper(c)) {
                    c = char(int(c) + 2);
                } else {
                    c = char(int(c) + 2);
                }
            }
        }
    }
    return encoded_message;
"
0,0.0,HumanEval_91_is_bored,"
    long boredom_count = 0;
    size_t pos = 0;
    std::string delimiter = "".?"";
    std::string token;

    while ((pos = S.find_first_of(delimiter)) != std::string::npos) {
        token = S.substr(0, pos);
        if (token.find(""I"") == 0) {
            boredom_count++;
        }
        S.erase(0, pos + 1);
    }
    if (S.find(""I"") == 0) {
        boredom_count++;
    }

    return boredom_count;
"
0,1.0,HumanEval_91_is_bored,"

long is_bored(std::string S) {
    long boredoms = 0;
    std::string::size_type start = 0;
    std::string::size_type end = 0;

    while (end != std::string::npos) {
        end = S.find_first_of("".?!"", start);
        std::string sentence = S.substr(start, end - start);
        if (!sentence.empty() && sentence[0] == 'I') {
            boredoms++;
        }
        start = end != std::string::npos ? end + 1 : std::string::npos;
    }

    return boredoms;
"
0,0.0,HumanEval_91_is_bored,"

long is_bored(std::string S) {
    long boredoms = 0;
    std::string::size_type start = 0;
    std::string::size_type end = 0;

    while (end != std::string::npos)
    {
        end = S.find_first_of("".?!"", start);

        std::string sentence = S.substr(start, end - start);
        if (sentence.size() > 0 && sentence[0] == 'I') 
        {
            boredoms++;
        }

        start = end != std::string::npos ? end + 1 : std::string::npos;
    }

    return boredoms;"
0,0.0,HumanEval_91_is_bored,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

long is_bored(string S) {
    long boredomCount = 0;
    string delimiters = "".?! "";
    size_t pos = 0;
    string token;

    while ((pos = S.find_first_of(delimiters)) != string::npos) {
        token = S.substr(0, pos);
        if(token.length() > 0 && token[0] == 'I') {
            boredomCount++;
        }
        S.erase(0, pos + 1);
    }
    return boredomCount;"
0,0.0,HumanEval_91_is_bored,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

long is_bored(string S) {
    long boredom_count = 0;
    string delimiters = "".?! "";
    size_t pos = 0;
    string token;

    while ((pos = S.find_first_of(delimiters)) != string::npos) {
        token = S.substr(0, pos);
        if (token.size() > 0 && token[0] == 'I') {
            boredom_count++;
        }
        S.erase(0, pos + delimiters.size());
    }
    return boredom_count;"
0,1.0,HumanEval_91_is_bored,"

long is_bored(std::string S) {
    // Initialize count to 0
    long count = 0;

    // Split the string into sentences
    std::vector<std::string> sentences;
    size_t pos = 0, found;
    while ((found = S.find_first_of("".?!"", pos)) != std::string::npos) {
        sentences.push_back(S.substr(pos, found - pos + 1));
        pos = found + 1;
    }

    // Check each sentence if it starts with ""I""
    for (std::string sentence : sentences) {
        if (sentence[0] == 'I') {
            count++;
        }
    }

    return count;"
0,0.0,HumanEval_91_is_bored,"
long is_bored(std::string S) {
    long boredoms = 0;
    std::string delimiters = "".?! "";
    size_t start = 0, end = 0;

    while (end != std::string::npos) {
        end = S.find_first_of(delimiters, start);
        std::string sentence = S.substr(start, end - start);
        if (!sentence.empty() && sentence[0] == 'I') {
            boredoms++;
        }
        start = end != std::string::npos ? end + 1 : std::string::npos;
    }

    return boredoms;"
0,0.0,HumanEval_91_is_bored,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

// Function to count the number of boredoms
long is_bored(string S) {
    // Initialize count to 0
    long count = 0;
    // Split the string into sentences
    vector<string> sentences;
    stringstream ss(S);
    string temp;
    while (getline(ss, temp, '.')) {
        sentences.push_back(temp);
    }
    getline(ss, temp, '?');
    sentences.push_back(temp);
    getline(ss, temp, '!');
    sentences.push_back(temp);
    // Iterate over the sentences
    for (string sentence : sentences) {
        // Trim leading and trailing whitespaces
        sentence.erase(sentence.begin(), find_if(sentence.begin(), sentence.end(), [](int ch) {
            return !isspace(ch);
        }));
        sentence.erase(find_if(sentence.rbegin(), sentence.rend(), [](int ch) {
            return !isspace(ch);
        }).base(), sentence.end());
        // Check if the sentence starts with ""I""
        if (sentence.length() > 0 && sentence[0] == 'I') {
            count++;
        }
    }
    return count;"
0,0.0,HumanEval_91_is_bored,"

long is_bored(std::string S) {
    long boredoms = 0;
    std::stringstream ss(S);
    std::string word;

    while (ss >> word) {
        if (word[0] == 'I') {
            boredoms++;
        }
    }

    return boredoms;
"
0,0.0,HumanEval_91_is_bored,"

long is_bored(std::string S) {
    long boredoms = 0;
    std::stringstream ss(S);
    std::string word;
    while (ss >> word) {
        if (word[0] == 'I') {
            boredoms++;
        }
    }
    return boredoms;"
1,1.0,HumanEval_43_pairs_sum_to_zero,"

bool pairs_sum_to_zero(std::vector<long> l) {
    std::unordered_set<long> s;
    for (long i : l) {
        if (s.find(-i) != s.end()) {
            return true;
        }
        s.insert(i);
    }
    return false;"
1,1.0,HumanEval_43_pairs_sum_to_zero,"
bool pairs_sum_to_zero(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    int left = 0;
    int right = l.size() - 1;
    while (left < right) {
        int sum = l[left] + l[right];
        if (sum == 0) {
            return true;
        }
        else if (sum < 0) {
            left++;
        }
        else {
            right--;
        }
    }
    return false;"
0,0.0,HumanEval_43_pairs_sum_to_zero,"
    std::unordered_set<long> s;
    for (long i : l) {
        if (s.find(-i) != s.end()) {
            return true;
        }
        s.insert(i);
    }
    return false;"
1,1.0,HumanEval_43_pairs_sum_to_zero,"

bool pairs_sum_to_zero(std::vector<long> l) {
    std::unordered_set<long> s;
    for (long i : l) {
        if (s.find(-i) != s.end()) {
            return true;
        }
        s.insert(i);
    }
    return false;
"
1,1.0,HumanEval_43_pairs_sum_to_zero,"

bool pairs_sum_to_zero(std::vector<long> l) {
    std::unordered_set<long> s;
    for (long i : l) {
        if (s.find(-i) != s.end()) {
            return true;
        }
        s.insert(i);
    }
    return false;"
1,1.0,HumanEval_43_pairs_sum_to_zero,"

bool pairs_sum_to_zero(std::vector<long> l) {
    std::unordered_set<long> s;
    for (long i : l) {
        if (s.find(i) != s.end()) {
            return true;
        }
        s.insert(-i);
    }
    return false;"
1,1.0,HumanEval_43_pairs_sum_to_zero,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

bool pairs_sum_to_zero(vector<long> l) {
    unordered_set<long> s;
    for (long i : l) {
        if (s.find(-i) != s.end()) {
            return true;
        }
        s.insert(i);
    }
    return false;"
1,1.0,HumanEval_43_pairs_sum_to_zero,"
bool pairs_sum_to_zero(std::vector<long> l) {
    std::unordered_set<long> s;
    for (long i : l) {
        if (s.find(-i) != s.end()) {
            return true;
        }
        s.insert(i);
    }
    return false;
"
1,1.0,HumanEval_43_pairs_sum_to_zero,"
bool pairs_sum_to_zero(std::vector<long> l) {
    std::unordered_set<long> s;
    for (long i : l) {
        if (s.find(-i) != s.end()) {
            return true;
        }
        s.insert(i);
    }
    return false;
"
1,1.0,HumanEval_43_pairs_sum_to_zero,"
bool pairs_sum_to_zero(std::vector<long> l) {
    std::unordered_set<long> s;
    for (long i : l) {
        if (s.find(-i) != s.end()) {
            return true;
        }
        s.insert(i);
    }
    return false;"
1,1.0,HumanEval_71_triangle_area,"

float triangle_area(long a, long b, long c) {
    if(a + b > c && b + c > a && c + a > b) {
        float s = (a + b + c) / 2.0f;
        float area = sqrt(s * (s - a) * (s - b) * (s - c));
        return roundf(area * 100) / 100;
    } else {
        return -1;
    }
"
0,0.0,HumanEval_71_triangle_area,"
    if(a + b > c && a + c > b && b + c > a) {
        float s = (a + b + c) / 2.0;
        float area = sqrt(s * (s - a) * (s - b) * (s - c));
        return roundf(area * 100) / 100;
    } else {
        return -1;
    }"
1,1.0,HumanEval_71_triangle_area,"

float triangle_area(long a, long b, long c) {
    if (a + b <= c || a + c <= b || b + c <= a) {
        return -1;
    }

    float s = (a + b + c) / 2.0;
    float area = sqrt(s * (s - a) * (s - b) * (s - c));

    return roundf(area * 100) / 100;"
1,1.0,HumanEval_71_triangle_area,"

float triangle_area(long a, long b, long c) {
    // Check if the sides form a valid triangle
    if (a + b <= c || a + c <= b || b + c <= a) {
        return -1;
    }

    // Calculate semi-perimeter
    float s = (a + b + c) / 2.0f;

    // Calculate area using Heron's formula
    float area = sqrt(s * (s - a) * (s - b) * (s - c));

    // Round the area to 2 decimal points
    return roundf(area * 100) / 100;"
1,1.0,HumanEval_71_triangle_area,"
float triangle_area(long a, long b, long c) {
    if(a + b > c && a + c > b && b + c > a) {
        float s = (a + b + c) / 2.0;
        float area = sqrt(s * (s - a) * (s - b) * (s - c));
        return roundf(area * 100) / 100;
    } else {
        return -1;
    }"
1,1.0,HumanEval_71_triangle_area,"
float triangle_area(long a, long b, long c) {
    // Check if the sides form a valid triangle
    if (a + b > c && a + c > b && b + c > a) {
        // Calculate the semi-perimeter
        float s = (a + b + c) / 2.0f;
        // Calculate the area using Heron's formula
        float area = sqrt(s * (s - a) * (s - b) * (s - c));
        // Round the area to 2 decimal points
        return roundf(area * 100) / 100;
    } else {
        // Return -1 if the sides do not form a valid triangle
        return -1;
    }"
1,1.0,HumanEval_71_triangle_area,"

float triangle_area(long a, long b, long c) {
    // Check if the three sides form a valid triangle
    if (a + b <= c || a + c <= b || b + c <= a) {
        return -1;
    }

    // Calculate the semi-perimeter
    float s = (a + b + c) / 2.0f;

    // Calculate the area using Heron's formula
    float area = sqrt(s * (s - a) * (s - b) * (s - c));

    // Round the area to 2 decimal points
    area = roundf(area * 100) / 100;

    return area;"
1,1.0,HumanEval_71_triangle_area,"

float triangle_area(long a, long b, long c) {
    if (a + b > c && a + c > b && b + c > a) {
        float s = (a + b + c) / 2.0;
        float area = sqrt(s * (s - a) * (s - b) * (s - c));
        return roundf(area * 100) / 100;
    } else {
        return -1;
    }"
1,1.0,HumanEval_71_triangle_area,"
float triangle_area(long a, long b, long c) {
    // Check if the sides can form a valid triangle
    if(a + b > c && b + c > a && a + c > b) {
        // Calculate semi-perimeter
        float s = (a + b + c) / 2.0f;
        // Calculate area using Heron's formula
        float area = sqrt(s * (s - a) * (s - b) * (s - c));
        // Round the area to 2 decimal points
        return roundf(area * 100) / 100;
    } else {
        // Return -1 if the sides can't form a valid triangle
        return -1;
    }"
1,1.0,HumanEval_71_triangle_area,"
float triangle_area(long a, long b, long c) {
    // Check if the three sides form a valid triangle
    if(a + b > c && a + c > b && b + c > a) {
        // Use Heron's formula to calculate the area of the triangle
        float s = (a + b + c) / 2.0f;
        float area = sqrt(s * (s - a) * (s - b) * (s - c));
        // Round the area to 2 decimal points
        return roundf(area * 100) / 100;
    } else {
        // If the three sides do not form a valid triangle, return -1
        return -1;
    }"
1,1.0,HumanEval_148_bf,"

std::vector<std::string> bf(std::string planet1, std::string planet2) {
    std::vector<std::string> planets = {""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    std::vector<std::string> result;

    // Check if planet1 and planet2 are valid
    if (std::find(planets.begin(), planets.end(), planet1) == planets.end() || std::find(planets.begin(), planets.end(), planet2) == planets.end()) {
        return result;
    }

    // Get the index of planet1 and planet2 in the planets vector
    int index1 = std::distance(planets.begin(), std::find(planets.begin(), planets.end(), planet1));
    int index2 = std::distance(planets.begin(), std::find(planets.begin(), planets.end(), planet2));

    // Make sure index1 is not greater than index2
    if (index1 > index2) {
        std::swap(index1, index2);
    }

    // Get all planets between planet1 and planet2
    for (int i = index1 + 1; i < index2; i++) {
        result.push_back(planets[i]);
    }

    return result;"
1,1.0,HumanEval_148_bf,"

std::vector<std::string> bf(std::string planet1, std::string planet2) {
    std::vector<std::string> planets = {""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    std::vector<std::string> result;

    // Check if planet1 and planet2 are valid
    auto it1 = std::find(planets.begin(), planets.end(), planet1);
    auto it2 = std::find(planets.begin(), planets.end(), planet2);

    if(it1 == planets.end() || it2 == planets.end()) {
        return result; // return an empty vector
    }

    // Get the positions of planet1 and planet2 in the planets vector
    int pos1 = std::distance(planets.begin(), it1);
    int pos2 = std::distance(planets.begin(), it2);

    // Ensure planet1 is not further from the sun than planet2
    if(pos1 > pos2) {
        std::swap(pos1, pos2);
    }

    // Get all planets between planet1 and planet2
    for(int i = pos1+1; i < pos2; i++) {
        result.push_back(planets[i]);
    }

    return result;
"
1,1.0,HumanEval_148_bf,"

std::vector<std::string> bf(std::string planet1, std::string planet2) {
    std::vector<std::string> planets {""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    std::vector<std::string> result;

    auto it1 = std::find(planets.begin(), planets.end(), planet1);
    auto it2 = std::find(planets.begin(), planets.end(), planet2);

    if(it1 == planets.end() || it2 == planets.end()) {
        return result;
    }

    int index1 = std::distance(planets.begin(), it1);
    int index2 = std::distance(planets.begin(), it2);

    if(index1 > index2) {
        std::swap(index1, index2);
    }

    for(int i = index1 + 1; i < index2; i++) {
        result.push_back(planets[i]);
    }

    return result;"
0,1.0,HumanEval_148_bf,"

std::vector<std::string> bf(std::string planet1, std::string planet2) {
    std::map<std::string, int> planets_order = {
        {""Mercury"", 1},
        {""Venus"", 2},
        {""Earth"", 3},
        {""Mars"", 4},
        {""Jupiter"", 5},
        {""Saturn"", 6},
        {""Uranus"", 7},
        {""Neptune"", 8}
    };

    if (planets_order.find(planet1) == planets_order.end() || planets_order.find(planet2) == planets_order.end()) {
        return std::vector<std::string>();
    }

    int start = std::min(planets_order[planet1], planets_order[planet2]);
    int end = std::max(planets_order[planet1], planets_order[planet2]);

    std::vector<std::string> result;
    for (auto& planet : planets_order) {
        if (planet.second > start && planet.second < end) {
            result.push_back(planet.first);
        }
    }

    return result;
"
1,0.0,HumanEval_148_bf,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

vector<string> bf(string planet1, string planet2) {
    vector<string> planets_order = {""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    vector<string> result;
    int pos1 = -1, pos2 = -1;

    // Check if planet1 and planet2 are valid
    for (int i = 0; i < planets_order.size(); i++) {
        if (planets_order[i] == planet1) pos1 = i;
        if (planets_order[i] == planet2) pos2 = i;
    }

    // If either of the planets is invalid, return an empty vector
    if (pos1 == -1 || pos2 == -1) return result;

    // If planet1 is closer to the sun than planet2, swap their positions
    if (pos1 > pos2) {
        swap(pos1, pos2);
    }

    // Add planets that are between planet1 and planet2 to the result vector
    for (int i = pos1+1; i < pos2; i++) {
        result.push_back(planets_order[i]);
    }

    return result;"
0,1.0,HumanEval_148_bf,"

std::vector<std::string> bf(std::string planet1, std::string planet2) {
    std::map<std::string, int> planets_order = {
        {""Mercury"", 1},
        {""Venus"", 2},
        {""Earth"", 3},
        {""Mars"", 4},
        {""Jupiter"", 5},
        {""Saturn"", 6},
        {""Uranus"", 7},
        {""Neptune"", 8}
    };

    if (planets_order.find(planet1) == planets_order.end() || planets_order.find(planet2) == planets_order.end()) {
        return std::vector<std::string>();
    }

    int start = std::min(planets_order[planet1], planets_order[planet2]);
    int end = std::max(planets_order[planet1], planets_order[planet2]);

    std::vector<std::string> result;
    for (auto& pair : planets_order) {
        if (pair.second > start && pair.second < end) {
            result.push_back(pair.first);
        }
    }

    return result;"
1,1.0,HumanEval_148_bf,"

std::vector<std::string> bf(std::string planet1, std::string planet2) {
    std::vector<std::string> planets = {""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    std::vector<std::string> result;

    // Check if planet1 and planet2 are valid
    auto it1 = std::find(planets.begin(), planets.end(), planet1);
    auto it2 = std::find(planets.begin(), planets.end(), planet2);

    if(it1 == planets.end() || it2 == planets.end()) {
        return result; // return an empty vector
    }

    // Get the indices of planet1 and planet2
    int index1 = std::distance(planets.begin(), it1);
    int index2 = std::distance(planets.begin(), it2);

    // Ensure index1 is the smaller index
    if(index1 > index2) {
        std::swap(index1, index2);
    }

    // Add the planets between planet1 and planet2 to the result
    for(int i = index1 + 1; i < index2; i++) {
        result.push_back(planets[i]);
    }

    return result;"
1,0.0,HumanEval_148_bf,"

std::vector<std::string> bf(std::string planet1, std::string planet2) {
    std::vector<std::string> planets = {""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    std::vector<std::string> result;

    // Check if planet1 and planet2 are valid
    auto it1 = std::find(planets.begin(), planets.end(), planet1);
    auto it2 = std::find(planets.begin(), planets.end(), planet2);

    if(it1 == planets.end() || it2 == planets.end()) {
        return result;
    }

    // Find the index of planet1 and planet2
    int index1 = std::distance(planets.begin(), it1);
    int index2 = std::distance(planets.begin(), it2);

    // If index1 is greater than index2, swap them
    if(index1 > index2) {
        std::swap(index1, index2);
    }

    // Add all planets between planet1 and planet2 to the result
    for(int i = index1+1; i < index2; i++) {
        result.push_back(planets[i]);
    }

    return result;
"
0,1.0,HumanEval_148_bf,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

vector<string> bf(string planet1, string planet2) {
    vector<string> planets = {""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    vector<string> result;
    auto it1 = find(planets.begin(), planets.end(), planet1);
    auto it2 = find(planets.begin(), planets.end(), planet2);
    if (it1 == planets.end() || it2 == planets.end()) {
        return result;
    }
    if (it1 > it2) {
        swap(it1, it2);
    }
    result.insert(result.end(), it1+1, it2);
    return result;"
0,0.0,HumanEval_148_bf,"
    std::vector<std::string> planets = {""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    std::vector<std::string> result;

    // Check if planet1 and planet2 are valid planets
    auto it1 = std::find(planets.begin(), planets.end(), planet1);
    auto it2 = std::find(planets.begin(), planets.end(), planet2);
    if(it1 == planets.end() || it2 == planets.end()) {
        return result; // return empty vector
    }

    // Get the positions of planet1 and planet2 in the list
    int pos1 = it1 - planets.begin();
    int pos2 = it2 - planets.begin();

    // Check which planet is closer to the Sun
    if(pos1 < pos2) {
        // Planet1 is closer to the Sun, so we start from planet1 and go to planet2
        for(int i = pos1 + 1; i < pos2; i++) {
            result.push_back(planets[i]);
        }
    } else {
        // Planet2 is closer to the Sun, so we start from planet2 and go to planet1
        for(int i = pos2 + 1; i < pos1; i++) {
            result.push_back(planets[i]);
        }
    }

    return result;
"
0,1.0,HumanEval_131_digits,"

long digits(long n) {
    long product = 1;
    bool isOdd = false;

    while (n != 0) {
        long digit = n % 10;
        if (digit % 2 != 0) {
            product *= digit;
            isOdd = true;
        }
        n /= 10;
    }

    return isOdd ? product : 0;"
1,1.0,HumanEval_131_digits,"
long digits(long n) {
    long product = 1;
    bool isOddFound = false;
    while (n > 0) {
        int digit = n % 10;
        if (digit % 2 != 0) {
            product *= digit;
            isOddFound = true;
        }
        n /= 10;
    }
    return isOddFound ? product : 0;"
0,1.0,HumanEval_131_digits,"
long digits(long n) {
    long product = 1;
    while (n > 0) {
        int digit = n % 10;
        if (digit % 2 != 0) {
            product *= digit;
        }
        n /= 10;
    }
    return product;"
0,1.0,HumanEval_131_digits,"
long digits(long n) {
    long product = 1;
    bool isOdd = false;

    while (n > 0) {
        long digit = n % 10;
        if (digit % 2 != 0) {
            product *= digit;
            isOdd = true;
        }
        n /= 10;
    }

    return isOdd ? product : 0;"
0,0.0,HumanEval_131_digits,"
    long result = 1;
    bool isOdd = false;
    while (n > 0) {
        int digit = n % 10;
        if (digit % 2 != 0) {
            result *= digit;
            isOdd = true;
        }
        n /= 10;
    }
    return isOdd ? result : 0;"
0,1.0,HumanEval_131_digits,"
long digits(long n) {
    long product = 1;
    bool isOdd = false;
    while (n != 0) {
        int digit = n % 10;
        if (digit % 2 != 0) {
            product *= digit;
            isOdd = true;
        }
        n /= 10;
    }
    return isOdd ? product : 0;
"
1,1.0,HumanEval_131_digits,"
long digits(long n) {
    long product = 1;
    bool isOdd = false;
    while (n > 0) {
        int digit = n % 10;
        if (digit % 2 != 0) {
            product *= digit;
            isOdd = true;
        }
        n /= 10;
    }
    return isOdd ? product : 0;
"
0,1.0,HumanEval_131_digits,"
long digits(long n) {
    long product = 1;
    bool isOdd = false;
    while (n > 0) {
        long digit = n % 10;
        if (digit % 2 != 0) {
            product *= digit;
            isOdd = true;
        }
        n /= 10;
    }
    return isOdd ? product : 0;
"
1,1.0,HumanEval_131_digits,"
long digits(long n) {
    long product = 1;
    bool isOdd = false;
    while (n > 0) {
        int digit = n % 10;
        if (digit % 2 != 0) {
            product *= digit;
            isOdd = true;
        }
        n /= 10;
    }
    return isOdd ? product : 0;
"
1,1.0,HumanEval_131_digits,"
long digits(long n) {
    long product = 1;
    bool isOdd = false;
    
    while(n != 0) {
        int digit = n % 10;
        if(digit % 2 != 0) {
            product *= digit;
            isOdd = true;
        }
        n /= 10;
    }
    
    return isOdd ? product : 0;"
1,1.0,HumanEval_101_words_string,"
std::vector<std::string> words_string(std::string s) {
    std::vector<std::string> words;
    std::string word = """";
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == ',' || s[i] == ' ') {
            if (word != """") {
                words.push_back(word);
                word = """";
            }
        } else {
            word += s[i];
        }
    }
    if (word != """") {
        words.push_back(word);
    }
    return words;
"
1,1.0,HumanEval_101_words_string,"

std::vector<std::string> words_string(std::string s) {
    std::vector<std::string> words;
    std::string word = """";
    for (auto x : s) {
        if (x == ' ' || x == ',') {
            if (word != """") {
                words.push_back(word);
                word = """";
            }
        } else {
            word += x;
        }
    }
    if (word != """") {
        words.push_back(word);
    }
    return words;"
1,1.0,HumanEval_101_words_string,"

std::vector<std::string> words_string(std::string s) {
    std::vector<std::string> words;
    std::string word = """";
    for (auto x : s) {
        if (x == ' ' || x == ',') {
            if (word != """") {
                words.push_back(word);
                word = """";
            }
        } else {
            word += x;
        }
    }
    if (word != """") {
        words.push_back(word);
    }
    return words;"
0,1.0,HumanEval_101_words_string,"

std::vector<std::string> words_string(std::string s) {
    std::vector<std::string> words;
    std::string word = """";
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == ' ' || s[i] == ',') {
            if (word != """") {
                words.push_back(word);
                word = """";
            }
        } else {
            word += s[i];
        }
    }
    if (word != """") {
        words.push_back(word);
    }
    return words;"
0,1.0,HumanEval_101_words_string,"

std::vector<std::string> words_string(std::string s) {
    std::vector<std::string> words;
    std::string word;
    for (char c : s) {
        if (c == ',' || c == ' ') {
            if (!word.empty()) {
                words.push_back(word);
                word.clear();
            }
        } else {
            word += c;
        }
    }
    if (!word.empty()) {
        words.push_back(word);
    }
    return words;"
0,0.0,HumanEval_101_words_string,"
    std::vector<std::string> words;
    std::stringstream ss(s);
    std::string word;
    while (std::getline(ss, word, ',')) {
        while (std::getline(ss, word, ' ')) {
            if (!word.empty()) {
                words.push_back(word);
            }
        }
    }
    return words;"
0,1.0,HumanEval_101_words_string,"

std::vector<std::string> words_string(std::string s) {
    std::vector<std::string> words;
    std::string word = """";
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == ',' || s[i] == ' ') {
            if (word != """") {
                words.push_back(word);
                word = """";
            }
        } else {
            word += s[i];
        }
    }
    if (word != """") {
        words.push_back(word);
    }
    return words;
"
0,0.0,HumanEval_101_words_string,"
    std::vector<std::string> words;
    std::stringstream ss(s);
    std::string word;
    while (std::getline(ss, word, ',')) {
        words.push_back(word);
    }
    for (size_t i = 0; i < words.size(); i++) {
        std::string &str = words[i];
        str.erase(std::remove(str.begin(), str.end(), ' '), str.end());
    }
    return words;
"
1,1.0,HumanEval_101_words_string,"
std::vector<std::string> words_string(std::string s) {
    std::vector<std::string> words;
    std::string word;
    for (char c : s) {
        if (c == ' ' || c == ',') {
            if (!word.empty()) {
                words.push_back(word);
                word.clear();
            }
        } else {
            word += c;
        }
    }
    if (!word.empty()) {
        words.push_back(word);
    }
    return words;
"
0,0.0,HumanEval_101_words_string,"

std::vector<std::string> words_string(std::string s) {
    std::istringstream iss(s);
    std::vector<std::string> words;
    std::string word;
    while (std::getline(iss, word, ',')) {
        words.push_back(word);
    }
    return words;"
1,1.0,HumanEval_18_how_many_times,"
long how_many_times(std::string string, std::string substring) {
    long count = 0;
    size_t pos = 0;
    while ((pos = string.find(substring, pos)) != std::string::npos) {
        pos += 1;
        count++;
    }
    return count;"
0,1.0,HumanEval_18_how_many_times,"

long how_many_times(std::string string, std::string substring) {
    long count = 0;
    std::size_t found = string.find(substring);
    while (found != std::string::npos) {
        count++;
        found = string.find(substring, found+1);
    }
    return count;"
0,1.0,HumanEval_18_how_many_times,"
long how_many_times(std::string string, std::string substring) {
    long count = 0;
    std::size_t found = string.find(substring);
    while (found != std::string::npos) {
        count++;
        found = string.find(substring, found+1);
    }
    return count;
"
0,1.0,HumanEval_18_how_many_times,"

long how_many_times(std::string string, std::string substring) {
    long count = 0;
    size_t pos = 0;
    while ((pos = string.find(substring, pos)) != std::string::npos) {
        ++count;
        pos += substring.size();
    }
    return count;"
0,0.0,HumanEval_18_how_many_times,"
    long count = 0;
    std::size_t found = string.find(substring);
    while (found != std::string::npos) {
        count++;
        found = string.find(substring, found+1);
    }
    return count;"
1,1.0,HumanEval_18_how_many_times,"
long how_many_times(std::string string, std::string substring) {
    long count = 0;
    std::size_t found = string.find(substring);
    while (found != std::string::npos) {
        count++;
        found = string.find(substring, found+1);
    }
    return count;"
1,1.0,HumanEval_18_how_many_times,"
#include<assert.h>
#include<bits/stdc++.h>

long how_many_times(std::string str, std::string substring) {
    long count = 0;
    std::size_t found = str.find(substring);
    while (found != std::string::npos) {
        count++;
        found = str.find(substring, found+1);
    }
    return count;
"
1,1.0,HumanEval_18_how_many_times,"
long how_many_times(std::string string, std::string substring) {
    long count = 0;
    std::size_t found = string.find(substring);
    while (found != std::string::npos) {
        count++;
        found = string.find(substring, found+1);
    }
    return count;"
0,1.0,HumanEval_18_how_many_times,"
long how_many_times(std::string string, std::string substring) {
    long count = 0;
    size_t pos = 0;
    while ((pos = string.find(substring, pos)) != std::string::npos) {
        ++count;
        pos += substring.length();
    }
    return count;
"
1,1.0,HumanEval_18_how_many_times,"

long how_many_times(std::string string, std::string substring) {
    long count = 0;
    std::size_t found = string.find(substring);
    while (found != std::string::npos) {
        count++;
        found = string.find(substring, found+1);
    }
    return count;
"
0,0.0,HumanEval_137_compare_one,"
    if (a.f0 == b.f0) {
        return Union_long_float_std_string_std_nullopt(std::nullopt{});
    }
    else if (a.f1 == b.f1) {
        return Union_long_float_std_string_std_nullopt(std::nullopt{});
    }
    else if (a.f2 == b.f2) {
        return Union_long_float_std_string_std_nullopt(std::nullopt{});
    }
    else if (a.f0 > b.f0) {
        return Union_long_float_std_string_std_nullopt(a.f0);
    }
    else if (a.f1 > b.f1) {
        return Union_long_float_std_string_std_nullopt(a.f1);
    }
    else if (a.f2 > b.f2) {
        return Union_long_float_std_string_std_nullopt(a.f2);
    }
    else {
        return Union_long_float_std_string_std_nullopt(b.f0);
    }
"
0,0.0,HumanEval_137_compare_one,"
#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;
    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }
};

std::optional<Union_long_float_std_string> compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
    if (a.f0 == b.f0) {
        return std::nullopt;
    } else if (a.f1 == b.f1) {
        return Union_long_float_std_string(a.f1);
    } else if (a.f2 == b.f2) {
        return Union_long_float_std_string(a.f2);
    } else {
        return Union_long_float_std_string(a.f0 > b.f0 ? a.f0 : b.f0);
    }
"
0,0.0,HumanEval_137_compare_one,"
    if (a.f0 == b.f0) {
        return Union_long_float_std_string_std_nullopt(std::nullopt());
    } else if (a.f1 == b.f1) {
        return Union_long_float_std_string_std_nullopt(std::max(a.f1, b.f1));
    } else if (a.f2 == b.f2) {
        return Union_long_float_std_string_std_nullopt(std::max(std::stof(a.f2), std::stof(b.f2)));
    } else {
        return Union_long_float_std_string_std_nullopt(std::max(a.f0, b.f0));
    }"
0,0.0,HumanEval_137_compare_one,"
#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;

    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}

    bool operator==(long f) {
        return f0 == f ;
    }   
    bool operator==(float f) {
        return f1 == f ;
    }   
    bool operator==(std::string f) {
        return f2 == f ;
    }
};

std::optional<Union_long_float_std_string> compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
    if(a.f0 == b.f0) {
        return std::nullopt;
    } else if(a.f1 == b.f1) {
        return std::nullopt;
    } else if(a.f2 == b.f2) {
        return std::nullopt;
    } else if(a.f0 > b.f0) {
        return a;
    } else if(a.f1 > b.f1) {
        return a;
    } else if(a.f2 > b.f2) {
        return a;
    } else {
        return b;
    }"
0,0.0,HumanEval_137_compare_one,"
    if (a.f0 == b.f0) {
        return Union_long_float_std_string_std_nullopt(std::nullopt{});
    } else if (a.f1 == b.f1) {
        return Union_long_float_std_string_std_nullopt(std::max(a.f1, b.f1));
    } else if (a.f2 == b.f2) {
        std::replace(a.f2.begin(), a.f2.end(), ',', '.');
        std::replace(b.f2.begin(), b.f2.end(), ',', '.');
        float a_f1 = std::stof(a.f2);
        float b_f1 = std::stof(b.f2);
        if (a_f1 == b_f1) {
            return Union_long_float_std_string_std_nullopt(std::nullopt{});
        } else {
            return Union_long_float_std_string_std_nullopt(std::max(a_f1, b_f1));
        }
    } else {
        return Union_long_float_std_string_std_nullopt(std::max(a.f0, b.f0));
    }"
0,0.0,HumanEval_137_compare_one,"
Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
    if (a.f0 == b.f0) {
        return Union_long_float_std_string_std_nullopt(std::nullopt());
    }
    else if (a.f1 == b.f1) {
        return Union_long_float_std_string_std_nullopt(std::nullopt());
    }
    else if (a.f2 == b.f2) {
        return Union_long_float_std_string_std_nullopt(std::nullopt());
    }
    else {
        if (a.f0 > b.f0) {
            return Union_long_float_std_string_std_nullopt(a.f0);
        }
        else if (a.f1 > b.f1) {
            return Union_long_float_std_string_std_nullopt(a.f1);
        }
        else {
            return Union_long_float_std_string_std_nullopt(a.f2);
        }
    }"
0,0.0,HumanEval_137_compare_one,"
#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;
    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }
};

std::optional<Union_long_float_std_string> compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
    if (a.f0 == b.f0) {
        return std::nullopt;
    } else if (a.f1 == b.f1) {
        return std::nullopt;
    } else if (a.f2 == b.f2) {
        return std::nullopt;
    } else if (a.f0 > b.f0) {
        return a;
    } else if (a.f1 > b.f1) {
        return a;
    } else if (a.f2 > b.f2) {
        return a;
    } else {
        return b;
    }"
0,0.0,HumanEval_137_compare_one,"
    if (a.f0 > b.f0) {
        return Union_long_float_std_string_std_nullopt(a.f0);
    } else if (a.f1 > b.f1) {
        return Union_long_float_std_string_std_nullopt(a.f1);
    } else if (a.f2 > b.f2) {
        return Union_long_float_std_string_std_nullopt(a.f2);
    } else {
        return Union_long_float_std_string_std_nullopt(std::nullopt());
    }
"
0,0.0,HumanEval_137_compare_one,"
Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
    if (a == b) {
        return Union_long_float_std_string_std_nullopt(std::nullopt());
    }
    else if (a.f0 > b.f0) {
        return Union_long_float_std_string_std_nullopt(a.f0);
    }
    else if (a.f1 > b.f1) {
        return Union_long_float_std_string_std_nullopt(a.f1);
    }
    else if (a.f2 > b.f2) {
        return Union_long_float_std_string_std_nullopt(a.f2);
    }
    else {
        return Union_long_float_std_string_std_nullopt(b.f0);
    }"
0,0.0,HumanEval_137_compare_one,"
Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
    if (a.f0 > b.f0) {
        return Union_long_float_std_string_std_nullopt(a.f0);
    }
    else if (a.f1 > b.f1) {
        return Union_long_float_std_string_std_nullopt(a.f1);
    }
    else if (a.f2 > b.f2) {
        return Union_long_float_std_string_std_nullopt(a.f2);
    }
    else {
        return Union_long_float_std_string_std_nullopt(std::nullopt());
    }"
1,1.0,HumanEval_51_remove_vowels,"

std::string remove_vowels(std::string text) {
    std::string vowels = ""aeiouAEIOU"";
    std::string result;
    for (char& c : text) {
        if (vowels.find(c) == std::string::npos) {
            result += c;
        }
    }
    return result;
"
1,0.0,HumanEval_51_remove_vowels,"

std::string remove_vowels(std::string text) {
    std::string vowels = ""aeiouAEIOU"";
    for (int i = 0; i < vowels.length(); i++) {
        while (text.find(vowels[i]) != std::string::npos) {
            text.erase(text.find(vowels[i]), 1);
        }
    }
    return text;"
1,1.0,HumanEval_51_remove_vowels,"
std::string remove_vowels(std::string text) {
    std::string vowels = ""aeiouAEIOU"";
    std::string result = """";

    for(int i = 0; i < text.length(); i++) {
        if(vowels.find(text[i]) == std::string::npos) {
            result += text[i];
        }
    }

    return result;
"
1,1.0,HumanEval_51_remove_vowels,"

std::string remove_vowels(std::string text) {
    std::string vowels = ""aeiouAEIOU"";
    std::string result = """";
    for (char& c : text) {
        if (vowels.find(c) == std::string::npos) {
            result += c;
        }
    }
    return result;"
1,1.0,HumanEval_51_remove_vowels,"

std::string remove_vowels(std::string text) {
    std::string result;
    for(char& c : text) {
        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || 
           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {
            continue;
        }
        result += c;
    }
    return result;"
0,0.0,HumanEval_51_remove_vowels,"
    std::string vowels = ""aeiouAEIOU"";
    std::string result = """";
    for(int i = 0; i < text.length(); i++){
        if(vowels.find(text[i]) == std::string::npos){
            result += text[i];
        }
    }
    return result;
"
1,1.0,HumanEval_51_remove_vowels,"

std::string remove_vowels(std::string text) {
    std::string result = """";
    for(int i = 0; i < text.length(); i++) {
        char c = std::tolower(text[i]);
        if(c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {
            result += text[i];
        }
    }
    return result;"
1,1.0,HumanEval_51_remove_vowels,"
std::string remove_vowels(std::string text) {
    std::string vowels = ""aeiouAEIOU"";
    std::string result = """";
    for (char& c : text) {
        if (vowels.find(c) == std::string::npos) {
            result += c;
        }
    }
    return result;"
1,1.0,HumanEval_51_remove_vowels,"

std::string remove_vowels(std::string text) {
    std::string vowels = ""aeiouAEIOU"";
    std::string result = """";
    for(char& c : text) {
        if(vowels.find(c) == std::string::npos) {
            result += c;
        }
    }
    return result;
"
0,0.0,HumanEval_51_remove_vowels,"
    std::string vowels = ""aeiouAEIOU"";
    std::string result;
    for (char& c : text) {
        if (vowels.find(c) == std::string::npos) {
            result += c;
        }
    }
    return result;"
1,1.0,HumanEval_70_strange_sort_list,"
std::vector<long> strange_sort_list(std::vector<long> lst) {
    std::sort(lst.begin(), lst.end());
    std::vector<long> result;
    while(!lst.empty()) {
        result.push_back(lst.front());
        lst.erase(lst.begin());
        if(!lst.empty()) {
            result.push_back(lst.back());
            lst.pop_back();
        }
    }
    return result;
"
1,1.0,HumanEval_70_strange_sort_list,"

std::vector<long> strange_sort_list(std::vector<long> lst) {
    std::sort(lst.begin(), lst.end());
    std::vector<long> result;
    while(!lst.empty()) {
        result.push_back(lst.front());
        lst.erase(lst.begin());
        if (!lst.empty()) {
            result.push_back(lst.back());
            lst.pop_back();
        }
    }
    return result;
"
1,1.0,HumanEval_70_strange_sort_list,"

std::vector<long> strange_sort_list(std::vector<long> lst) {
    std::vector<long> result;
    if(lst.empty()) return result;

    std::sort(lst.begin(), lst.end());

    while(!lst.empty()) {
        result.push_back(lst.front());
        lst.erase(lst.begin());
        if(!lst.empty()) {
            result.push_back(lst.back());
            lst.pop_back();
        }
    }

    return result;"
1,1.0,HumanEval_70_strange_sort_list,"

std::vector<long> strange_sort_list(std::vector<long> lst) {
    std::vector<long> result;
    if(lst.empty()) return result;
    
    std::sort(lst.begin(), lst.end());

    while(!lst.empty()) {
        result.push_back(lst.front());
        lst.erase(lst.begin());
        if(!lst.empty()) {
            result.push_back(lst.back());
            lst.pop_back();
        }
    }

    return result;"
0,1.0,HumanEval_70_strange_sort_list,"

std::vector<long> strange_sort_list(std::vector<long> lst) {
    // Sort the vector in ascending order
    std::sort(lst.begin(), lst.end());

    // Create a vector to store the result
    std::vector<long> result;

    // While the vector is not empty
    while(!lst.empty()) {
        // Remove the last element and add it to the result
        result.push_back(lst.back());
        lst.pop_back();

        // If the vector is not empty, remove the first element and add it to the result
        if(!lst.empty()) {
            result.push_back(lst.front());
            lst.erase(lst.begin());
        }
    }

    return result;
"
1,1.0,HumanEval_70_strange_sort_list,"
std::vector<long> strange_sort_list(std::vector<long> lst) {
    if (lst.empty()) return lst;

    std::sort(lst.begin(), lst.end());
    std::vector<long> result;
    while (!lst.empty()) {
        result.push_back(lst.front());
        lst.erase(lst.begin());
        if (!lst.empty()) {
            result.push_back(lst.back());
            lst.pop_back();
        }
    }
    return result;
"
1,1.0,HumanEval_70_strange_sort_list,"

std::vector<long> strange_sort_list(std::vector<long> lst) {
    std::sort(lst.begin(), lst.end());
    std::vector<long> result;
    while (!lst.empty()) {
        result.push_back(lst.front());
        lst.erase(lst.begin());
        if (!lst.empty()) {
            result.push_back(lst.back());
            lst.pop_back();
        }
    }
    return result;
"
1,1.0,HumanEval_70_strange_sort_list,"

std::vector<long> strange_sort_list(std::vector<long> lst) {
    if (lst.empty()) {
        return lst;
    }

    std::sort(lst.begin(), lst.end());
    std::vector<long> result;
    while(!lst.empty()) {
        result.push_back(lst.front());
        lst.erase(lst.begin());
        if (!lst.empty()) {
            result.push_back(lst.back());
            lst.pop_back();
        }
    }
    return result;
"
1,1.0,HumanEval_70_strange_sort_list,"

std::vector<long> strange_sort_list(std::vector<long> lst) {
    std::vector<long> result;
    std::sort(lst.begin(), lst.end());

    while (!lst.empty()) {
        result.push_back(lst.front());
        lst.erase(lst.begin());
        if (!lst.empty()) {
            result.push_back(lst.back());
            lst.pop_back();
        }
    }

    return result;
"
1,1.0,HumanEval_70_strange_sort_list,"

std::vector<long> strange_sort_list(std::vector<long> lst) {
    std::sort(lst.begin(), lst.end());
    std::vector<long> result;
    while(!lst.empty()) {
        result.push_back(lst.front());
        lst.erase(lst.begin());
        if(!lst.empty()) {
            result.push_back(lst.back());
            lst.pop_back();
        }
    }
    return result;"
1,1.0,HumanEval_20_find_closest_elements,"
std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
    assert(numbers.size() >= 2);
    std::sort(numbers.begin(), numbers.end());
    float min_difference = std::numeric_limits<float>::max();
    float first_number = 0, second_number = 0;
    for (size_t i = 0; i < numbers.size() - 1; ++i) {
        float difference = numbers[i + 1] - numbers[i];
        if (difference < min_difference) {
            min_difference = difference;
            first_number = numbers[i];
            second_number = numbers[i + 1];
        }
    }
    return std::make_tuple(first_number, second_number);"
1,1.0,HumanEval_20_find_closest_elements,"

std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
    assert(numbers.size() >= 2);

    std::sort(numbers.begin(), numbers.end());

    float min_diff = std::numeric_limits<float>::max();
    std::tuple<float, float> result;

    for (size_t i = 0; i < numbers.size() - 1; ++i) {
        float diff = numbers[i+1] - numbers[i];
        if (diff < min_diff) {
            min_diff = diff;
            result = std::make_tuple(numbers[i], numbers[i+1]);
        }
    }

    return result;
"
1,1.0,HumanEval_20_find_closest_elements,"
std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
    assert(numbers.size() >= 2);

    std::sort(numbers.begin(), numbers.end());

    float min_diff = std::numeric_limits<float>::max();
    float min_pair_1, min_pair_2;

    for(size_t i = 0; i < numbers.size() - 1; ++i) {
        float diff = numbers[i+1] - numbers[i];
        if(diff < min_diff) {
            min_diff = diff;
            min_pair_1 = numbers[i];
            min_pair_2 = numbers[i+1];
        }
    }

    return std::make_tuple(min_pair_1, min_pair_2);"
1,1.0,HumanEval_20_find_closest_elements,"
std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
    assert(numbers.size() >= 2);
    std::sort(numbers.begin(), numbers.end());
    float min_diff = std::numeric_limits<float>::max();
    float min_pair[2];
    for (size_t i = 0; i < numbers.size() - 1; ++i) {
        float diff = numbers[i+1] - numbers[i];
        if (diff < min_diff) {
            min_diff = diff;
            min_pair[0] = numbers[i];
            min_pair[1] = numbers[i+1];
        }
    }
    return std::make_tuple(min_pair[0], min_pair[1]);
"
1,1.0,HumanEval_20_find_closest_elements,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

tuple<float, float> find_closest_elements(vector<float> numbers) {
    assert(numbers.size() >= 2);
    sort(numbers.begin(), numbers.end());
    float min_diff = FLT_MAX;
    float min_pair[2];
    for(size_t i = 0; i < numbers.size() - 1; ++i) {
        float diff = numbers[i+1] - numbers[i];
        if(diff < min_diff) {
            min_diff = diff;
            min_pair[0] = numbers[i];
            min_pair[1] = numbers[i+1];
        }
    }
    return make_tuple(min_pair[0], min_pair[1]);
"
0,0.0,HumanEval_20_find_closest_elements,"
    assert(numbers.size() >= 2);
    std::sort(numbers.begin(), numbers.end());
    float min_diff = std::numeric_limits<float>::max();
    float min_pair[2];
    for (size_t i = 0; i < numbers.size() - 1; ++i) {
        float diff = numbers[i+1] - numbers[i];
        if (diff < min_diff) {
            min_diff = diff;
            min_pair[0] = numbers[i];
            min_pair[1] = numbers[i+1];
        }
    }
    return std::make_tuple(min_pair[0], min_pair[1]);"
1,1.0,HumanEval_20_find_closest_elements,"

std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
    assert(numbers.size() >= 2);
    std::sort(numbers.begin(), numbers.end());
    float min_diff = std::numeric_limits<float>::max();
    float min_pair[2] = {0, 0};
    for(size_t i = 0; i < numbers.size() - 1; ++i) {
        float diff = numbers[i+1] - numbers[i];
        if(diff < min_diff) {
            min_diff = diff;
            min_pair[0] = numbers[i];
            min_pair[1] = numbers[i+1];
        }
    }
    return std::make_tuple(min_pair[0], min_pair[1]);"
1,1.0,HumanEval_20_find_closest_elements,"

std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
    assert(numbers.size() >= 2);

    std::sort(numbers.begin(), numbers.end());

    float min_diff = std::numeric_limits<float>::max();
    float min_pair[2];

    for (size_t i = 0; i < numbers.size() - 1; ++i) {
        float diff = numbers[i+1] - numbers[i];
        if (diff < min_diff) {
            min_diff = diff;
            min_pair[0] = numbers[i];
            min_pair[1] = numbers[i+1];
        }
    }

    return std::make_tuple(min_pair[0], min_pair[1]);"
1,1.0,HumanEval_20_find_closest_elements,"

std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
    assert(numbers.size() >= 2);

    std::sort(numbers.begin(), numbers.end());

    float min_diff = std::numeric_limits<float>::max();
    float min_pair[2];

    for (size_t i = 0; i < numbers.size() - 1; ++i) {
        float diff = numbers[i + 1] - numbers[i];
        if (diff < min_diff) {
            min_diff = diff;
            min_pair[0] = numbers[i];
            min_pair[1] = numbers[i + 1];
        }
    }

    return std::make_tuple(min_pair[0], min_pair[1]);
"
0,1.0,HumanEval_20_find_closest_elements,"
    std::sort(numbers.begin(), numbers.end());
    float min_diff = std::numeric_limits<float>::max();
    float closest_elements[2];
    for (size_t i = 0; i < numbers.size() - 1; ++i) {
        float diff = numbers[i+1] - numbers[i];
        if (diff < min_diff) {
            min_diff = diff;
            closest_elements[0] = numbers[i];
            closest_elements[1] = numbers[i+1];
        }
    }
    return std::make_tuple(closest_elements[0], closest_elements[1]);"
0,1.0,HumanEval_76_is_simple_power,"
bool is_simple_power(long x, long n) {
    if(x < 1 || n < 1) {
        return false;
    }
    while(x % n == 0) {
        x /= n;
    }
    return x == 1;
"
1,1.0,HumanEval_76_is_simple_power,"

bool is_simple_power(long x, long n) {
    if(x == 1)
        return true;
    if(n == 1)
        return false;
    while(x > 1){
        if(x % n != 0){
            return false;
        }
        x = x / n;
    }
    return true;"
1,1.0,HumanEval_76_is_simple_power,"

bool is_simple_power(long x, long n) {
    if(x == 1) return true; // 1 is a simple power of any number
    if(n == 1) return false; // 1 is not a simple power of any number except 1 itself
    if(n == 0) return false; // 0 is not a simple power of any number
    if(x == 0) return false; // 0 is not a simple power of any number
    while(x > 1) {
        if(x % n != 0) return false;
        x = x / n;
    }
    return x == 1;
"
1,0.0,HumanEval_76_is_simple_power,"

bool is_simple_power(long x, long n) {
    // Base case: if x is 1, then it is a simple power of any n
    if(x == 1) {
        return true;
    }

    // If n is 1, then x cannot be a simple power of any n (except 1)
    if(n == 1) {
        return false;
    }

    // If x is 0, then it is not a simple power of any n
    if(x == 0) {
        return false;
    }

    // Initialize result as 1
    long long result = 1;

    // Check all powers from 2 to sqrt(x)
    for(int i = 2; i <= sqrt(x); i++) {
        result = n;
        for(int j = 2; j <= i; j++) {
            result *= n;

            // If result becomes greater than x, then break the loop
            if(result > x) {
                break;
            }
        }

        // If result is equal to x, then return true
        if(result == x) {
            return true;
        }
    }

    // If we reach here, then x is not a simple power of n
    return false;
"
1,1.0,HumanEval_76_is_simple_power,"

bool is_simple_power(long x, long n) {
    if(x == 1) return true;
    if(n == 1) return false;

    while(x > 1) {
        if(x % n != 0) return false;
        x /= n;
    }

    return true;
"
0,1.0,HumanEval_76_is_simple_power,"

bool is_simple_power(long x, long n) {
    if(n == 1) {
        return (x != 1);
    }
    if(x == 1 || x == 0) {
        return true;
    }
    if(n == 0) {
        return (x == 1);
    }
    while(x % n == 0) {
        x /= n;
    }
    return (x == 1);"
1,1.0,HumanEval_76_is_simple_power,"
bool is_simple_power(long x, long n) {
    if (x == 1) {
        return true;
    }

    if (n == 1) {
        return (x > 1);
    }

    if (n == 0) {
        return (x == 0);
    }

    while (x % n == 0) {
        x /= n;
    }

    return (x == 1);"
0,0.0,HumanEval_76_is_simple_power,"
    assert(n > 0);
    while (x % n == 0) {
        x /= n;
    }
    return x == 1;
"
0,1.0,HumanEval_76_is_simple_power,"

bool is_simple_power(long x, long n) {
    if (x <= 0 || n <= 0) {
        return false;
    }
    while (x % n == 0) {
        x /= n;
    }
    return x == 1;"
1,1.0,HumanEval_76_is_simple_power,"
bool is_simple_power(long x, long n) {
    if (x == 1) {
        return true;
    }
    if (n == 1 || n == 0) {
        return false;
    }
    while (x % n == 0) {
        x /= n;
        if (x == 1) {
            return true;
        }
    }
    return false;"
0,1.0,HumanEval_39_prime_fib,"

long prime_fib(long n) {
    assert(n > 0);
    long a = 0, b = 1, c = 1;
    long count = 0;
    while (count < n) {
        if (is_prime(c)) {
            count++;
            if (count == n) return c;
        }
        a = b;
        b = c;
        c = a + b;
    }
    return -1; // should never reach here"
0,1.0,HumanEval_39_prime_fib,"

long prime_fib(long n) {
    assert(n > 0);
    long fib1 = 1, fib2 = 1, fib;
    long count = 1;
    while (count < n) {
        fib = fib1 + fib2;
        fib1 = fib2;
        fib2 = fib;
        if (isPrime(fib)) {
            count++;
        }
    }
    return fib1;"
0,0.0,HumanEval_39_prime_fib,"
long prime_fib(long n) {
    assert(n > 0);

    long i = 0, j = 1, k = 1;
    long count = 0;

    while (count < n) {
        if (is_prime(j)) {
            count++;
            if (count == n) {
                return j;
            }
        }
        i = j;
        j = k;
        k = i + j;
    }

    return -1;
}

bool is_prime(long x) {
    if (x < 2) return false;
    for (long i = 2; i * i <= x; i++) {
        if (x % i == 0) return false;
    }
    return true;"
0,1.0,HumanEval_39_prime_fib,"

long prime_fib(long n) {
    assert(n > 0);
    vector<long> fib_primes;
    long a = 0, b = 1;
    while (fib_primes.size() < n) {
        long c = a + b;
        a = b;
        b = c;
        if (is_prime(c))
            fib_primes.push_back(c);
    }
    return fib_primes.back();"
0,0.0,HumanEval_39_prime_fib,"
    assert(n > 0);
    std::vector<long> fibPrimes;
    long i = 1, j = 1;
    while(fibPrimes.size() < n) {
        if(isPrime(i) && isFib(j)) {
            fibPrimes.push_back(j);
        }
        i++;
        j = j+i-1;
    }
    return fibPrimes.back();
}

bool isPrime(long num) {
    if (num <= 1)  return false;
    if (num <= 3)  return true;
    if (num%2 == 0 || num%3 == 0) return false;
    for (long i=5; i*i<=num; i=i+6)
        if (num%i == 0 || num%(i+2) == 0)
           return false;
    return true;
}

bool isFib(long num) {
    long a = 0;
    long b = 1;
    if (num == a || num == b)
        return true;
    long c = a + b;
    while (c <= num) {
        if (c == num)
            return true;
        a = b;
        b = c;
        c = a + b;
    }
    return false;
"
0,1.0,HumanEval_39_prime_fib,"

long prime_fib(long n) {
    if (n < 1) {
        throw std::invalid_argument(""n should be greater than 0"");
    }
    long fib1 = 0, fib2 = 1, fib3 = 1;
    long count = 0;
    while(count < n) {
        if(isPrime(fib3)) {
            count++;
        }
        if(count == n) {
            return fib3;
        }
        fib1 = fib2;
        fib2 = fib3;
        fib3 = fib1 + fib2;
    }
    return -1;"
0,1.0,HumanEval_39_prime_fib,"

long prime_fib(long n) {
    long i = 1;
    long count = 0;
    while (count < n) {
        long f = fib(i);
        if (isPrime(f))
            count++;
        i++;
    }
    return fib(i - 1);
"
0,1.0,HumanEval_39_prime_fib,"

long prime_fib(long n) {
    assert(n > 0);
    long a = 0, b = 1, c = 1;
    long count = 0;
    while (count < n) {
        if (isPrime(c)) {
            count++;
            if (count == n) return c;
        }
        a = b;
        b = c;
        c = a + b;
    }
    return -1; // should never reach here"
0,0.0,HumanEval_39_prime_fib,"

long prime_fib(long n) {
    long i = 1;
    while (n > 0) {
        long fib = fibonacci(i);
        if (isPrime(fib)) {
            n--;
        }
        i++;
    }
    return fibonacci(i-1);"
0,1.0,HumanEval_39_prime_fib,"

long prime_fib(long n) {
    long fib1 = 0, fib2 = 1, fib3 = 1;
    long i = 2, count = 0;

    while(count < n){
        fib1 = fib2;
        fib2 = fib3;
        fib3 = fib1 + fib2;

        if(isPrime(fib2)){
            count++;
        }
        i++;
    }
    return fib2;"
0,0.0,HumanEval_145_order_by_points,"

std::vector<long> order_by_points(std::vector<long> nums) {
    std::map<long, int> mp;
    for(int i = 0; i < nums.size(); i++) {
        mp[nums[i]] = sumOfDigits(nums[i]);
    }
    std::vector<long> res;
    for(auto it = mp.begin(); it != mp.end(); it++) {
        res.push_back(it->first);
    }
    return res;"
0,0.0,HumanEval_145_order_by_points,"

std::vector<long> order_by_points(std::vector<long> nums) {
    std::vector<std::pair<long, int>> numsWithPoints;
    for(int i = 0; i < nums.size(); i++) {
        numsWithPoints.push_back(std::make_pair(nums[i], sumOfDigits(nums[i])));
    }
    std::sort(numsWithPoints.begin(), numsWithPoints.end(), [](const std::pair<long, int>& a, const std::pair<long, int>& b) {
        if(a.second == b.second) {
            return a.first < b.first;
        }
        return a.second < b.second;
    });
    std::vector<long> sortedNums;
    for(auto& num : numsWithPoints) {
        sortedNums.push_back(num.first);
    }
    return sortedNums;
"
0,0.0,HumanEval_145_order_by_points,"

std::vector<long> order_by_points(std::vector<long> nums) {
    std::vector<std::pair<long, int>> vec;
    for (int i = 0; i < nums.size(); i++) {
        vec.push_back(std::make_pair(nums[i], i));
    }
    std::sort(vec.begin(), vec.end(), comp);
    std::vector<long> res;
    for (int i = 0; i < vec.size(); i++) {
        res.push_back(vec[i].first);
    }
    return res;
"
0,0.0,HumanEval_145_order_by_points,"

std::vector<long> order_by_points(std::vector<long> nums) {
    std::map<int, std::vector<long>> m;
    for (size_t i = 0; i < nums.size(); ++i) {
        m[sum_of_digits(nums[i])].push_back(nums[i]);
    }
    nums.clear();
    for (auto it = m.begin(); it != m.end(); ++it) {
        std::sort(it->second.begin(), it->second.end());
        for (size_t i = 0; i < it->second.size(); ++i) {
            nums.push_back(it->second[i]);
        }
    }
    return nums;"
0,0.0,HumanEval_145_order_by_points,"
    std::sort(nums.begin(), nums.end(), [](long a, long b) {
        long sum_a = 0, sum_b = 0;
        long temp_a = a, temp_b = b;
        if (a < 0) temp_a = -a;
        if (b < 0) temp_b = -b;
        while (temp_a) {
            sum_a += temp_a % 10;
            temp_a /= 10;
        }
        while (temp_b) {
            sum_b += temp_b % 10;
            temp_b /= 10;
        }
        return (sum_a == sum_b) ? a < b : sum_a < sum_b;
    });
    return nums;"
0,0.0,HumanEval_145_order_by_points,"

std::vector<long> order_by_points(std::vector<long> nums) {
    std::map<long, int> sum_map;
    std::map<long, std::vector<long>> index_map;

    // Calculate sum of digits for each number and store it in sum_map
    for (int i = 0; i < nums.size(); i++) {
        long num = nums[i];
        long sum = 0;
        num = abs(num);  // Take absolute value to handle negative numbers
        while (num > 0) {
            sum += num % 10;
            num /= 10;
        }
        sum_map[nums[i]] = sum;

        // Store the index of each number in index_map
        if (index_map.find(sum) != index_map.end()) {
            index_map[sum].push_back(i);
        } else {
            index_map[sum] = std::vector<long>{i};
        }
    }

    // Sort the numbers based on their sum of digits
    std::vector<long> sorted_nums;
    for (auto it = index_map.begin(); it != index_map.end(); it++) {
        std::vector<long> indices = it->second;
        std::sort(indices.begin(), indices.end());
        for (long index : indices) {
            sorted_nums.push_back(nums[index]);
        }
    }

    return sorted_nums;"
0,0.0,HumanEval_145_order_by_points,"
std::vector<long> order_by_points(std::vector<long> nums) {
    // Create a vector of pairs to store the sum of digits and the original index
    std::vector<std::pair<int, int>> sums_and_indices;
    for(int i = 0; i < nums.size(); i++) {
        sums_and_indices.push_back({sum_of_digits(nums[i]), i});
    }

    // Sort the vector of pairs based on the sum of digits and the original index
    sort(sums_and_indices.begin(), sums_and_indices.end());

    // Reorder the original vector based on the sorted indices
    std::vector<long> result(nums.size());
    for(int i = 0; i < nums.size(); i++) {
        result[i] = nums[sums_and_indices[i].second];
    }

    return result;"
0,0.0,HumanEval_145_order_by_points,"
    // Helper function to calculate sum of digits
    auto sum_of_digits = [](long num) {
        num = std::abs(num);
        long sum = 0;
        while (num > 0) {
            sum += num % 10;
            num /= 10;
        }
        return sum;
    };

    // Sort the vector using a custom comparator
    std::sort(nums.begin(), nums.end(), [&](long a, long b) {
        long sum_a = sum_of_digits(a);
        long sum_b = sum_of_digits(b);
        // If sum of digits are same, order by index
        if (sum_a == sum_b) {
            return std::find(nums.begin(), nums.end(), a) < std::find(nums.begin(), nums.end(), b);
        }
        // Order by sum of digits
        return sum_a < sum_b;
    });

    return nums;
"
0,0.0,HumanEval_145_order_by_points,"
    std::sort(nums.begin(), nums.end(), [](long a, long b) {
        long sum_a = 0, sum_b = 0;
        long temp_a = a, temp_b = b;
        if (a < 0) temp_a = -a;
        if (b < 0) temp_b = -b;
        while (temp_a) {
            sum_a += temp_a % 10;
            temp_a /= 10;
        }
        while (temp_b) {
            sum_b += temp_b % 10;
            temp_b /= 10;
        }
        if (sum_a == sum_b) {
            return a < b;
        }
        return sum_a < sum_b;
    });
    return nums;
"
0,0.0,HumanEval_145_order_by_points,"
std::vector<long> order_by_points(std::vector<long> nums) {
    // Create a vector of pairs to hold the sum of digits and the index
    std::vector<std::pair<int, int>> sums(nums.size());
    for(int i = 0; i < nums.size(); i++) {
        sums[i] = {sum_of_digits(nums[i]), i};
    }

    // Sort the vector of pairs
    std::sort(sums.begin(), sums.end());

    // Create a new vector to hold the sorted numbers
    std::vector<long> sorted_nums(nums.size());
    for(int i = 0; i < nums.size(); i++) {
        sorted_nums[i] = nums[sums[i].second];
    }

    return sorted_nums;
"
1,1.0,HumanEval_0_has_close_elements,"

bool has_close_elements(std::vector<float> numbers, float threshold) {
    std::sort(numbers.begin(), numbers.end());
    for (size_t i = 0; i < numbers.size() - 1; i++) {
        if (numbers[i+1] - numbers[i] <= threshold) {
            return true;
        }
    }
    return false;"
1,1.0,HumanEval_0_has_close_elements,"
bool has_close_elements(std::vector<float> numbers, float threshold) {
    assert(threshold >= 0); // ensure threshold is non-negative
    std::sort(numbers.begin(), numbers.end()); // sort the numbers
    for (size_t i = 1; i < numbers.size(); i++) {
        if (numbers[i] - numbers[i - 1] < threshold) {
            return true; // found two close elements
        }
    }
    return false; // no close elements found"
1,1.0,HumanEval_0_has_close_elements,"
bool has_close_elements(std::vector<float> numbers, float threshold) {
    // Sort the vector in ascending order
    std::sort(numbers.begin(), numbers.end());

    // Iterate over the vector
    for (size_t i = 0; i < numbers.size() - 1; i++) {
        // If the difference between the current number and the next number is less than the threshold, return true
        if (numbers[i + 1] - numbers[i] < threshold) {
            return true;
        }
    }

    // If no pair of numbers is found that are closer than the threshold, return false
    return false;
"
1,1.0,HumanEval_0_has_close_elements,"
bool has_close_elements(std::vector<float> numbers, float threshold) {
    // Sort the vector in ascending order
    std::sort(numbers.begin(), numbers.end());

    // Iterate over the vector
    for (size_t i = 0; i < numbers.size() - 1; i++) {
        // If the difference between the current number and the next number is less than the threshold, return true
        if (numbers[i+1] - numbers[i] < threshold) {
            return true;
        }
    }

    // If no pair of numbers was found that were closer than the threshold, return false
    return false;
"
1,1.0,HumanEval_0_has_close_elements,"
bool has_close_elements(std::vector<float> numbers, float threshold) {
    // Sort the vector
    std::sort(numbers.begin(), numbers.end());

    // Iterate through the vector
    for (size_t i = 0; i < numbers.size() - 1; ++i) {
        // If the difference between the current number and the next number is less than the threshold, return true
        if (numbers[i + 1] - numbers[i] < threshold) {
            return true;
        }
    }

    // If no pair of numbers was found closer than the threshold, return false
    return false;"
1,1.0,HumanEval_0_has_close_elements,"
bool has_close_elements(std::vector<float> numbers, float threshold) {
    // Sort the vector
    std::sort(numbers.begin(), numbers.end());

    // Iterate over the sorted vector
    for (size_t i = 1; i < numbers.size(); i++) {
        // If the difference between the current number and the previous number
        // is less than the threshold, return true
        if (numbers[i] - numbers[i - 1] < threshold) {
            return true;
        }
    }

    // If no two numbers were closer than the threshold, return false
    return false;"
1,1.0,HumanEval_0_has_close_elements,"
bool has_close_elements(std::vector<float> numbers, float threshold) {
    sort(numbers.begin(), numbers.end());
    for (size_t i = 0; i < numbers.size() - 1; i++) {
        if (numbers[i+1] - numbers[i] < threshold) {
            return true;
        }
    }
    return false;
"
1,1.0,HumanEval_0_has_close_elements,"
bool has_close_elements(std::vector<float> numbers, float threshold) {
    std::sort(numbers.begin(), numbers.end());
    for (size_t i = 0; i < numbers.size() - 1; ++i) {
        if (numbers[i + 1] - numbers[i] < threshold) {
            return true;
        }
    }
    return false;
"
1,1.0,HumanEval_0_has_close_elements,"
bool has_close_elements(std::vector<float> numbers, float threshold) {
    // Sort the vector
    std::sort(numbers.begin(), numbers.end());

    // Iterate over the vector
    for (size_t i = 0; i < numbers.size() - 1; ++i) {
        // Check if the difference between current number and next number is less than threshold
        if (numbers[i + 1] - numbers[i] < threshold) {
            return true;
        }
    }

    // If no pair of numbers found, return false
    return false;
"
1,1.0,HumanEval_0_has_close_elements,"

bool has_close_elements(std::vector<float> numbers, float threshold) {
    std::sort(numbers.begin(), numbers.end());
    for (size_t i = 0; i < numbers.size() - 1; ++i) {
        if (numbers[i+1] - numbers[i] <= threshold) {
            return true;
        }
    }
    return false;"
0,0.0,HumanEval_10_make_palindrome,"
    int len = string.size();
    int i = 0;
    for (i = len; i >= 0; i--) {
        if (string.substr(0, i) == string.substr(0, i) && string.substr(0, i) == string.substr(len - i, i)) {
            break;
        }
    }
    std::string suffix = string.substr(i);
    std::reverse(suffix.begin(), suffix.end());
    string += suffix;
    return string;"
0,0.0,HumanEval_10_make_palindrome,"
std::string make_palindrome(std::string string) {
    int len = string.size();
    int i = 0;
    for (i = len; i >= 0; i--) {
        if (string.substr(0, i) == string.substr(len - i, i))
            break;
    }
    if (i == len)
        return string;
    else {
        std::string postfix = string.substr(i, len - i);
        std::reverse(postfix.begin(), postfix.end());
        return string + postfix;
    }"
0,0.0,HumanEval_10_make_palindrome,"
    // Find the longest postfix of the string that is a palindrome.
    int len = string.length();
    int longestPalindromeEnd = 0;
    for (int i = 0; i < len; i++) {
        std::string subString = string.substr(0, i+1);
        if (subString == std::string(subString.rbegin(), subString.rend())) {
            longestPalindromeEnd = i;
        }
    }

    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    std::string prefixToReverse = string.substr(0, longestPalindromeEnd);
    std::string suffixToAppend(prefixToReverse.rbegin(), prefixToReverse.rend());
    return string + suffixToAppend;
"
0,0.0,HumanEval_10_make_palindrome,"
std::string make_palindrome(std::string str) {
    int len = str.size();
    int i = 0;
    for (i = len; i >= 0; i--) {
        if (strncmp(str.c_str(), str.substr(0, i).c_str(), i) == 0) {
            break;
        }
    }
    if (i == len) {
        return str;
    }
    std::string suffix = str.substr(i, len - i);
    std::string prefix = str.substr(0, i);
    std::string palindrome = str + std::string(suffix.rbegin(), suffix.rend());
    return palindrome;"
0,0.0,HumanEval_10_make_palindrome,"
std::string make_palindrome(std::string s) {
    int n = s.size();
    int i = 0;
    for (i = n; i >= 0; i--) {
        if (s.substr(0, i) == std::string(s.substr(0, i).rbegin(), s.substr(0, i).rend())) {
            break;
        }
    }

    if (i == n) {
        return s;
    }

    std::string postfix = s.substr(i, n - i);
    std::string prefix = s.substr(0, i);
    std::string not_palindrome = s.substr(i, n - i);
    std::string reverse_prefix(prefix.rbegin(), prefix.rend());

    return s + reverse_prefix;"
0,0.0,HumanEval_10_make_palindrome,"
std::string make_palindrome(std::string string) {
    int len = string.size();
    int i = 0;

    // Find the longest postfix of the string that is a palindrome
    for (int j = len - 1; j >= 0; j--) {
        if (string[i] == string[j]) {
            i++;
        }
    }

    // If the entire string is a palindrome, return the string itself
    if (i == len) {
        return string;
    }

    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix
    std::string suffix = string.substr(i);
    std::string prefix = string.substr(0, i);
    std::string non_palindrome = string.substr(i);
    std::reverse(non_palindrome.begin(), non_palindrome.end());
    return string + non_palindrome;"
0,0.0,HumanEval_10_make_palindrome,"
    // Get the length of the string
    int n = string.length();

    // If the string is empty or consists of one character, return the string itself
    if(n <= 1) return string;

    // Create a reversed copy of the string
    std::string rev = string;
    reverse(rev.begin(), rev.end());

    // Create a string that concatenates the original string and its reversed copy
    std::string combined = string + ""#"" + rev;

    // Create a vector to store the lps array
    std::vector<int> lps(n+n+2, 0);

    // Compute the lps array
    int len = 0;
    int i = 1;
    while(i < combined.length()) {
        if(combined[i] == combined[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if(len != 0) len = lps[len-1];
            else {
                lps[i] = 0;
                i++;
            }
        }
    }

    // Compute the minimum number of characters to be appended at the end
    int extra = n - lps[2*n];

    // Append the reversed part of the original string to the end
    for(int i=0; i<extra; i++) {
        string += rev[i];
    }

    return string;
"
0,0.0,HumanEval_10_make_palindrome,"
std::string make_palindrome(std::string string) {
    int len = string.size();
    int i;
    for (i = 0; i < len; ++i) {
        if (string == std::string(string.rbegin(), string.rend())) {
            return string;
        }
        string.pop_back();
    }
    std::string suffix(string.rbegin(), string.rbegin() + i);
    std::string prefix(string.begin(), string.end());
    std::string non_palindromic_part(prefix.rbegin(), prefix.rend());
    std::string result = string + non_palindromic_part;
    return result;"
0,1.0,HumanEval_10_make_palindrome,"
#include<assert.h>
#include<bits/stdc++.h>

std::string make_palindrome(std::string str) {
    int n = str.size();
    int i = 0;
    for (i = n; i >= 0; i--) {
        if (str.substr(0, i) == std::string(str.substr(0, i).rbegin(), str.substr(0, i).rend())) {
            break;
        }
    }
    std::string suffix = str.substr(i, n - i);
    std::string prefix = str.substr(0, i);
    std::string non_palindrome_part = str.substr(i, n - i);
    std::reverse(non_palindrome_part.begin(), non_palindrome_part.end());
    return str + std::string(non_palindrome_part.rbegin(), non_palindrome_part.rend());"
0,0.0,HumanEval_10_make_palindrome,"
    // Get the length of the string
    int n = string.length();

    // If the string is empty or already a palindrome, return the string as is
    if (n == 0 || string == stringrev(string)) {
        return string;
    }

    // Initialize the longest palindromic postfix
    int longest_palindromic_postfix = 0;

    // Compute the longest palindromic postfix
    for (int i = 0; i < n; i++) {
        std::string suffix = string.substr(i, n);
        if (is_palindrome(suffix)) {
            longest_palindromic_postfix = i;
            break;
        }
    }

    // Get the prefix before the longest palindromic postfix
    std::string prefix = string.substr(0, longest_palindromic_postfix);

    // Get the remaining part of the string
    std::string remaining = string.substr(longest_palindromic_postfix, n);

    // Reverse the prefix and append it to the remaining part
    std::string result = remaining + stringrev(prefix);

    return result;
}

// Helper function to check if a string is a palindrome
bool is_palindrome(std::string string) {
    int n = string.length();
    for (int i = 0; i < n / 2; i++) {
        if (string[i] != string[n - i - 1]) {
            return false;
        }
    }
    return true;
}

// Helper function to reverse a string
std::string stringrev(std::string string) {
    int n = string.length();
    std::string reversed_string = """";
    for (int i = n - 1; i >= 0; i--) {
        reversed_string += string[i];
    }
    return reversed_string;
"
1,1.0,HumanEval_11_string_xor,"

std::string string_xor(std::string a, std::string b) {
    assert(a.size() == b.size());

    std::string result = """";

    for(int i = 0; i < a.size(); i++) {
        result += (a[i] == b[i]) ? '0' : '1';
    }

    return result;"
1,1.0,HumanEval_11_string_xor,"

std::string string_xor(std::string a, std::string b) {
    assert(a.size() == b.size());
    std::string result = """";
    for(size_t i = 0; i < a.size(); ++i) {
        result += (a[i] == b[i]) ? '0' : '1';
    }
    return result;
"
1,1.0,HumanEval_11_string_xor,"

std::string string_xor(std::string a, std::string b) {
    assert(a.size() == b.size());

    std::string result = """";
    for (size_t i = 0; i < a.size(); i++) {
        result += (a[i] == b[i]) ? '0' : '1';
    }
    return result;
"
1,1.0,HumanEval_11_string_xor,"

std::string string_xor(std::string a, std::string b) {
    assert(a.size() == b.size());
    std::string result = """";
    for (int i = 0; i < a.size(); i++) {
        result += (a[i] == b[i]) ? '0' : '1';
    }
    return result;
"
1,1.0,HumanEval_11_string_xor,"
std::string string_xor(std::string a, std::string b) {
    assert(a.size() == b.size());

    std::string result = """";
    for(int i = 0; i < a.size(); i++) {
        if(a[i] == b[i]) {
            result += '0';
        } else {
            result += '1';
        }
    }
    return result;
"
1,1.0,HumanEval_11_string_xor,"

std::string string_xor(std::string a, std::string b) {
    assert(a.size() == b.size());

    std::string result = """";

    for(int i = 0; i < a.size(); i++) {
        result += (a[i] == b[i]) ? '0' : '1';
    }

    return result;"
0,0.0,HumanEval_11_string_xor,"
    assert(a.size() == b.size());
    std::string result = """";
    for(int i = 0; i < a.size(); i++) {
        result += (a[i] == b[i]) ? '0' : '1';
    }
    return result;"
1,1.0,HumanEval_11_string_xor,"
std::string string_xor(std::string a, std::string b) {
    assert(a.size() == b.size());

    std::string result = """";
    for(int i = 0; i < a.size(); i++) {
        if(a[i] == b[i])
            result += '0';
        else
            result += '1';
    }

    return result;"
1,1.0,HumanEval_11_string_xor,"
std::string string_xor(std::string a, std::string b) {
    assert(a.size() == b.size());

    std::string result = """";
    for(int i = 0; i < a.size(); ++i) {
        if(a[i] == b[i]) {
            result += '0';
        } else {
            result += '1';
        }
    }
    return result;"
1,1.0,HumanEval_11_string_xor,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

string string_xor(string a, string b) {
    assert(a.size() == b.size());

    string result = """";
    for (int i = 0; i < a.size(); i++) {
        result += ((a[i] == b[i]) ? '0' : '1');
    }
    return result;
"
0,1.0,HumanEval_139_special_factorial,"

long special_factorial(long n) {
    assert(n > 0);
    long result = 1;
    for(long i = n; i >= 1; i--) {
        result *= factorial(i);
    }
    return result;
"
1,1.0,HumanEval_139_special_factorial,"
long special_factorial(long n) {
    long result = 1;
    for(long i = n; i > 0; i--) {
        long fact = 1;
        for(long j = i; j > 0; j--) {
            fact *= j;
        }
        result *= fact;
    }
    return result;"
0,1.0,HumanEval_139_special_factorial,"

long special_factorial(long n) {
    assert(n > 0);
    long result = 1;
    for(long i = 1; i <= n; i++) {
        result *= factorial(n - i + 1);
    }
    return result;
"
0,0.0,HumanEval_139_special_factorial,"

long special_factorial(long n) {
    long result = 1;
    for (long i = n; i > 0; i--) {
        result *= factorial(i);
    }
    return result;"
1,0.0,HumanEval_139_special_factorial,"
long special_factorial(long n) {
    long result = 1;
    for(long i = n; i > 0; i--) {
        long factorial = 1;
        for(long j = 1; j <= i; j++) {
            factorial *= j;
        }
        result *= factorial;
    }
    return result;
"
0,1.0,HumanEval_139_special_factorial,"

long special_factorial(long n) {
    assert(n > 0);
    long result = 1;
    for(long i = n; i > 0; i--) {
        result *= factorial(i);
    }
    return result;"
0,0.0,HumanEval_139_special_factorial,"
    assert(n > 0);
    long result = 1;
    for(long i = n; i > 0; i--) {
        long factorial = 1;
        for(long j = i; j > 0; j--) {
            factorial *= j;
        }
        result *= factorial;
    }
    return result;
"
0,1.0,HumanEval_139_special_factorial,"

long special_factorial(long n) {
    long result = 1;
    for(long i = n; i > 0; i--) {
        result *= factorial(i);
    }
    return result;"
0,1.0,HumanEval_139_special_factorial,"

long special_factorial(long n) {
    assert(n > 0);
    long result = 1;
    for (long i = n; i > 0; i--) {
        result *= factorial(i);
    }
    return result;"
0,1.0,HumanEval_139_special_factorial,"

long special_factorial(long n) {
    assert(n > 0);
    long result = 1;
    for(long i = n; i >= 1; i--) {
        result *= factorial(i);
    }
    return result;
"
0,0.0,HumanEval_122_add_elements,"
long add_elements(std::vector<long> arr, long k) {
    long sum = 0;
    for (long i = 0; i < k; i++) {
        if (arr[i] >= 0 && arr[i] <= 99) {
            sum += arr[i];
        }
    }
    return sum;
"
0,1.0,HumanEval_122_add_elements,"

long add_elements(std::vector<long> arr, long k) {
    assert(1 <= arr.size() && arr.size() <= 100);
    assert(1 <= k && k <= arr.size());

    long sum = 0;
    for(long i = 0; i < k; i++) {
        if(arr[i] >= 0 && arr[i] <= 99) {
            sum += arr[i];
        }
    }

    return sum;"
0,0.0,HumanEval_122_add_elements,"
    assert(1 <= arr.size() && arr.size() <= 100);
    assert(1 <= k && k <= arr.size());

    long sum = 0;
    for (long i = 0; i < k; i++) {
        if (arr[i] >= 0 && arr[i] <= 99) {
            sum += arr[i];
        }
    }
    return sum;"
1,1.0,HumanEval_122_add_elements,"
long add_elements(std::vector<long> arr, long k) {
    long sum = 0;
    for (long i = 0; i < k; i++) {
        if (std::to_string(arr[i]).length() <= 2) {
            sum += arr[i];
        }
    }
    return sum;
"
0,0.0,HumanEval_122_add_elements,"
    long sum = 0;
    for(long i = 0; i < k; i++) {
        if(arr[i] >= 0 && arr[i] <= 99) {
            sum += arr[i];
        }
    }
    return sum;"
0,0.0,HumanEval_122_add_elements,"
long add_elements(std::vector<long> arr, long k) {
    long sum = 0;
    for (long i = 0; i < k; i++) {
        if (arr[i] >= 10 && arr[i] <= 99) {
            sum += arr[i];
        }
    }
    return sum;"
0,1.0,HumanEval_122_add_elements,"

long add_elements(std::vector<long> arr, long k) {
    long sum = 0;
    for(long i = 0; i < k; i++) {
        if(arr[i] >= 0 && arr[i] <= 99) {
            sum += arr[i];
        }
    }
    return sum;"
0,1.0,HumanEval_122_add_elements,"

long add_elements(std::vector<long> arr, long k) {
    assert(1 <= arr.size() && arr.size() <= 100);
    assert(1 <= k && k <= arr.size());
    
    long sum = 0;
    for (long i = 0; i < k; i++) {
        if (arr[i] >= 0 && arr[i] <= 99) {
            sum += arr[i];
        }
    }
    return sum;"
0,0.0,HumanEval_122_add_elements,"
long add_elements(std::vector<long> arr, long k) {
    assert(1 <= arr.size() && arr.size() <= 100);
    assert(1 <= k && k <= arr.size());

    long sum = 0;
    for (long i = 0; i < k; i++) {
        if (arr[i] >= 0 && arr[i] <= 99) {
            sum += arr[i];
        }
    }

    return sum;"
0,0.0,HumanEval_122_add_elements,"
long add_elements(std::vector<long> arr, long k) {
    assert(1 <= arr.size() && arr.size() <= 100);
    assert(1 <= k && k <= arr.size());

    long sum = 0;

    for (long i = 0; i < k; i++) {
        if (arr[i] >= 0 && arr[i] <= 99) {
            sum += arr[i];
        }
    }

    return sum;"
1,1.0,HumanEval_46_fib4,"
long fib4(long n) {
    if(n == 0 || n == 1) {
        return 0;
    }
    if(n == 2) {
        return 2;
    }
    if(n == 3) {
        return 0;
    }

    long fib[4] = {0, 0, 2, 0};
    for(long i = 4; i <= n; i++) {
        long temp = fib[3] + fib[2] + fib[1] + fib[0];
        for(long j = 0; j < 3; j++) {
            fib[j] = fib[j+1];
        }
        fib[3] = temp;
    }
    return fib[3];
"
1,1.0,HumanEval_46_fib4,"
long fib4(long n) {
    if (n == 0) return 0;
    if (n == 1) return 0;
    if (n == 2) return 2;
    if (n == 3) return 0;

    std::vector<long> fib = {0, 0, 2, 0};

    for (long i = 4; i <= n; i++) {
        fib.push_back(fib[i-1] + fib[i-2] + fib[i-3] + fib[i-4]);
    }

    return fib[n];"
1,1.0,HumanEval_46_fib4,"
long fib4(long n) {
    if (n < 2) {
        return 0;
    }
    if (n == 2) {
        return 2;
    }
    if (n == 3) {
        return 0;
    }

    long a = 0, b = 0, c = 2, d = 0;
    long result = 0;

    for (long i = 4; i <= n; i++) {
        result = a + b + c + d;
        a = b;
        b = c;
        c = d;
        d = result;
    }

    return result;
"
0,1.0,HumanEval_46_fib4,"

long fib4(long n) {
    assert(n >= 0);

    if (n == 0 || n == 1) {
        return 0;
    }
    if (n == 2) {
        return 2;
    }
    if (n == 3) {
        return 0;
    }

    vector<long> fib = {0, 0, 2, 0};
    for (long i = 4; i <= n; i++) {
        fib.push_back(fib[i-1] + fib[i-2] + fib[i-3] + fib[i-4]);
    }

    return fib[n];
"
1,1.0,HumanEval_46_fib4,"

long fib4(long n) {
    if (n == 0) return 0;
    if (n == 1) return 0;
    if (n == 2) return 2;
    if (n == 3) return 0;

    long fibs[4] = {0, 0, 2, 0};
    for (long i = 4; i <= n; i++) {
        long next = fibs[0] + fibs[1] + fibs[2] + fibs[3];
        for (long j = 0; j < 3; j++) {
            fibs[j] = fibs[j + 1];
        }
        fibs[3] = next;
    }
    return fibs[3];
"
1,1.0,HumanEval_46_fib4,"
long fib4(long n) {
    if(n == 0) return 0;
    if(n == 1) return 0;
    if(n == 2) return 2;
    if(n == 3) return 0;

    long a = 0, b = 0, c = 2, d = 0;
    long result = 0;

    for(long i = 4; i <= n; i++) {
        result = a + b + c + d;
        a = b;
        b = c;
        c = d;
        d = result;
    }

    return result;
"
1,1.0,HumanEval_46_fib4,"
long fib4(long n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 0;
    }
    if (n == 2) {
        return 2;
    }
    if (n == 3) {
        return 0;
    }

    long a = 0;
    long b = 0;
    long c = 2;
    long d = 0;
    long result = 0;

    for (long i = 4; i <= n; i++) {
        result = a + b + c + d;
        a = b;
        b = c;
        c = d;
        d = result;
    }

    return result;"
1,1.0,HumanEval_46_fib4,"
long fib4(long n) {
    if (n == 0 || n == 1) {
        return 0;
    }
    else if (n == 2) {
        return 2;
    }
    else if (n == 3) {
        return 0;
    }

    long fib[4] = {0, 0, 2, 0};
    for (long i = 4; i <= n; i++) {
        long next = fib[3] + fib[2] + fib[1] + fib[0];
        for (long j = 0; j < 3; j++) {
            fib[j] = fib[j+1];
        }
        fib[3] = next;
    }

    return fib[3];
"
1,1.0,HumanEval_46_fib4,"
long fib4(long n) {
    if(n == 0) return 0;
    if(n == 1) return 0;
    if(n == 2) return 2;
    if(n == 3) return 0;

    long fib[n+1];
    fib[0] = 0;
    fib[1] = 0;
    fib[2] = 2;
    fib[3] = 0;

    for(long i = 4; i <= n; i++) {
        fib[i] = fib[i-1] + fib[i-2] + fib[i-3] + fib[i-4];
    }

    return fib[n];"
1,1.0,HumanEval_46_fib4,"

long fib4(long n) {
    if (n == 0) return 0;
    if (n == 1) return 0;
    if (n == 2) return 2;
    if (n == 3) return 0;

    std::vector<long> fib_values(n+1, 0);
    fib_values[0] = 0;
    fib_values[1] = 0;
    fib_values[2] = 2;
    fib_values[3] = 0;

    for(long i = 4; i <= n; ++i) {
        fib_values[i] = fib_values[i-1] + fib_values[i-2] + fib_values[i-3] + fib_values[i-4];
    }

    return fib_values[n];
"
1,1.0,HumanEval_104_unique_digits,"

std::vector<long> unique_digits(std::vector<long> x) {
    std::vector<long> result;
    for (long num : x) {
        std::string strNum = std::to_string(num);
        bool hasEvenDigit = false;
        for (char c : strNum) {
            int digit = c - '0';
            if (digit % 2 == 0) {
                hasEvenDigit = true;
                break;
            }
        }
        if (!hasEvenDigit) {
            result.push_back(num);
        }
    }
    std::sort(result.begin(), result.end());
    return result;"
1,1.0,HumanEval_104_unique_digits,"

std::vector<long> unique_digits(std::vector<long> x) {
    std::vector<long> result;
    for(long num : x) {
        std::string num_str = std::to_string(num);
        bool has_even_digit = false;
        for(char digit : num_str) {
            if((digit - '0') % 2 == 0) {
                has_even_digit = true;
                break;
            }
        }
        if(!has_even_digit) {
            result.push_back(num);
        }
    }
    std::sort(result.begin(), result.end());
    return result;"
1,1.0,HumanEval_104_unique_digits,"
std::vector<long> unique_digits(std::vector<long> x) {
    std::vector<long> result;
    for (long num : x) {
        std::string num_str = std::to_string(num);
        bool has_even_digit = false;
        for (char digit : num_str) {
            if ((digit - '0') % 2 == 0) {
                has_even_digit = true;
                break;
            }
        }
        if (!has_even_digit) {
            result.push_back(num);
        }
    }
    std::sort(result.begin(), result.end());
    return result;
"
0,1.0,HumanEval_104_unique_digits,"
std::vector<long> unique_digits(std::vector<long> x) {
    std::vector<long> result;
    for (long num : x) {
        bool hasEvenDigit = false;
        while (num > 0) {
            if ((num % 10) % 2 == 0) {
                hasEvenDigit = true;
                break;
            }
            num /= 10;
        }
        if (!hasEvenDigit) {
            result.push_back(num);
        }
    }
    sort(result.begin(), result.end());
    return result;
"
0,0.0,HumanEval_104_unique_digits,"
    std::vector<long> result;
    for(auto num : x) {
        std::string num_str = std::to_string(num);
        bool has_even_digit = false;
        for(auto digit : num_str) {
            if((digit - '0') % 2 == 0) {
                has_even_digit = true;
                break;
            }
        }
        if(!has_even_digit)
            result.push_back(num);
    }
    std::sort(result.begin(), result.end());
    return result;"
1,1.0,HumanEval_104_unique_digits,"
std::vector<long> unique_digits(std::vector<long> x) {
    std::vector<long> result;
    for (long num : x) {
        std::string num_str = std::to_string(num);
        bool has_even_digit = false;
        for (char c : num_str) {
            int digit = c - '0';
            if (digit % 2 == 0) {
                has_even_digit = true;
                break;
            }
        }
        if (!has_even_digit) {
            result.push_back(num);
        }
    }
    std::sort(result.begin(), result.end());
    return result;
"
1,1.0,HumanEval_104_unique_digits,"
std::vector<long> unique_digits(std::vector<long> x) {
    std::vector<long> result;
    for (long num : x) {
        std::string str_num = std::to_string(num);
        bool has_even_digit = false;
        for (char digit : str_num) {
            if ((digit - '0') % 2 == 0) {
                has_even_digit = true;
                break;
            }
        }
        if (!has_even_digit) {
            result.push_back(num);
        }
    }
    std::sort(result.begin(), result.end());
    return result;"
1,1.0,HumanEval_104_unique_digits,"
std::vector<long> unique_digits(std::vector<long> x) {
    std::vector<long> result;
    for(long num : x) {
        std::string num_str = std::to_string(num);
        bool has_even_digit = false;
        for(char digit : num_str) {
            if((digit - '0') % 2 == 0) {
                has_even_digit = true;
                break;
            }
        }
        if(!has_even_digit) {
            result.push_back(num);
        }
    }
    std::sort(result.begin(), result.end());
    return result;
"
0,1.0,HumanEval_104_unique_digits,"
std::vector<long> unique_digits(std::vector<long> x) {
    std::vector<long> result;
    for (long num : x) {
        bool hasEvenDigit = false;
        while (num > 0) {
            if ((num % 10) % 2 == 0) {
                hasEvenDigit = true;
                break;
            }
            num /= 10;
        }
        if (!hasEvenDigit) {
            result.push_back(num);
        }
    }
    std::sort(result.begin(), result.end());
    return result;
"
1,1.0,HumanEval_104_unique_digits,"

std::vector<long> unique_digits(std::vector<long> x) {
    std::vector<long> result;
    for(long num : x) {
        std::string num_str = std::to_string(num);
        bool has_even_digit = false;
        for(char digit : num_str) {
            if((digit - '0') % 2 == 0) {
                has_even_digit = true;
                break;
            }
        }
        if(!has_even_digit) {
            result.push_back(num);
        }
    }
    std::sort(result.begin(), result.end());
    return result;"
1,1.0,HumanEval_117_select_words,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

vector<string> select_words(string s, long n) {
    vector<string> words;
    string word;
    stringstream ss(s);
    while (ss >> word) {
        words.push_back(word);
    }

    vector<string> result;
    for (string word : words) {
        long consonants = 0;
        for (char c : word) {
            if (tolower(c) >= 'a' && tolower(c) <= 'z' &&
                !(tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' ||
                  tolower(c) == 'o' || tolower(c) == 'u')) {
                consonants++;
            }
        }
        if (consonants == n) {
            result.push_back(word);
        }
    }
    return result;
"
1,1.0,HumanEval_117_select_words,"

std::vector<std::string> select_words(std::string s, long n) {
    std::vector<std::string> result;
    std::string word = """";
    int consonant_count = 0;
    std::string consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ"";

    for(int i=0; i<s.length(); i++) {
        if(s[i] == ' ') {
            for(int j=0; j<word.length(); j++) {
                if(consonants.find(word[j]) != std::string::npos) {
                    consonant_count++;
                }
            }
            if(consonant_count == n) {
                result.push_back(word);
            }
            consonant_count = 0;
            word = """";
        } else {
            word += s[i];
        }
    }
    // Check the last word
    for(int j=0; j<word.length(); j++) {
        if(consonants.find(word[j]) != std::string::npos) {
            consonant_count++;
        }
    }
    if(consonant_count == n) {
        result.push_back(word);
    }
    return result;
"
1,0.0,HumanEval_117_select_words,"
std::vector<std::string> select_words(std::string s, long n) {
    std::vector<std::string> words;
    std::string word = """";
    for (auto x : s) {
        if (x == ' ') {
            words.push_back(word);
            word = """";
        } else {
            word = word + x;
        }
    }
    words.push_back(word);

    std::vector<std::string> result;
    std::string consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ"";
    for (auto w : words) {
        long count = 0;
        for (auto c : w) {
            if (consonants.find(c) != std::string::npos) {
                count++;
            }
        }
        if (count == n) {
            result.push_back(w);
        }
    }
    return result;"
1,0.0,HumanEval_117_select_words,"
std::vector<std::string> select_words(std::string s, long n) {
    std::vector<std::string> words;
    std::string word;
    std::stringstream ss(s);
    while (ss >> word)
        words.push_back(word);
    
    std::vector<std::string> result;
    for (std::string w : words) {
        long cnt = 0;
        for (char c : w) {
            if (std::tolower(c) != 'a' && std::tolower(c) != 'e' && std::tolower(c) != 'i' && std::tolower(c) != 'o' && std::tolower(c) != 'u' && std::isalpha(c))
                cnt++;
        }
        if (cnt == n)
            result.push_back(w);
    }
    return result;"
1,0.0,HumanEval_117_select_words,"
std::vector<std::string> select_words(std::string s, long n) {
    std::vector<std::string> words;
    std::string word;
    std::stringstream ss(s);
    while (ss >> word) {
        words.push_back(word);
    }

    std::vector<std::string> result;
    for (const auto& word : words) {
        long count = 0;
        for (char c : word) {
            if (tolower(c) != 'a' && tolower(c) != 'e' && tolower(c) != 'i' && tolower(c) != 'o' && tolower(c) != 'u' && isalpha(c)) {
                ++count;
            }
        }
        if (count == n) {
            result.push_back(word);
        }
    }
    return result;"
1,0.0,HumanEval_117_select_words,"
std::vector<std::string> select_words(std::string s, long n) {
    std::vector<std::string> result;
    std::stringstream ss(s);
    std::string word;
    while (ss >> word) {
        long consonants = 0;
        for (char c : word) {
            if (tolower(c) >= 'a' && tolower(c) <= 'z' && 
                !(tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' || 
                  tolower(c) == 'o' || tolower(c) == 'u')) {
                consonants++;
            }
        }
        if (consonants == n) {
            result.push_back(word);
        }
    }
    return result;"
1,0.0,HumanEval_117_select_words,"

std::vector<std::string> select_words(std::string s, long n) {
    std::vector<std::string> result;
    std::istringstream ss(s);
    std::string word;
    while (ss >> word) {
        long consonants = 0;
        for (char c : word) {
            if (tolower(c) >= 'a' && tolower(c) <= 'z' && 
                !(tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' || 
                  tolower(c) == 'o' || tolower(c) == 'u')) {
                consonants++;
            }
        }
        if (consonants == n) {
            result.push_back(word);
        }
    }
    return result;
"
1,1.0,HumanEval_117_select_words,"

std::vector<std::string> select_words(std::string s, long n) {
    std::vector<std::string> result;
    std::string word;
    std::stringstream ss(s);
    std::string consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ"";

    while (ss >> word) {
        long count = 0;
        for (char c : word) {
            if (consonants.find(c) != std::string::npos) {
                count++;
            }
        }
        if (count == n) {
            result.push_back(word);
        }
    }
    return result;"
1,0.0,HumanEval_117_select_words,"

std::vector<std::string> select_words(std::string s, long n) {
    std::vector<std::string> words;
    std::string word = """";
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == ' ') {
            words.push_back(word);
            word = """";
        } else {
            word += s[i];
        }
    }
    words.push_back(word);

    std::vector<std::string> result;
    for (std::string str : words) {
        long count = 0;
        for (char c : str) {
            if (tolower(c) != 'a' && tolower(c) != 'e' && tolower(c) != 'i' && tolower(c) != 'o' && tolower(c) != 'u' && isalpha(c)) {
                count++;
            }
        }
        if (count == n) {
            result.push_back(str);
        }
    }
    return result;
"
0,0.0,HumanEval_117_select_words,"

std::vector<std::string> select_words(std::string s, long n) {
    std::vector<std::string> result;
    std::string word = """";
    long consonants = 0;

    for (char c : s) {
        if (c == ' ') {
            if (consonants == n) {
                result.push_back(word);
            }
            word = """";
            consonants = 0;
        } else {
            word += tolower(c);
            if (tolower(c) != 'a' && tolower(c) != 'e' && tolower(c) != 'i' && tolower(c) != 'o' && tolower(c) != 'u') {
                consonants++;
            }
        }
    }

    if (consonants == n) {
        result.push_back(word);
    }

    return result;"
0,1.0,HumanEval_72_will_it_fly,"

bool will_it_fly(std::vector<long> q, long w) {
    return isPalindrome(q) && sumVector(q) <= w;
"
0,1.0,HumanEval_72_will_it_fly,"

bool will_it_fly(std::vector<long> q, long w) {
    return is_palindrome(q) && sum_vector(q) <= w;"
1,1.0,HumanEval_72_will_it_fly,"
bool will_it_fly(std::vector<long> q, long w) {
    long sum = 0;
    int n = q.size();
    for(int i = 0; i < n; i++) {
        sum += q[i];
    }
    if(sum > w) {
        return false;
    }
    int start = 0, end = n - 1;
    while(start < end) {
        if(q[start] != q[end]) {
            return false;
        }
        start++;
        end--;
    }
    return true;"
0,1.0,HumanEval_72_will_it_fly,"

bool will_it_fly(std::vector<long> q, long w) {
    return (isPalindrome(q) && sum(q) <= w);"
0,1.0,HumanEval_72_will_it_fly,"

bool will_it_fly(std::vector<long> q, long w) {
    return isPalindrome(q) && sumOfVector(q) <= w;
"
0,1.0,HumanEval_72_will_it_fly,"

bool will_it_fly(std::vector<long> q, long w) {
    return is_palindrome(q) && sum_vector(q) <= w;"
1,1.0,HumanEval_72_will_it_fly,"
bool will_it_fly(std::vector<long> q, long w) {
    long sum = 0;
    int n = q.size();
    for(int i = 0; i < n; i++) {
        sum += q[i];
    }
    if(sum > w) {
        return false;
    }
    int start = 0;
    int end = n - 1;
    while(start < end) {
        if(q[start] != q[end]) {
            return false;
        }
        start++;
        end--;
    }
    return true;"
0,1.0,HumanEval_72_will_it_fly,"

bool will_it_fly(std::vector<long> q, long w) {
    if (is_palindrome(q)) {
        long sum = std::accumulate(q.begin(), q.end(), 0L);
        if (sum <= w) {
            return true;
        }
    }
    return false;"
1,1.0,HumanEval_72_will_it_fly,"
bool will_it_fly(std::vector<long> q, long w) {
    long sum = 0;
    int size = q.size();
    for(int i = 0; i < size / 2; i++) {
        if (q[i] != q[size - i - 1]) {
            return false;
        }
    }
    for(int i = 0; i < size; i++) {
        sum += q[i];
    }
    return sum <= w;"
1,1.0,HumanEval_72_will_it_fly,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

bool is_palindrome(const vector<long>& v) {
    int n = v.size();
    for (int i = 0; i < n / 2; i++) {
        if (v[i] != v[n - 1 - i]) {
            return false;
        }
    }
    return true;
}

bool will_it_fly(vector<long> q, long w) {
    if (!is_palindrome(q)) {
        return false;
    }
    long sum = accumulate(q.begin(), q.end(), 0L);
    return sum <= w;
"
1,1.0,HumanEval_55_fib,"
long fib(long n) {
    if (n <= 1)
        return n;
    long a = 0, b = 1, c;
    for (long i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    return b;"
1,1.0,HumanEval_55_fib,"
long fib(long n) {
    if (n <= 1)
        return n;
    else
        return fib(n-1) + fib(n-2);"
1,1.0,HumanEval_55_fib,"
long fib(long n) {
    assert(n >= 0);

    if (n <= 1)
        return n;
    
    long previous = 0, current = 1;

    for (long i = 2; i <= n; i++) {
        long temp = previous + current;
        previous = current;
        current = temp;
    }

    return current;"
1,1.0,HumanEval_55_fib,"
long fib(long n) {
    if (n <= 0)
       return 0;
    else if (n == 1)
       return 1;
    else
       return fib(n-1) + fib(n-2);"
1,1.0,HumanEval_55_fib,"
long fib(long n) {
    assert(n >= 0);
    if (n <= 1) {
        return n;
    }
    long a = 0, b = 1;
    for (long i = 2; i <= n; i++) {
        long temp = a + b;
        a = b;
        b = temp;
    }
    return b;"
1,1.0,HumanEval_55_fib,"
long fib(long n) {
    assert(n >= 0);
    if (n <= 1)
        return n;
    else
        return fib(n - 1) + fib(n - 2);
"
1,1.0,HumanEval_55_fib,"
long fib(long n) {
    if (n <= 1)
        return n;
    else
        return fib(n-1) + fib(n-2);"
1,1.0,HumanEval_55_fib,"
long fib(long n) {
    if (n <= 1)
        return n;
    else
        return fib(n-1) + fib(n-2);
"
1,1.0,HumanEval_55_fib,"
long fib(long n) {
    // Base cases
    if (n <= 0)
        return 0;
    if (n == 1)
        return 1;

    // Fibonacci variables
    long fib_1 = 1, fib_2 = 0, fib_n;

    // Calculate Fibonacci sequence up to n
    for (long i = 2; i <= n; i++) {
        fib_n = fib_1 + fib_2;
        fib_2 = fib_1;
        fib_1 = fib_n;
    }

    return fib_1;"
1,1.0,HumanEval_55_fib,"

long fib(long n) {
    assert(n >= 0);
    if (n <= 1)
        return n;
    long a = 0;
    long b = 1;
    for (long i = 2; i <= n; ++i) {
        long c = a + b;
        a = b;
        b = c;
    }
    return b;"
0,0.0,HumanEval_153_Strongest_Extension,"
    // Initialize the strongest extension to be the first extension in the vector
    // and its strength to be the strength of the first extension.
    std::string strongest_extension = extensions[0];
    int strongest_strength = std::count_if(extensions[0].begin(), extensions[0].end(), ::isupper) 
                             - std::count_if(extensions[0].begin(), extensions[0].end(), ::islower);

    // Iterate through the rest of the extensions.
    for (int i = 1; i < extensions.size(); i++) {
        // Calculate the strength of the current extension.
        int current_strength = std::count_if(extensions[i].begin(), extensions[i].end(), ::isupper) 
                              - std::count_if(extensions[i].begin(), extensions[i].end(), ::islower);

        // If the current extension is stronger than the current strongest extension,
        // update the strongest extension and its strength.
        if (current_strength > strongest_strength) {
            strongest_extension = extensions[i];
            strongest_strength = current_strength;
        }
    }

    // Return the class name and the strongest extension in the format specified.
    return class_name + ""."" + strongest_extension;"
1,0.0,HumanEval_153_Strongest_Extension,"
std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
    double max_strength = -1000000;
    std::string strongest_extension = """";

    for (auto extension : extensions) {
        double strength = 0;
        for (char c : extension) {
            if (isupper(c)) {
                strength++;
            } else if (islower(c)) {
                strength--;
            }
        }
        if (strength > max_strength) {
            max_strength = strength;
            strongest_extension = extension;
        }
    }

    return class_name + ""."" + strongest_extension;"
1,0.0,HumanEval_153_Strongest_Extension,"
std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
    double max_strength = -1000000.0;
    std::string strongest_extension = """";

    for (const auto &extension : extensions) {
        double strength = 0.0;
        for (const auto &ch : extension) {
            if (isupper(ch)) {
                strength++;
            } else if (islower(ch)) {
                strength--;
            }
        }
        if (strength > max_strength) {
            max_strength = strength;
            strongest_extension = extension;
        }
    }

    return class_name + ""."" + strongest_extension;
"
1,0.0,HumanEval_153_Strongest_Extension,"
std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
    double maxStrength = -1000000.0;
    std::string strongestExtension = """";

    for(auto &extension : extensions){
        double strength = 0.0;
        for(auto &c : extension){
            if(isupper(c))
                strength++;
            else if(islower(c))
                strength--;
        }
        if(strength > maxStrength){
            maxStrength = strength;
            strongestExtension = extension;
        }
    }
    return class_name + '.' + strongestExtension;
"
1,1.0,HumanEval_153_Strongest_Extension,"

std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
    double max_strength = -1000000;
    std::string strongest_extension = """";

    for(auto extension : extensions) {
        int cap = 0, sm = 0;
        for(auto ch : extension) {
            if(isupper(ch)) cap++;
            if(islower(ch)) sm++;
        }
        double strength = (double)cap - sm;
        if(strength > max_strength) {
            max_strength = strength;
            strongest_extension = extension;
        }
    }

    return class_name + ""."" + strongest_extension;"
0,0.0,HumanEval_153_Strongest_Extension,"
    // Initialize the strongest extension to be the first extension in the vector
    std::string strongest_extension = extensions[0];
    double strongest_strength = 0;

    // Iterate over all extensions
    for(auto& extension : extensions) {
        // Calculate the strength of the extension
        double strength = 0;
        for(auto& ch : extension) {
            if(isupper(ch)) {
                strength++;
            } else if(islower(ch)) {
                strength--;
            }
        }

        // If the strength of the extension is greater than the current strongest
        // strength, update the strongest extension and its strength
        if(strength > strongest_strength) {
            strongest_extension = extension;
            strongest_strength = strength;
        }
    }

    // Return the class name and the strongest extension in the required format
    return class_name + '.' + strongest_extension;
"
1,1.0,HumanEval_153_Strongest_Extension,"
std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
    std::string strongest_extension = """";
    int max_strength = INT_MIN;

    for(auto extension : extensions){
        int cap = 0, sm = 0;
        for(char c : extension){
            if(isupper(c)) cap++;
            if(islower(c)) sm++;
        }
        int strength = cap - sm;
        if(strength > max_strength){
            max_strength = strength;
            strongest_extension = extension;
        }
    }

    return class_name + ""."" + strongest_extension;"
1,0.0,HumanEval_153_Strongest_Extension,"
std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
    double max_strength = -1000000;
    std::string strongest_extension;
    for (auto ext : extensions) {
        double strength = 0;
        for (char c : ext) {
            if (isupper(c)) {
                strength++;
            } else if (islower(c)) {
                strength--;
            }
        }
        if (strength > max_strength) {
            max_strength = strength;
            strongest_extension = ext;
        }
    }
    return class_name + ""."" + strongest_extension;"
1,1.0,HumanEval_153_Strongest_Extension,"

std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
    double max_strength = -1e9;
    std::string strongest_extension;

    for(auto &extension : extensions) {
        double strength = 0;
        for(char &ch : extension) {
            if(isupper(ch)) {
                strength++;
            } else if(islower(ch)) {
                strength--;
            }
        }

        if(strength > max_strength) {
            max_strength = strength;
            strongest_extension = extension;
        }
    }

    return class_name + ""."" + strongest_extension;"
1,1.0,HumanEval_153_Strongest_Extension,"

std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
    double max_strength = -1000000;
    std::string strongest_extension = """";
    for (auto extension : extensions) {
        double strength = 0;
        for (char c : extension) {
            if (isupper(c)) {
                strength += 1;
            } else if (islower(c)) {
                strength -= 1;
            }
        }
        if (strength > max_strength) {
            max_strength = strength;
            strongest_extension = extension;
        }
    }
    return class_name + ""."" + strongest_extension;"
0,0.0,HumanEval_119_match_parens,"

std::string match_parens(std::vector<std::string> lst) {
    int open = 0, close = 0;
    for(auto& str : lst) {
        for(char& ch : str) {
            if(ch == '(') {
                open++;
            } else if(ch == ')') {
                if(open > 0) {
                    open--;
                } else {
                    close++;
                }
            }
        }
    }
    return (open == close) ? ""Yes"" : ""No"";"
0,0.0,HumanEval_119_match_parens,"

std::string match_parens(std::vector<std::string> lst) {
    int count = 0;
    for(auto str : lst) {
        for(char c : str) {
            if(c == '(') {
                count++;
            } else if(c == ')') {
                if(count == 0) {
                    return ""No"";
                }
                count--;
            }
        }
    }
    return count == 0 ? ""Yes"" : ""No"";
"
0,0.0,HumanEval_119_match_parens,"

std::string match_parens(std::vector<std::string> lst) {
    int open = 0, close = 0;
    for (auto &s : lst) {
        for (char &c : s) {
            if (c == '(') {
                open++;
            } else if (c == ')') {
                if (open > 0) {
                    open--;
                } else {
                    close++;
                }
            }
        }
    }
    return (open == close) ? ""Yes"" : ""No"";
"
0,0.0,HumanEval_119_match_parens,"
std::string match_parens(std::vector<std::string> lst) {
    int open = 0, close = 0;
    for (auto& str : lst) {
        for (char& c : str) {
            if (c == '(') {
                open++;
            } else if (c == ')') {
                if (open > 0) {
                    open--;
                } else {
                    close++;
                }
            }
        }
    }
    if (open == close) {
        return ""Yes"";
    } else {
        return ""No"";
    }"
0,1.0,HumanEval_119_match_parens,"
std::string match_parens(std::vector<std::string> lst) {
    int count = 0;
    for(auto str : lst) {
        for(auto ch : str) {
            if(ch == '(') {
                count++;
            } else if(ch == ')') {
                if(count == 0) {
                    return ""No"";
                }
                count--;
            }
        }
    }
    return count == 0 ? ""Yes"" : ""No"";
"
0,0.0,HumanEval_119_match_parens,"
std::string match_parens(std::vector<std::string> lst) {
    int count = 0;
    for (auto& s : lst) {
        for (auto& c : s) {
            if (c == '(') {
                count++;
            } else if (c == ')') {
                count--;
                if (count < 0) {
                    return ""No"";
                }
            }
        }
    }
    return count == 0 ? ""Yes"" : ""No"";
"
0,0.0,HumanEval_119_match_parens,"
    std::string s1 = lst[0];
    std::string s2 = lst[1];

    int count = 0;
    for (int i = 0; i < s1.size(); i++) {
        if (s1[i] == '(') {
            count++;
        } else if (s1[i] == ')') {
            if (count == 0) {
                return ""No"";
            }
            count--;
        }
    }

    for (int i = 0; i < s2.size(); i++) {
        if (s2[i] == '(') {
            count++;
        } else if (s2[i] == ')') {
            if (count == 0) {
                return ""No"";
            }
            count--;
        }
    }

    return count == 0 ? ""Yes"" : ""No"";
"
0,0.0,HumanEval_119_match_parens,"
    // Initialize a stack to store the parentheses
    std::stack<char> s;

    // Concatenate the two strings
    std::string str = lst[0] + lst[1];

    // Traverse through the string
    for(int i = 0; i < str.size(); i++) {
        // If the current character is an open parenthesis, push it to the stack
        if(str[i] == '(') {
            s.push(str[i]);
        }
        // If the current character is a close parenthesis
        else {
            // If the stack is empty, return ""No"" as there is no matching open parenthesis for this close parenthesis
            if(s.empty()) {
                return ""No"";
            }
            // If the stack is not empty, pop the top element from the stack
            else {
                s.pop();
            }
        }
    }

    // If the stack is empty, return ""Yes"" as all parentheses are balanced
    if(s.empty()) {
        return ""Yes"";
    }
    // If the stack is not empty, return ""No"" as there are unbalanced parentheses
    else {
        return ""No"";
    }"
0,0.0,HumanEval_119_match_parens,"
std::string match_parens(std::vector<std::string> lst) {
    int count = 0;
    for (auto &s : lst) {
        for (char &c : s) {
            if (c == '(') {
                count++;
            } else if (c == ')') {
                if (count == 0) {
                    return ""No"";
                }
                count--;
            }
        }
    }
    return count == 0 ? ""Yes"" : ""No"";"
0,0.0,HumanEval_119_match_parens,"

std::string match_parens(std::vector<std::string> lst) {
    int open = 0, close = 0;
    for(auto& str : lst) {
        for(char& c : str) {
            if (c == '(') {
                open++;
            } else if (c == ')') {
                if (open > 0) {
                    open--;
                } else {
                    close++;
                }
            }
        }
    }
    return (open == close) ? ""Yes"" : ""No"";"
1,1.0,HumanEval_90_next_smallest,"

std::optional<long> next_smallest(std::vector<long> lst) {
    if(lst.size() < 2) {
        return std::nullopt;
    }
    long smallest = LONG_MAX, next_smallest = LONG_MAX;
    for(long num : lst) {
        if(num < smallest) {
            next_smallest = smallest;
            smallest = num;
        } else if(num > smallest && num < next_smallest) {
            next_smallest = num;
        }
    }
    if(next_smallest == LONG_MAX) {
        return std::nullopt;
    }
    return next_smallest;
"
1,1.0,HumanEval_90_next_smallest,"
std::optional<long> next_smallest(std::vector<long> lst) {
    if(lst.size() < 2) {
        return std::nullopt;
    }
    long first_min = LONG_MAX;
    long second_min = LONG_MAX;
    for(long num : lst) {
        if(num < first_min) {
            second_min = first_min;
            first_min = num;
        } else if(num < second_min && num != first_min) {
            second_min = num;
        }
    }
    if(second_min == LONG_MAX) {
        return std::nullopt;
    }
    return second_min;
"
1,1.0,HumanEval_90_next_smallest,"
std::optional<long> next_smallest(std::vector<long> lst) {
    if (lst.size() < 2) {
        return std::nullopt;
    }
    long first_min = LONG_MAX;
    long second_min = LONG_MAX;
    for (long num : lst) {
        if (num < first_min) {
            second_min = first_min;
            first_min = num;
        } else if (num > first_min && num < second_min) {
            second_min = num;
        }
    }
    if (second_min == LONG_MAX) {
        return std::nullopt;
    }
    return second_min;"
0,1.0,HumanEval_90_next_smallest,"

std::optional<long> next_smallest(std::vector<long> lst) {
    if(lst.size() < 2) {
        return std::nullopt;
    }

    std::set<long> s(lst.begin(), lst.end());

    auto it = s.begin();
    std::advance(it, 1);

    return *it;"
1,1.0,HumanEval_90_next_smallest,"
std::optional<long> next_smallest(std::vector<long> lst) {
    if(lst.size() < 2) {
        return std::nullopt;
    }
    long first_min = LONG_MAX;
    long second_min = LONG_MAX;
    for(long num : lst) {
        if(num < first_min) {
            second_min = first_min;
            first_min = num;
        } else if(num < second_min && num != first_min) {
            second_min = num;
        }
    }
    if(second_min == LONG_MAX) {
        return std::nullopt;
    }
    return second_min;
"
1,1.0,HumanEval_90_next_smallest,"
std::optional<long> next_smallest(std::vector<long> lst) {
    if(lst.size() < 2) {
        return std::nullopt;
    }

    long first_min = LONG_MAX, second_min = LONG_MAX;

    for(long num : lst) {
        if(num < first_min) {
            second_min = first_min;
            first_min = num;
        } else if(num < second_min && num != first_min) {
            second_min = num;
        }
    }

    if(second_min == LONG_MAX) {
        return std::nullopt;
    }

    return second_min;
"
1,1.0,HumanEval_90_next_smallest,"
std::optional<long> next_smallest(std::vector<long> lst) {
    if(lst.size() < 2) {
        return std::nullopt;
    }

    long first_min = LONG_MAX;
    long second_min = LONG_MAX;

    for(long num : lst) {
        if(num < first_min) {
            second_min = first_min;
            first_min = num;
        } else if(num > first_min && num < second_min) {
            second_min = num;
        }
    }

    if(second_min == LONG_MAX) {
        return std::nullopt;
    }
    return second_min;"
1,0.0,HumanEval_90_next_smallest,"

std::optional<long> next_smallest(std::vector<long> lst) {
    if (lst.size() < 2) {
        return std::nullopt;
    }
    std::sort(lst.begin(), lst.end());
    for (size_t i = 1; i < lst.size(); i++) {
        if (lst[i] != lst[0]) {
            return lst[i];
        }
    }
    return std::nullopt;"
1,1.0,HumanEval_90_next_smallest,"
std::optional<long> next_smallest(std::vector<long> lst) {
    if (lst.size() < 2) {
        return std::nullopt;
    }

    long smallest = LONG_MAX;
    long second_smallest = LONG_MAX;

    for (long num : lst) {
        if (num < smallest) {
            second_smallest = smallest;
            smallest = num;
        } else if (num > smallest && num < second_smallest) {
            second_smallest = num;
        }
    }

    if (second_smallest == LONG_MAX) {
        return std::nullopt;
    }

    return second_smallest;
"
0,0.0,HumanEval_90_next_smallest,"
    // Sort the vector in ascending order
    std::sort(lst.begin(), lst.end());

    // Iterate over the vector to find the 2nd smallest element
    for (size_t i = 1; i < lst.size(); ++i) {
        // If the current element is not equal to the first element and is not equal to the previous element,
        // then it is the 2nd smallest element
        if (lst[i] != lst[0] && lst[i] != lst[i-1]) {
            return lst[i];
        }
    }

    // If no such element is found, return None
    return std::nullopt;
"
0,0.0,HumanEval_92_any_int,"
    // Check if all numbers are integers
    if (x == (int)x && y == (int)y && z == (int)z) {
        // Check if one of the numbers is equal to the sum of the other two
        if (x + y == z || x + z == y || y + z == x) {
            return true;
        }
    }
    // Return false in any other cases
    return false;"
0,0.0,HumanEval_92_any_int,"

bool any_int(float x, float y, float z) {
    // Check if all numbers are integers
    if(x == (int)x && y == (int)y && z == (int)z) {
        // Check if one of the numbers is equal to the sum of the other two
        if(x + y == z || x + z == y || y + z == x) {
            return true;
        }
    }
    return false;
"
0,0.0,HumanEval_92_any_int,"

bool any_int(float x, float y, float z) {
    // Check if all numbers are integers
    if(x == (int)x && y == (int)y && z == (int)z) {
        // Check if one of the numbers is equal to the sum of the other two
        if(x == y + z || y == x + z || z == x + y) {
            return true;
        }
    }
    // Return false in any other cases
    return false;"
0,0.0,HumanEval_92_any_int,"

bool any_int(float x, float y, float z) {
    // Check if all numbers are integers
    if (x == (int)x && y == (int)y && z == (int)z) {
        // Check if one of the numbers is equal to the sum of the other two
        if (x + y == z || x + z == y || y + z == x) {
            return true;
        }
    }
    // Return false in any other cases
    return false;"
0,0.0,HumanEval_92_any_int,"

bool any_int(float x, float y, float z) {
    // Check if all numbers are integers
    if (x == (int)x && y == (int)y && z == (int)z) {
        // Check if one of the numbers is equal to the sum of the other two
        if (x + y == z || x + z == y || y + z == x) {
            return true;
        }
    }
    // Return false in any other cases
    return false;"
0,0.0,HumanEval_92_any_int,"

bool any_int(float x, float y, float z) {
    // Check if all numbers are integers
    if (x == (int)x && y == (int)y && z == (int)z) {
        // Check if any number is equal to the sum of the other two
        if (x == y + z || y == x + z || z == x + y) {
            return true;
        }
    }
    // Return false in any other cases
    return false;
"
0,0.0,HumanEval_92_any_int,"

bool any_int(float x, float y, float z) {
    // Check if all numbers are integers
    if (x == (int)x && y == (int)y && z == (int)z) {
        // Check if one of the numbers is equal to the sum of the other two
        if (x + y == z || x + z == y || y + z == x) {
            return true;
        }
    }
    // Return false in any other cases
    return false;"
0,0.0,HumanEval_92_any_int,"

bool any_int(float x, float y, float z) {
    // Check if all numbers are integers
    if (x == (int)x && y == (int)y && z == (int)z) {
        // Check if one of the numbers is equal to the sum of the other two
        if (x + y == z || x + z == y || y + z == x) {
            return true;
        }
    }
    return false;
"
0,0.0,HumanEval_92_any_int,"

bool any_int(float x, float y, float z) {
    // Check if all numbers are integers
    if (x == (int)x && y == (int)y && z == (int)z) {
        // Check if one of the numbers is equal to the sum of the other two
        if (x == y + z || y == x + z || z == x + y) {
            return true;
        }
    }
    // Return false in any other cases
    return false;"
0,1.0,HumanEval_92_any_int,"
bool any_int(float x, float y, float z) {
    // Check if all numbers are integers
    if (x == (int)x && y == (int)y && z == (int)z) {
        // Check if one of the numbers is equal to the sum of the other two
        if (x == y + z || y == x + z || z == x + y) {
            return true;
        }
    }
    // If the above conditions are not met, return false
    return false;"
1,1.0,HumanEval_2_truncate_number,"
float truncate_number(float number) {
    float integerPart;
    float fractionalPart = modf(number, &integerPart);
    return fractionalPart;"
1,1.0,HumanEval_2_truncate_number,"

float truncate_number(float number) {
    float intpart;
    float frac = modf(number, &intpart);
    return frac;"
1,1.0,HumanEval_2_truncate_number,"

float truncate_number(float number) {
    float intpart;
    float fracpart = modf(number, &intpart);
    return fracpart;"
0,0.0,HumanEval_2_truncate_number,"
    float intPart;
    float decimalPart = modf(number, &intPart);
    return decimalPart;"
1,1.0,HumanEval_2_truncate_number,"

float truncate_number(float number) {
    float intpart;
    float decimal = modf(number, &intpart);
    return decimal;"
1,1.0,HumanEval_2_truncate_number,"

float truncate_number(float number) {
    float intPart;
    float decimalPart = modf(number, &intPart);
    return decimalPart;"
1,1.0,HumanEval_2_truncate_number,"

float truncate_number(float number) {
    // Using modf function to separate the number into integral and fractional parts
    float integral;
    float fractional = modf(number, &integral);

    // Return the fractional part
    return fractional;"
1,1.0,HumanEval_2_truncate_number,"

float truncate_number(float number) {
    float integer_part = floor(number);
    float decimal_part = number - integer_part;
    return decimal_part;"
1,1.0,HumanEval_2_truncate_number,"

float truncate_number(float number) {
    float intpart;
    float decimal = modf(number, &intpart);
    return decimal;"
0,0.0,HumanEval_2_truncate_number,"
    assert(number > 0);
    float integer_part = floor(number);
    float decimal_part = number - integer_part;
    return decimal_part;
"
1,1.0,HumanEval_42_incr_list,"

std::vector<long> incr_list(std::vector<long> l) {
    for(long &n : l) {
        n++;
    }
    return l;
"
1,1.0,HumanEval_42_incr_list,"
std::vector<long> incr_list(std::vector<long> l) {
    for(long &i : l) {
        i++;
    }
    return l;"
1,1.0,HumanEval_42_incr_list,"
std::vector<long> incr_list(std::vector<long> l) {
    for(long &i : l) {
        i++;
    }
    return l;
"
1,1.0,HumanEval_42_incr_list,"

std::vector<long> incr_list(std::vector<long> l) {
    for(auto& i : l) {
        i++;
    }
    return l;
"
1,1.0,HumanEval_42_incr_list,"

std::vector<long> incr_list(std::vector<long> l) {
    for(long i = 0; i < l.size(); i++) {
        l[i]++;
    }
    return l;"
1,1.0,HumanEval_42_incr_list,"

std::vector<long> incr_list(std::vector<long> l) {
    for(long& i : l) {
        i++;
    }
    return l;
"
1,1.0,HumanEval_42_incr_list,"
std::vector<long> incr_list(std::vector<long> l) {
    for (long& num : l) {
        num++;
    }
    return l;"
1,1.0,HumanEval_42_incr_list,"
std::vector<long> incr_list(std::vector<long> l) {
    for(long& num : l) {
        num += 1;
    }
    return l;"
1,1.0,HumanEval_42_incr_list,"
std::vector<long> incr_list(std::vector<long> l) {
    for (auto &element : l) {
        element++;
    }
    return l;"
1,1.0,HumanEval_42_incr_list,"

std::vector<long> incr_list(std::vector<long> l) {
    for (long &i : l) {
        i++;
    }
    return l;"
0,0.0,HumanEval_150_x_or_y,"
long x_or_y(long n, long x, long y) {
    return isPrime(n) ? x : y;"
0,0.0,HumanEval_150_x_or_y,"

long x_or_y(long n, long x, long y) {
    return is_prime(n) ? x : y;"
0,1.0,HumanEval_150_x_or_y,"
long x_or_y(long n, long x, long y) {
    return isPrime(n) ? x : y;
"
0,0.0,HumanEval_150_x_or_y,"

long x_or_y(long n, long x, long y) {
    return isPrime(n) ? x : y;"
0,1.0,HumanEval_150_x_or_y,"

long x_or_y(long n, long x, long y) {
    return isPrime(n) ? x : y;
"
0,1.0,HumanEval_150_x_or_y,"
long x_or_y(long n, long x, long y) {
    return isPrime(n) ? x : y;"
0,0.0,HumanEval_150_x_or_y,"

long x_or_y(long n, long x, long y) {
    return isPrime(n)?x:y;"
0,0.0,HumanEval_150_x_or_y,"

long x_or_y(long n, long x, long y) {
    return isPrime(n) ? x : y;
"
0,0.0,HumanEval_150_x_or_y,"

long x_or_y(long n, long x, long y) {
    return isPrime(n) ? x : y;"
0,1.0,HumanEval_150_x_or_y,"

long x_or_y(long n, long x, long y) {
    return isPrime(n) ? x : y;"
0,1.0,HumanEval_49_modp,"
long modp(long n, long p) {
    long res = 1;
    n = n % p;
    while (n > 0) {
        if (n % 2 == 1)
            res = (res * n) % p;
        n = n - 1;
        n = n / 2;
    }
    return res % p;
"
1,1.0,HumanEval_49_modp,"
long modp(long n, long p) {
    // base case
    if (n == 0)
        return 1;
    
    // recursive case
    long temp = modp(n / 2, p);
    if (n % 2 == 0)
        return (temp * temp) % p;
    else
        return (2 * temp * temp) % p;
"
1,1.0,HumanEval_49_modp,"
long modp(long n, long p) {
    // Base cases
    if (n == 0)
        return 1;
    if (n == 1)
        return 2;

    // If n is even
    if (n % 2 == 0) {
        long y = modp(n / 2, p);
        return (y * y) % p;
    }

    // If n is odd
    else {
        long y = modp(n - 1, p);
        return (2 * y) % p;
    }
"
0,0.0,HumanEval_49_modp,"
long modp(long n, long p) {
    long res = 1;
    n = n % p;
    while (n > 0) {
        if (n % 2 == 1)
            res = (res * 2) % p;
        n = n / 2;
        res = res % p;
    }
    return res;"
0,1.0,HumanEval_49_modp,"
long modp(long n, long p) {
    // base case
    if(n == 0)
        return 1;
    
    // recursive case
    long temp = modp(n/2, p);
    
    if(n % 2 == 0)
        return (temp * temp) % p;
    else
        return (((temp * temp) % p) * 2) % p;"
0,1.0,HumanEval_49_modp,"
long modp(long n, long p) {
    if(n == 0)
        return 1;

    long temp = modp(n/2, p);

    if(n%2 == 0)
        return (temp * temp) % p;
    else
        return (((temp * temp) % p) * 2) % p;"
0,0.0,HumanEval_49_modp,"
long modp(long n, long p) {
    // Base cases
    if (p == 1)
        return 0;
    if (n == 0)
        return 1;

    // Initialize result
    long res = 1;

    // n could be negative, convert it to positive
    n = abs(n);

    while (n > 0) {
        // If n is odd
        if (n % 2 == 1)
            res = (res * 2) % p;

        // n must be even now, so we can do n = n / 2
        n = n / 2;

        // Also, p = p * p
        if (res > p)
            res = res - p;
    }

    return res;"
0,1.0,HumanEval_49_modp,"
long modp(long n, long p) {
    // Base case
    if(n == 0)
        return 1;

    // Recursive case
    long temp = modp(n/2, p);

    if(n%2 == 0)
        return (temp * temp) % p;
    else
        return (((temp * temp) % p) * 2) % p;"
1,0.0,HumanEval_49_modp,"

long modp(long n, long p) {
    // base cases
    if(n == 0)
        return 1;
    if(n == 1)
        return 2;
    
    // recursive case
    long temp = modp(n/2, p);
    temp = (temp * temp) % p;
    if(n % 2 == 0) // if n is even
        return temp;
    else // if n is odd
        return (temp * 2) % p;"
0,0.0,HumanEval_49_modp,"
long modp(long n, long p) {
    // Base cases
    if (p == 1) return 0;
    if (n == 0) return 1;

    // Initialize result
    long res = 1;

    // n could be negative, convert it to positive
    n = abs(n);

    while (n > 0) {
        // If n is odd, multiply result with base
        if (n & 1) {
            res = (res * 2) % p;
        }

        // n must be even now, reduce n and halve it
        n = n >> 1;
        // Also, reduce the modulo
        res %= p;
    }

    // If result is negative, add p to make it positive
    if (res < 0) {
        res += p;
    }

    return res;"
0,1.0,HumanEval_155_even_odd_count,"

std::tuple<long, long> even_odd_count(long num) {
    long even_count = 0;
    long odd_count = 0;
    num = abs(num); // Take absolute value to handle negative numbers
    while(num > 0) {
        long digit = num % 10;
        if(digit % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
        num = num / 10;
    }
    return std::make_tuple(even_count, odd_count);"
0,1.0,HumanEval_155_even_odd_count,"
std::tuple<long, long> even_odd_count(long num) {
    long even_count = 0;
    long odd_count = 0;

    num = abs(num); // to handle negative numbers

    while(num > 0) {
        if((num % 10) % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
        num = num / 10;
    }

    return std::make_tuple(even_count, odd_count);"
0,0.0,HumanEval_155_even_odd_count,"
    long even_count = 0, odd_count = 0;
    num = std::abs(num);
    while (num > 0) {
        if ((num % 10) % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
        num = num / 10;
    }
    return std::make_tuple(even_count, odd_count);"
0,0.0,HumanEval_155_even_odd_count,"

std::tuple<long, long> even_odd_count(long num) {
    long even_count = 0, odd_count = 0;
    num = std::abs(num); // make sure the number is positive
    while(num > 0) {
        int digit = num % 10;
        if (digit % 2 == 0)
            even_count++;
        else
            odd_count++;
        num /= 10;
    }
    return std::make_tuple(even_count, odd_count);
"
0,0.0,HumanEval_155_even_odd_count,"
    long even_count = 0;
    long odd_count = 0;

    num = abs(num); // convert to positive if negative
    while(num > 0) {
        if((num % 10) % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
        num = num / 10;
    }

    return std::make_tuple(even_count, odd_count);
"
0,0.0,HumanEval_155_even_odd_count,"
    long even_count = 0;
    long odd_count = 0;
    num = abs(num); // convert to positive if negative
    while(num > 0) {
        long digit = num % 10; // get the last digit
        if (digit % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
        num /= 10; // remove the last digit
    }
    return std::make_tuple(even_count, odd_count);"
0,1.0,HumanEval_155_even_odd_count,"
std::tuple<long, long> even_odd_count(long num) {
    long even_count = 0;
    long odd_count = 0;
    num = abs(num); // get absolute value of num
    while(num > 0) {
        long digit = num % 10;
        if(digit % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
        num /= 10;
    }
    return std::make_tuple(even_count, odd_count);
"
0,0.0,HumanEval_155_even_odd_count,"
std::tuple<long, long> even_odd_count(long num) {
    long even_count = 0;
    long odd_count = 0;
    num = std::abs(num); // Convert to positive if it's negative
    while(num > 0) {
        if((num % 10) % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
        num = num / 10;
    }
    return std::make_tuple(even_count, odd_count);"
0,0.0,HumanEval_155_even_odd_count,"

std::tuple<long, long> even_odd_count(long num) {
    long even_count = 0, odd_count = 0;
    num = std::abs(num); // to handle negative numbers
    while (num > 0) {
        if ((num % 10) % 2 == 0) 
            even_count++;
        else 
            odd_count++;
        num = num / 10;
    }
    return std::make_tuple(even_count, odd_count);"
0,1.0,HumanEval_155_even_odd_count,"

std::tuple<long, long> even_odd_count(long num) {
    long even_count = 0, odd_count = 0;
    num = std::abs(num); // make sure the number is positive
    while (num > 0) {
        if ((num % 10) % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
        num /= 10;
    }
    return std::make_tuple(even_count, odd_count);"
0,0.0,HumanEval_80_is_happy,"
    // Check if the string length is less than 3
    if (s.size() < 3) {
        return false;
    }

    // Check if every 3 consecutive letters are distinct
    for (int i = 0; i < s.size() - 2; i++) {
        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {
            return false;
        }
    }

    return true;"
1,1.0,HumanEval_80_is_happy,"
bool is_happy(std::string s) {
    if (s.size() < 3) return false;
    for (int i = 0; i < s.size() - 2; i++) {
        if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2]) return false;
    }
    return true;
"
0,0.0,HumanEval_80_is_happy,"
    if(s.length() < 3)
        return false;
    for(int i = 0; i < s.length() - 2; i++) {
        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2])
            return false;
    }
    return true;"
0,0.0,HumanEval_80_is_happy,"
    if (s.size() < 3) {
        return false;
    }
    for (int i = 0; i < s.size() - 2; i++) {
        if (s[i] == s[i + 1] || s[i + 1] == s[i + 2] || s[i] == s[i + 2]) {
            return false;
        }
    }
    return true;"
1,1.0,HumanEval_80_is_happy,"
bool is_happy(std::string s) {
    if (s.length() < 3) return false;

    for (int i = 0; i < s.length() - 2; i++) {
        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {
            return false;
        }
    }

    return true;
"
0,0.0,HumanEval_80_is_happy,"
    if (s.length() < 3) {
        return false;
    }
    for (int i = 0; i < s.length() - 2; i++) {
        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {
            return false;
        }
    }
    return true;"
1,1.0,HumanEval_80_is_happy,"
bool is_happy(std::string s) {
    if (s.length() < 3) {
        return false;
    }
    for (int i = 0; i < s.length() - 2; i++) {
        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {
            return false;
        }
    }
    return true;"
0,0.0,HumanEval_80_is_happy,"
    // Your code goes here
    if (s.length() < 3) {
        return false;
    }
    for (int i = 2; i < s.length(); i++) {
        if (s[i] == s[i-1] || s[i] == s[i-2] || s[i-1] == s[i-2]) {
            return false;
        }
    }
    return true;"
0,0.0,HumanEval_80_is_happy,"
    if(s.size() < 3) {
        return false;
    }

    for(int i = 0; i < s.size()-2; i++) {
        if(s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2]) {
            return false;
        }
    }

    return true;"
1,1.0,HumanEval_80_is_happy,"
bool is_happy(std::string s) {
    if(s.size() < 3)
        return false;

    for(int i = 0; i < s.size()-2; i++) {
        if(s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])
            return false;
    }
    return true;"
1,1.0,HumanEval_59_largest_prime_factor,"
long largest_prime_factor(long n) {
    long largest = -1;

    // Divide n by 2 until it is odd
    while (n % 2 == 0) {
        largest = 2;
        n >>= 1;
    }

    // n must be odd at this point, thus skip the even numbers and iterate only for odd
    for (long i = 3; i <= sqrt(n); i += 2) {
        // While i divides n, print i and divide n
        while (n % i == 0) {
            largest = i;
            n = n / i;
        }
    }

    // This condition is to handle the case when n is a prime number
    // greater than 2
    if (n > 2)
        largest = n;

    return largest;
"
0,1.0,HumanEval_59_largest_prime_factor,"
long largest_prime_factor(long n) {
    // Check if the number is a prime number
    if(n % 2 == 0){
        return -1;
    }

    // Divide n by 2 until it is no longer divisible
    while(n % 2 == 0){
        n /= 2;
    }

    // Find the largest prime factor by dividing n by all odd numbers starting from 3
    for(long i = 3; i <= sqrt(n); i += 2){
        while(n % i == 0){
            n /= i;
        }
    }

    // Return the largest prime factor
    return n;
"
0,0.0,HumanEval_59_largest_prime_factor,"
    long largest_prime = -1;

    // Divide n by 2 until n becomes odd
    while (n % 2 == 0) {
        largest_prime = 2;
        n >>= 1;
    }

    // n must be odd at this point, so find odd factors of n
    for (long i = 3; i <= sqrt(n); i += 2) {
        while (n % i == 0) {
            largest_prime = i;
            n = n / i;
        }
    }

    // This condition is to handle the case when n is a prime number
    // greater than 2
    if (n > 2)
        largest_prime = n;

    return largest_prime;
"
1,1.0,HumanEval_59_largest_prime_factor,"

long largest_prime_factor(long n) {
    long largest = -1;

    // Divide n by 2 until n becomes odd
    while (n % 2 == 0) {
        largest = 2;
        n >>= 1;
    }

    // n is now odd, so find odd factors of n
    for (long i = 3; i <= sqrt(n); i += 2) {
        while (n % i == 0) {
            largest = i;
            n = n / i;
        }
    }

    // This condition is to handle the case when n is a prime number
    // greater than 2
    if (n > 2)
        largest = n;

    return largest;
"
1,1.0,HumanEval_59_largest_prime_factor,"
long largest_prime_factor(long n) {
    long largest = -1;

    // Divide n by 2 until it is odd
    while (n % 2 == 0) {
        largest = 2;
        n >>= 1;
    }

    // n is now odd, find odd factors of n
    for (long i = 3; i <= sqrt(n); i += 2) {
        while (n % i == 0) {
            largest = i;
            n = n / i;
        }
    }

    // This condition is to handle the case when n is a prime number
    // greater than 2
    if (n > 2)
        largest = n;

    return largest;
"
1,1.0,HumanEval_59_largest_prime_factor,"
long largest_prime_factor(long n) {
    long max_prime = -1;

    while (n%2 == 0) {
        max_prime = 2;
        n >>= 1;
    }

    for (long i = 3; i <= sqrt(n); i += 2) {
        while (n%i == 0) {
            max_prime = i;
            n = n/i;
        }
    }

    if (n > 2)
        max_prime = n;

    return max_prime;
"
1,1.0,HumanEval_59_largest_prime_factor,"
long largest_prime_factor(long n) {
    long max_prime = -1;
  
    // Divide n by 2 until n becomes odd
    while (n%2 == 0) {
        max_prime = 2;
        n >>= 1;
    }
  
    // n must be odd at this point, thus skip the even numbers
    for (long i = 3; i <= sqrt(n); i += 2) {
        // While i divides n, print i and divide n
        while (n%i == 0) {
            max_prime = i;
            n = n/i;
        }
    }
  
    // This condition is to handle the case when n is a prime number
    // greater than 2
    if (n > 2)
        max_prime = n;
  
    return max_prime;"
1,1.0,HumanEval_59_largest_prime_factor,"
long largest_prime_factor(long n) {
    long largest = -1;

    // Divide n by 2 until n becomes odd
    while (n % 2 == 0) {
        largest = 2;
        n >>= 1;
    }

    // n must be odd at this point, thus skip the even numbers and iterate only for odd
    for (long i = 3; i <= sqrt(n); i += 2) {
        while (n % i == 0) {
            largest = i;
            n = n / i;
        }
    }

    // this condition is to handle the case when n is a prime number
    // greater than 2
    if (n > 2)
        largest = n;

    return largest;
"
1,1.0,HumanEval_59_largest_prime_factor,"
long largest_prime_factor(long n) {
    long largest = -1;

    // Divide n by 2 until n becomes odd
    while (n % 2 == 0) {
        largest = 2;
        n >>= 1;
    }

    // n must be odd at this point, thus skip the even numbers and iterate only for odd
    for (long i = 3; i <= sqrt(n); i += 2) {
        while (n % i == 0) {
            largest = i;
            n = n / i;
        }
    }

    // This condition is to handle the case when n is a prime number
    // greater than 2
    if (n > 2)
        largest = n;

    return largest;
"
1,1.0,HumanEval_59_largest_prime_factor,"

long largest_prime_factor(long n) {
    long largest = -1;

    // Divide n by 2 until n becomes odd
    while (n % 2 == 0) {
        largest = 2;
        n >>= 1;
    }

    // n must be odd at this point, thus skip the even numbers and iterate only for odd
    for (long i = 3; i <= sqrt(n); i += 2) {
        // while i divides n, print i and divide n
        while (n % i == 0) {
            largest = i;
            n = n / i;
        }
    }

    // This condition is to handle the case when n is a prime number greater than 2
    if (n > 2)
        largest = n;

    return largest;
"
0,0.0,HumanEval_66_digitSum,"
    long sum = 0;
    for(char c : s) {
        if(isupper(c)) {
            sum += (int)c;
        }
    }
    return sum;"
1,1.0,HumanEval_66_digitSum,"
long digitSum(std::string s) {
    long sum = 0;
    for(char& c : s) {
        if(isupper(c)) {
            sum += (long)c;
        }
    }
    return sum;
"
1,1.0,HumanEval_66_digitSum,"
long digitSum(std::string s) {
    long sum = 0;
    for (char& c : s) {
        if (isupper(c)) {
            sum += (long)c;
        }
    }
    return sum;"
1,1.0,HumanEval_66_digitSum,"
long digitSum(std::string s) {
    long sum = 0;
    for(char& c : s) {
        if(isupper(c)) {
            sum += int(c);
        }
    }
    return sum;
"
1,1.0,HumanEval_66_digitSum,"
long digitSum(std::string s) {
    long sum = 0;
    for(char c : s) {
        if(isupper(c)) {
            sum += (int)c;
        }
    }
    return sum;
"
1,1.0,HumanEval_66_digitSum,"
long digitSum(std::string s) {
    long sum = 0;
    for(char& c : s) {
        if(isupper(c)) {
            sum += (int)c;
        }
    }
    return sum;
"
1,1.0,HumanEval_66_digitSum,"
long digitSum(std::string s) {
    long sum = 0;
    for(char c : s) {
        if(isupper(c)) {
            sum += (int)c;
        }
    }
    return sum;"
1,1.0,HumanEval_66_digitSum,"
long digitSum(std::string s) {
    long sum = 0;
    for(char c : s) {
        if(isupper(c)) {
            sum += (long)c;
        }
    }
    return sum;"
0,0.0,HumanEval_66_digitSum,"
    long sum = 0;
    for (char c : s) {
        if (isupper(c)) {
            sum += (int)c;
        }
    }
    return sum;"
1,1.0,HumanEval_66_digitSum,"
long digitSum(std::string s) {
    long sum = 0;
    for (char c : s) {
        if (isupper(c)) {
            sum += int(c);
        }
    }
    return sum;
"
1,1.0,HumanEval_21_rescale_to_unit,"

std::vector<float> rescale_to_unit(std::vector<float> numbers) {
    assert(numbers.size() >= 2);

    auto minmax = std::minmax_element(numbers.begin(), numbers.end());
    float min_val = *minmax.first;
    float max_val = *minmax.second;
    float range = max_val - min_val;

    for(size_t i = 0; i < numbers.size(); ++i) {
        numbers[i] = (numbers[i] - min_val) / range;
    }

    return numbers;"
1,1.0,HumanEval_21_rescale_to_unit,"

std::vector<float> rescale_to_unit(std::vector<float> numbers) {
    assert(numbers.size() >= 2);

    auto minmax = minmax_element(numbers.begin(), numbers.end());
    float min_val = *minmax.first;
    float max_val = *minmax.second;

    for(size_t i = 0; i < numbers.size(); ++i) {
        numbers[i] = (numbers[i] - min_val) / (max_val - min_val);
    }

    return numbers;
"
0,0.0,HumanEval_21_rescale_to_unit,"
    assert(numbers.size() >= 2);
    auto minmax = std::minmax_element(numbers.begin(), numbers.end());
    float min_val = *minmax.first;
    float max_val = *minmax.second;
    float range = max_val - min_val;

    for (size_t i = 0; i < numbers.size(); ++i) {
        numbers[i] = (numbers[i] - min_val) / range;
    }

    return numbers;"
0,1.0,HumanEval_21_rescale_to_unit,"
    assert(numbers.size() >= 2);

    auto minmax = std::minmax_element(numbers.begin(), numbers.end());
    float min_val = *minmax.first;
    float max_val = *minmax.second;
    float range = max_val - min_val;

    for (size_t i = 0; i < numbers.size(); ++i) {
        numbers[i] = (numbers[i] - min_val) / range;
    }

    return numbers;"
1,1.0,HumanEval_21_rescale_to_unit,"

std::vector<float> rescale_to_unit(std::vector<float> numbers) {
    assert(numbers.size() >= 2);
    auto minmax = std::minmax_element(numbers.begin(), numbers.end());
    float min_val = *minmax.first;
    float max_val = *minmax.second;
    float range = max_val - min_val;
    for (size_t i = 0; i < numbers.size(); ++i) {
        numbers[i] = (numbers[i] - min_val) / range;
    }
    return numbers;"
1,1.0,HumanEval_21_rescale_to_unit,"

std::vector<float> rescale_to_unit(std::vector<float> numbers) {
    assert(numbers.size() >= 2);

    auto minmax = std::minmax_element(numbers.begin(), numbers.end());
    float min_val = *minmax.first;
    float max_val = *minmax.second;

    float range = max_val - min_val;

    for (size_t i = 0; i < numbers.size(); ++i) {
        numbers[i] = (numbers[i] - min_val) / range;
    }

    return numbers;"
1,1.0,HumanEval_21_rescale_to_unit,"

std::vector<float> rescale_to_unit(std::vector<float> numbers) {
    assert(numbers.size() >= 2);

    auto minmax = std::minmax_element(numbers.begin(), numbers.end());
    float min_val = *minmax.first;
    float max_val = *minmax.second;
    float range = max_val - min_val;

    for(size_t i = 0; i < numbers.size(); ++i) {
        numbers[i] = (numbers[i] - min_val) / range;
    }

    return numbers;
"
1,1.0,HumanEval_21_rescale_to_unit,"

std::vector<float> rescale_to_unit(std::vector<float> numbers) {
    assert(numbers.size() >= 2);

    auto minmax = std::minmax_element(numbers.begin(), numbers.end());
    float min_val = *minmax.first;
    float max_val = *minmax.second;
    float range = max_val - min_val;

    for(size_t i = 0; i < numbers.size(); ++i) {
        numbers[i] = (numbers[i] - min_val) / range;
    }

    return numbers;"
1,1.0,HumanEval_21_rescale_to_unit,"

std::vector<float> rescale_to_unit(std::vector<float> numbers) {
    assert(numbers.size() >= 2); // Ensure that the vector has at least two elements

    // Find the minimum and maximum values in the vector
    float min_val = *std::min_element(numbers.begin(), numbers.end());
    float max_val = *std::max_element(numbers.begin(), numbers.end());

    // Calculate the range of the values
    float range = max_val - min_val;

    // Apply the transformation to each element in the vector
    for (size_t i = 0; i < numbers.size(); ++i) {
        numbers[i] = (numbers[i] - min_val) / range;
    }

    return numbers;
"
1,1.0,HumanEval_21_rescale_to_unit,"

std::vector<float> rescale_to_unit(std::vector<float> numbers) {
    assert(numbers.size() >= 2);

    float min_val = *std::min_element(numbers.begin(), numbers.end());
    float max_val = *std::max_element(numbers.begin(), numbers.end());

    for (size_t i = 0; i < numbers.size(); ++i) {
        numbers[i] = (numbers[i] - min_val) / (max_val - min_val);
    }

    return numbers;"
1,1.0,HumanEval_121_solution,"
long solution(std::vector<long> lst) {
    long sum = 0;
    for (size_t i = 0; i < lst.size(); i += 2) {
        if (lst[i] % 2 != 0) {
            sum += lst[i];
        }
    }
    return sum;"
1,1.0,HumanEval_121_solution,"
long solution(std::vector<long> lst) {
    long sum = 0;
    for (int i = 0; i < lst.size(); i++) {
        if (i % 2 == 0 && lst[i] % 2 != 0) {
            sum += lst[i];
        }
    }
    return sum;"
0,0.0,HumanEval_121_solution,"
    long sum = 0;
    for (int i = 0; i < lst.size(); i += 2) {
        if (lst[i] % 2 != 0) {
            sum += lst[i];
        }
    }
    return sum;"
1,1.0,HumanEval_121_solution,"
long solution(std::vector<long> lst) {
    long sum = 0;
    for(int i = 0; i < lst.size(); i++) {
        if(i % 2 == 0 && lst[i] % 2 != 0) {
            sum += lst[i];
        }
    }
    return sum;
"
1,1.0,HumanEval_121_solution,"

long solution(std::vector<long> lst) {
    long sum = 0;
    for (int i = 0; i < lst.size(); i++) {
        if (i % 2 == 0 && lst[i] % 2 != 0) {
            sum += lst[i];
        }
    }
    return sum;
"
0,0.0,HumanEval_121_solution,"
    long sum = 0;
    for (int i = 0; i < lst.size(); i += 2) {
        if (lst[i] % 2 != 0) {
            sum += lst[i];
        }
    }
    return sum;"
1,1.0,HumanEval_121_solution,"
long solution(std::vector<long> lst) {
    long sum = 0;
    for(int i = 0; i < lst.size(); i++) {
        if(i % 2 == 0 && lst[i] % 2 != 0) {
            sum += lst[i];
        }
    }
    return sum;"
1,1.0,HumanEval_121_solution,"
long solution(std::vector<long> lst) {
    long sum = 0;
    for(int i = 0; i < lst.size(); i++) {
        if(i % 2 == 0 && lst[i] % 2 == 1) {
            sum += lst[i];
        }
    }
    return sum;"
1,1.0,HumanEval_121_solution,"
long solution(std::vector<long> lst) {
    long sum = 0;
    for (size_t i = 0; i < lst.size(); i += 2) {
        if (lst[i] % 2 != 0) {
            sum += lst[i];
        }
    }
    return sum;"
0,0.0,HumanEval_121_solution,"
    long sum = 0;
    for (int i = 0; i < lst.size(); i++) {
        if (i % 2 == 0 && lst[i] % 2 != 0) {
            sum += lst[i];
        }
    }
    return sum;"
1,1.0,HumanEval_68_pluck,"

std::vector<long> pluck(std::vector<long> arr) {
    long min_even = LONG_MAX;
    long min_index = LONG_MAX;
    for (long i = 0; i < arr.size(); i++) {
        if (arr[i] < min_even && arr[i] % 2 == 0) {
            min_even = arr[i];
            min_index = i;
        }
    }
    if (min_even == LONG_MAX) {
        return {};
    } else {
        return {min_even, min_index};
    }"
1,1.0,HumanEval_68_pluck,"

std::vector<long> pluck(std::vector<long> arr) {
    long smallest_even = LONG_MAX;
    long smallest_even_index = -1;
    for(long i = 0; i < arr.size(); i++) {
        if(arr[i] % 2 == 0 && arr[i] < smallest_even) {
            smallest_even = arr[i];
            smallest_even_index = i;
        }
    }
    if(smallest_even_index == -1) {
        return {};
    }
    return {smallest_even, smallest_even_index};
"
0,0.0,HumanEval_68_pluck,"
    std::vector<long> result;
    long smallest_even = LONG_MAX;
    long smallest_index = LONG_MAX;

    for (long i = 0; i < arr.size(); i++) {
        if (arr[i] < smallest_even && arr[i] % 2 == 0) {
            smallest_even = arr[i];
            smallest_index = i;
        }
    }

    if (smallest_even != LONG_MAX) {
        result.push_back(smallest_even);
        result.push_back(smallest_index);
    }

    return result;
"
1,1.0,HumanEval_68_pluck,"
std::vector<long> pluck(std::vector<long> arr) {
    long smallestEvenValue = LONG_MAX;
    long smallestEvenIndex = -1;
    for (size_t i = 0; i < arr.size(); ++i) {
        if (arr[i] < smallestEvenValue && arr[i] % 2 == 0) {
            smallestEvenValue = arr[i];
            smallestEvenIndex = i;
        }
    }
    if (smallestEvenIndex == -1) {
        return {};
    } else {
        return {smallestEvenValue, smallestEvenIndex};
    }
"
1,1.0,HumanEval_68_pluck,"
std::vector<long> pluck(std::vector<long> arr) {
    long smallest_even = LONG_MAX;
    long smallest_even_index = -1;
    for (long i = 0; i < arr.size(); i++) {
        if (arr[i] < smallest_even && arr[i] % 2 == 0) {
            smallest_even = arr[i];
            smallest_even_index = i;
        }
    }
    if (smallest_even_index == -1) {
        return {};
    } else {
        return {smallest_even, smallest_even_index};
    }"
1,1.0,HumanEval_68_pluck,"
std::vector<long> pluck(std::vector<long> arr) {
    long minEvenValue = LONG_MAX;
    long minEvenIndex = LONG_MAX;
    for (long i = 0; i < arr.size(); i++) {
        if (arr[i] < minEvenValue && arr[i] % 2 == 0) {
            minEvenValue = arr[i];
            minEvenIndex = i;
        }
    }
    if (minEvenValue == LONG_MAX) {
        return {};
    } else {
        return {minEvenValue, minEvenIndex};
    }"
0,0.0,HumanEval_68_pluck,"
    // Your code here
    long min_even = LONG_MAX;
    long min_index = LONG_MAX;

    for (long i = 0; i < arr.size(); i++) {
        if (arr[i] < min_even && arr[i] % 2 == 0) {
            min_even = arr[i];
            min_index = i;
        }
    }

    if (min_even == LONG_MAX) {
        return {};
    } else {
        return {min_even, min_index};
    }"
1,1.0,HumanEval_68_pluck,"

std::vector<long> pluck(std::vector<long> arr) {
    long min_even = LONG_MAX;
    long min_index = LONG_MAX;
    for (long i = 0; i < arr.size(); ++i) {
        if (arr[i] < min_even && arr[i] % 2 == 0) {
            min_even = arr[i];
            min_index = i;
        }
    }
    if (min_even == LONG_MAX) {
        return {};
    }
    return {min_even, min_index};"
1,1.0,HumanEval_68_pluck,"
std::vector<long> pluck(std::vector<long> arr) {
    long smallest_even = LONG_MAX;
    int smallest_even_index = -1;
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {
            smallest_even = arr[i];
            smallest_even_index = i;
        }
    }
    if (smallest_even_index == -1) {
        return {};
    } else {
        return {smallest_even, smallest_even_index};
    }"
0,0.0,HumanEval_68_pluck,"
    long min_even = LONG_MAX;
    long min_index = LONG_MAX;
    for (long i = 0; i < arr.size(); i++) {
        if (arr[i] < min_even && arr[i] % 2 == 0) {
            min_even = arr[i];
            min_index = i;
        }
    }
    if (min_even == LONG_MAX) {
        return {};
    } else {
        return {min_even, min_index};
    }
"
1,1.0,HumanEval_147_get_max_triples,"
long get_max_triples(long n) {
    long count = 0;
    std::vector<long> a(n);
    for (long i = 1; i <= n; i++) {
        a[i-1] = i*i - i + 1;
    }
    for (long i = 0; i < n; i++) {
        for (long j = i+1; j < n; j++) {
            for (long k = j+1; k < n; k++) {
                if ((a[i] + a[j] + a[k]) % 3 == 0) {
                    count++;
                }
            }
        }
    }
    return count;"
0,0.0,HumanEval_147_get_max_triples,"
long get_max_triples(long n) {
    std::vector<long> a(n);
    for (long i = 1; i <= n; ++i) {
        a[i-1] = i * i - i + 1;
    }
    std::vector<long> count(3, 0);
    for (long i = 0; i < n; ++i) {
        ++count[a[i] % 3];
    }
    long res = count[0]*(count[0]-1)*(count[0]-2)/6 + count[1]*count[2];
    return res;
"
0,0.0,HumanEval_147_get_max_triples,"
    long count = 0;
    std::vector<long> a(n);
    for (long i = 1; i <= n; i++) {
        a[i-1] = i * i - i + 1;
    }
    std::vector<long> remainderCount(3, 0);
    for (long i = 0; i < n; i++) {
        remainderCount[a[i] % 3]++;
    }
    count += remainderCount[0]*(remainderCount[0]-1)*(remainderCount[0]-2)/6;
    count += remainderCount[1]*remainderCount[2];
    count += remainderCount[0]*(remainderCount[0]-1)*(remainderCount[0]-2)/6;
    return count;"
0,0.0,HumanEval_147_get_max_triples,"
long get_max_triples(long n) {
    std::vector<long> a(n);
    for(long i = 1; i <= n; i++) {
        a[i-1] = i * i - i + 1;
    }
    
    std::vector<long> remainders(3, 0);
    for(long i = 0; i < n; i++) {
        remainders[a[i] % 3]++;
    }
    
    long count = 0;
    count += remainders[0]*(remainders[0]-1)*(remainders[0]-2)/6; // choose 3 numbers from remainder0
    count += remainders[1]*remainders[2]*(remainders[0]); // choose 1 number from remainder1 and 1 number from remainder2, then choose 1 number from remainder0
    count += remainders[1]*(remainders[1]-1)*(remainders[1]-2)/6; // choose 3 numbers from remainder1
    count += remainders[2]*(remainders[2]-1)*(remainders[2]-2)/6; // choose 3 numbers from remainder2
    count += remainders[0]*(remainders[0]-1)/2*remainders[1]; // choose 2 numbers from remainder0 and 1 number from remainder1
    count += remainders[0]*(remainders[0]-1)/2*remainders[2]; // choose 2 numbers from remainder0 and 1 number from remainder2
    
    return count;"
1,0.0,HumanEval_147_get_max_triples,"
long get_max_triples(long n) {
    std::vector<long> a(n);
    long count = 0;
    for (long i = 1; i <= n; ++i) {
        a[i-1] = i * i - i + 1;
    }
    std::vector<long> mod_count(3, 0);
    for (long i = 0; i < n; ++i) {
        ++mod_count[a[i] % 3];
    }
    count += mod_count[0]*(mod_count[0]-1)*(mod_count[0]-2)/6;
    count += mod_count[1]*mod_count[2]*(mod_count[0]);
    count += mod_count[1]*(mod_count[1]-1)*(mod_count[1]-2)/6;
    count += mod_count[2]*(mod_count[2]-1)*(mod_count[2]-2)/6;
    return count;"
0,0.0,HumanEval_147_get_max_triples,"
    long count = 0;
    std::vector<long> a(n);
    for (long i = 1; i <= n; i++) {
        a[i-1] = i * i - i + 1;
    }
    std::vector<long> remainders(3, 0);
    for (long i = 0; i < n; i++) {
        remainders[a[i] % 3]++;
    }
    count += (remainders[0]*(remainders[0]-1)*(remainders[0]-2))/6; // 3 numbers from the same remainder
    count += (remainders[1]*remainders[2]*(remainders[0])); // 1 number from remainder 1 and 1 number from remainder 2
    count += (remainders[1]*(remainders[1]-1)*(remainders[1]-2))/6; // 3 numbers from the same remainder
    count += (remainders[2]*(remainders[2]-1)*(remainders[2]-2))/6; // 3 numbers from the same remainder
    return count;
"
1,1.0,HumanEval_147_get_max_triples,"
long get_max_triples(long n) {
    assert(n >= 1);
    long count = 0;
    std::vector<long> a(n);

    for (long i = 1; i <= n; i++) {
        a[i-1] = i * i - i + 1;
    }

    for (long i = 0; i < n; i++) {
        for (long j = i+1; j < n; j++) {
            for (long k = j+1; k < n; k++) {
                if ((a[i] + a[j] + a[k]) % 3 == 0) {
                    count++;
                }
            }
        }
    }

    return count;
"
0,0.0,HumanEval_147_get_max_triples,"
long get_max_triples(long n) {
    assert(n >= 1);

    long count = 0;
    std::vector<long> a(n);

    for (long i = 1; i <= n; i++) {
        a[i - 1] = i * i - i + 1;
    }

    std::vector<long> mod0(n, 0), mod1(n, 0), mod2(n, 0);

    for (long i = 0; i < n; i++) {
        mod0[i] = (i > 0 ? mod0[i - 1] : 0) + (a[i] % 3 == 0);
        mod1[i] = (i > 0 ? mod1[i - 1] : 0) + (a[i] % 3 == 1);
        mod2[i] = (i > 0 ? mod2[i - 1] : 0) + (a[i] % 3 == 2);
    }

    for (long i = 0; i < n; i++) {
        if (a[i] % 3 == 0) {
            count += mod2[i] + mod1[i] + (i > 0 ? mod0[i - 1] : 0);
        }
        else if (a[i] % 3 == 1) {
            count += mod0[i] + mod2[i] + (i > 0 ? mod1[i - 1] : 0);
        }
        else {
            count += mod1[i] + mod0[i] + (i > 0 ? mod2[i - 1] : 0);
        }
    }

    return count;"
0,0.0,HumanEval_147_get_max_triples,"
long get_max_triples(long n) {
    std::vector<long> a(n);
    for (long i = 1; i <= n; ++i)
        a[i-1] = i * i - i + 1;

    long count = 0;
    std::vector<long> mods(3, 0);
    for (long num : a)
        ++mods[num % 3];

    count += mods[0]*(mods[0]-1)*(mods[0]-2)/6; // choose 3 numbers from mods[0]
    count += mods[1]*(mods[1]-1)*(mods[1]-2)/6; // choose 3 numbers from mods[1]
    count += mods[2]*(mods[2]-1)*(mods[2]-2)/6; // choose 3 numbers from mods[2]
    count += mods[0]*(mods[0]-1)/2*mods[1]; // choose 2 numbers from mods[0] and 1 number from mods[1]
    count += mods[0]*(mods[0]-1)/2*mods[2]; // choose 2 numbers from mods[0] and 1 number from mods[2]
    count += mods[1]*(mods[1]-1)/2*mods[2]; // choose 2 numbers from mods[1] and 1 number from mods[2]
    count += mods[0]*mods[1]*mods[2]; // choose 1 number from each mods

    return count;"
0,0.0,HumanEval_147_get_max_triples,"
    long result = 0;
    std::vector<long> a(n);
    for (long i = 1; i <= n; ++i) {
        a[i-1] = i * i - i + 1;
    }
    std::vector<long> mod0(n, 0), mod1(n, 0), mod2(n, 0);
    for (long i = 0; i < n; ++i) {
        mod0[i] = (i > 0 ? mod0[i-1] : 0) + (a[i] % 3 == 0);
        mod1[i] = (i > 0 ? mod1[i-1] : 0) + (a[i] % 3 == 1);
        mod2[i] = (i > 0 ? mod2[i-1] : 0) + (a[i] % 3 == 2);
    }
    for (long i = 0; i < n; ++i) {
        if (a[i] % 3 == 0) {
            result += mod1[i] + mod2[i] + (i > 0 ? mod0[i-1] : 0);
        } else if (a[i] % 3 == 1) {
            result += mod2[i] + (i > 0 ? mod1[i-1] : 0) + (i > 1 ? mod0[i-2] : 0);
        } else {
            result += mod1[i] + (i > 0 ? mod2[i-1] : 0) + (i > 1 ? mod0[i-2] : 0);
        }
    }
    return result;
"
1,0.0,HumanEval_110_exchange,"
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
    int odd1 = 0, odd2 = 0;
    for(int i = 0; i < lst1.size(); i++) {
        if(lst1[i] % 2 != 0) odd1++;
    }
    for(int i = 0; i < lst2.size(); i++) {
        if(lst2[i] % 2 != 0) odd2++;
    }
    if(odd1 == 0) return ""YES"";
    if(odd2 == 0) return ""YES"";
    if(odd1 % 2 == 0 && odd2 % 2 == 0) return ""YES"";
    return ""NO"";
"
0,0.0,HumanEval_110_exchange,"

std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
    int odd_lst1 = 0, odd_lst2 = 0;
    for (long num : lst1) {
        if (num % 2 != 0) {
            odd_lst1++;
        }
    }
    for (long num : lst2) {
        if (num % 2 != 0) {
            odd_lst2++;
        }
    }
    if (odd_lst1 > odd_lst2) {
        return ""NO"";
    } else {
        return ""YES"";
    }
"
0,0.0,HumanEval_110_exchange,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

string exchange(vector<long> lst1, vector<long> lst2) {
    int odd1 = 0, odd2 = 0;
    for(int i = 0; i < lst1.size(); i++) {
        if(lst1[i] % 2 != 0) 
            odd1++;
    }
    for(int i = 0; i < lst2.size(); i++) {
        if(lst2[i] % 2 != 0) 
            odd2++;
    }

    if(odd1 > odd2)
        return ""NO"";
    else
        return ""YES"";
"
0,0.0,HumanEval_110_exchange,"

std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
    int odd1 = 0, odd2 = 0;
    for(int i=0; i<lst1.size(); i++) {
        if(lst1[i] % 2 != 0) odd1++;
    }
    for(int i=0; i<lst2.size(); i++) {
        if(lst2[i] % 2 != 0) odd2++;
    }
    if(odd1 > odd2) {
        return ""NO"";
    }
    return ""YES"";
"
0,0.0,HumanEval_110_exchange,"

std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
    int odd1 = 0, odd2 = 0;
    for(int i=0; i<lst1.size(); i++){
        if(lst1[i] % 2 != 0)
            odd1++;
    }
    for(int i=0; i<lst2.size(); i++){
        if(lst2[i] % 2 != 0)
            odd2++;
    }
    if(odd1 > odd2)
        return ""NO"";
    else
        return ""YES"";
"
0,0.0,HumanEval_110_exchange,"
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
    int odd1 = 0, odd2 = 0;
    for (int i = 0; i < lst1.size(); i++) {
        if (lst1[i] % 2 != 0)
            odd1++;
    }
    for (int i = 0; i < lst2.size(); i++) {
        if (lst2[i] % 2 != 0)
            odd2++;
    }
    if (odd1 > odd2)
        return ""NO"";
    else
        return ""YES"";"
0,0.0,HumanEval_110_exchange,"

std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
    int odd1 = 0, odd2 = 0;
    for(int i = 0; i < lst1.size(); i++) {
        if(lst1[i] % 2 != 0)
            odd1++;
    }
    for(int i = 0; i < lst2.size(); i++) {
        if(lst2[i] % 2 != 0)
            odd2++;
    }
    if(odd1 > odd2)
        return ""NO"";
    else
        return ""YES"";"
0,0.0,HumanEval_110_exchange,"
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
    bool hasOdd = false;
    for (long num : lst1) {
        if (num % 2 != 0) {
            hasOdd = true;
            break;
        }
    }

    if (!hasOdd) {
        return ""YES"";
    }

    for (long num : lst2) {
        if (num % 2 == 0) {
            return ""YES"";
        }
    }

    return ""NO"";
"
0,0.0,HumanEval_110_exchange,"

std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
    int odd1 = 0, odd2 = 0;
    for(int i = 0; i < lst1.size(); i++) {
        if(lst1[i] % 2 != 0) {
            odd1++;
        }
    }
    for(int i = 0; i < lst2.size(); i++) {
        if(lst2[i] % 2 != 0) {
            odd2++;
        }
    }
    if(odd1 == 0) {
        return ""YES"";
    }
    if(odd2 == 0) {
        return ""NO"";
    }
    if(odd1 > odd2) {
        return ""NO"";
    }
    return ""YES"";
"
0,0.0,HumanEval_110_exchange,"

std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
    int odd1 = 0, odd2 = 0;
    for (long num : lst1) {
        if (num % 2 != 0) {
            odd1++;
        }
    }
    for (long num : lst2) {
        if (num % 2 != 0) {
            odd2++;
        }
    }
    if (odd1 > odd2) {
        return ""NO"";
    } else {
        return ""YES"";
    }
"
0,0.0,HumanEval_47_median,"
    // Sort the vector
    std::sort(l.begin(), l.end());

    // Compute the median
    int n = l.size();
    if (n % 2 == 0) {
        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;
    } else {
        return l[n / 2];
    }"
1,1.0,HumanEval_47_median,"
float median(std::vector<long> l) {
    sort(l.begin(), l.end());
    int n = l.size();
    if (n % 2 == 0)
        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;
    else
        return l[n / 2];
"
1,1.0,HumanEval_47_median,"

float median(std::vector<long> l) {
    size_t size = l.size();

    // Check if the vector is empty
    assert(size != 0);

    // Sort the vector
    std::sort(l.begin(), l.end());

    // If the size of the vector is even
    if (size % 2 == 0) {
        return (l[size / 2 - 1] + l[size / 2]) / 2.0f;
    }
    // If the size of the vector is odd
    else {
        return l[size / 2];
    }"
1,1.0,HumanEval_47_median,"

float median(std::vector<long> l) {
    assert(!l.empty());
    std::sort(l.begin(), l.end());
    if (l.size() % 2 == 0) {
        return (l[l.size() / 2 - 1] + l[l.size() / 2]) / 2.0f;
    } else {
        return l[l.size() / 2];
    }"
0,0.0,HumanEval_47_median,"
    assert(l.size() > 0);
    std::sort(l.begin(), l.end());
    if (l.size() % 2 == 0) {
        return (l[l.size() / 2 - 1] + l[l.size() / 2]) / 2.0f;
    } else {
        return l[l.size() / 2];
    }"
1,1.0,HumanEval_47_median,"
float median(std::vector<long> l) {
    size_t size = l.size();

    // check if the size of the vector is 0
    assert(size != 0);

    std::sort(l.begin(), l.end());

    if (size % 2 == 0)
        return (l[size / 2 - 1] + l[size / 2]) / 2.0f;
    else
        return l[size / 2];"
1,1.0,HumanEval_47_median,"

float median(std::vector<long> l) {
    size_t size = l.size();

    // Check if the vector is empty
    assert(size != 0);

    // Sort the vector
    std::sort(l.begin(), l.end());

    // If the size of the vector is even, return the average of the two middle elements
    if (size % 2 == 0) {
        return (l[size / 2 - 1] + l[size / 2]) / 2.0f;
    }
    // If the size of the vector is odd, return the middle element
    else {
        return l[size / 2];
    }
"
1,1.0,HumanEval_47_median,"

float median(std::vector<long> l) {
    size_t size = l.size();

    // Sort the vector
    std::sort(l.begin(), l.end());

    if (size % 2 != 0) {
        // If the size is odd, return the middle element
        return l[size / 2];
    } else {
        // If the size is even, return the average of the two middle elements
        return (l[(size - 1) / 2] + l[size / 2]) / 2.0f;
    }
"
1,1.0,HumanEval_47_median,"

float median(std::vector<long> l) {
    size_t size = l.size();
    assert(size != 0);

    std::sort(l.begin(), l.end());

    if (size % 2 == 0)
        return (l[size / 2 - 1] + l[size / 2]) / 2.0f;
    else
        return l[size / 2];
"
1,1.0,HumanEval_47_median,"

float median(std::vector<long> l) {
    size_t size = l.size();
    assert(size > 0);

    std::sort(l.begin(), l.end());

    if (size % 2 == 0) {
        return (l[size / 2 - 1] + l[size / 2]) / 2.0f;
    } else {
        return l[size / 2];
    }
"
0,1.0,HumanEval_82_prime_length,"
bool prime_length(std::string string) {
    return isPrime(string.length());
"
1,1.0,HumanEval_82_prime_length,"
#include<assert.h>
#include<bits/stdc++.h>

bool isPrime(int n) {
    if (n <= 1)  return false;
    if (n <= 3)  return true;
  
    if (n%2 == 0 || n%3 == 0)
        return false;
  
    for (int i=5; i*i<=n; i=i+6)
        if (n%i == 0 || n%(i+2) == 0)
            return false;
  
    return true;
}

bool prime_length(std::string str) {
    int length = str.length();
    return isPrime(length);
"
0,0.0,HumanEval_82_prime_length,"
    int n = string.length();
    if (n <= 1)
        return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0)
            return false;
    }
    return true;"
1,1.0,HumanEval_82_prime_length,"
#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(int n) {
    if (n <= 1)
        return false;
    if (n == 2)
        return true;
    if (n % 2 == 0)
        return false;
    for (int i = 3; i * i <= n; i += 2)
        if (n % i == 0)
            return false;
    return true;
}

bool prime_length(std::string str) {
    int length = str.length();
    return is_prime(length);"
1,1.0,HumanEval_82_prime_length,"
#include<assert.h>
#include<bits/stdc++.h>

bool prime_length(std::string str) {
    int length = str.length();
    if (length <= 1)
        return false;
    for (int i = 2; i * i <= length; i++) {
        if (length % i == 0)
            return false;
    }
    return true;
"
0,1.0,HumanEval_82_prime_length,"

bool prime_length(std::string string) {
    return is_prime(string.length());
"
0,0.0,HumanEval_82_prime_length,"
    int n = string.length();
    if (n <= 1)
        return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0)
            return false;
    }
    return true;"
1,1.0,HumanEval_82_prime_length,"
#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(int n) {
    if (n <= 1) 
        return false; 
    if (n == 2) 
        return true; 
    if (n % 2 == 0) 
        return false; 
    for (int i = 3; i * i <= n; i += 2) 
        if (n % i == 0) 
            return false; 
    return true; 
}

bool prime_length(std::string str) {
    int len = str.length();
    return is_prime(len);"
1,1.0,HumanEval_82_prime_length,"
#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(int n) {
    if (n <= 1)
        return false;
    if (n <= 3)
        return true;
    if (n % 2 == 0 || n % 3 == 0)
        return false;
    for (int i = 5; i * i <= n; i = i + 6)
        if (n % i == 0 || n % (i + 2) == 0)
            return false;
    return true;
}

bool prime_length(std::string str) {
    int length = str.length();
    return is_prime(length);
"
0,0.0,HumanEval_82_prime_length,"
    // Function to check if a number is prime
    auto is_prime = [](int num) {
        if (num <= 1) return false;
        if (num == 2) return true;
        if (num % 2 == 0) return false;
        for (int i = 3; i * i <= num; i += 2) {
            if (num % i == 0) return false;
        }
        return true;
    };

    // Get the length of the string
    int len = string.length();

    // Check if the length is prime
    return is_prime(len);"
1,1.0,HumanEval_73_smallest_change,"
long smallest_change(std::vector<long> arr) {
    long changes = 0;
    for (long i = 0; i < arr.size() / 2; i++) {
        if (arr[i] != arr[arr.size() - 1 - i]) {
            changes++;
        }
    }
    return changes;"
0,1.0,HumanEval_73_smallest_change,"
long smallest_change(std::vector<long> arr) {
    long n = arr.size();
    long changes = 0;
    for(long i = 0; i <= n/2; i++) {
        if(arr[i] != arr[n-i-1]) {
            changes++;
        }
    }
    return changes;"
1,1.0,HumanEval_73_smallest_change,"

long smallest_change(std::vector<long> arr) {
    int n = arr.size();
    int changes = 0;
    for(int i=0; i<n/2; i++) {
        if(arr[i] != arr[n-1-i]) {
            changes++;
        }
    }
    return changes;
"
0,1.0,HumanEval_73_smallest_change,"
long smallest_change(std::vector<long> arr) {
    int n = arr.size();
    int count = 0;
    for(int i = 0; i <= n/2; i++) {
        if(arr[i] != arr[n-i-1]) {
            count++;
        }
    }
    return count;"
0,1.0,HumanEval_73_smallest_change,"

long smallest_change(std::vector<long> arr) {
    int n = arr.size();
    int changes = 0;
    for(int i = 0; i <= n/2; i++) {
        if(arr[i] != arr[n-i-1]) {
            changes++;
        }
    }
    return changes;"
1,1.0,HumanEval_73_smallest_change,"

long smallest_change(std::vector<long> arr) {
    int n = arr.size();
    int changes = 0;

    for(int i = 0; i < (n+1)/2; i++) {
        if(arr[i] != arr[n-i-1]) {
            changes++;
        }
    }

    return changes;
"
1,1.0,HumanEval_73_smallest_change,"

long smallest_change(std::vector<long> arr) {
    long n = arr.size();
    long changes = 0;
    for (long i = 0; i < (n+1)/2; ++i) {
        if (arr[i] != arr[n-1-i]) {
            ++changes;
        }
    }
    return changes;"
1,0.0,HumanEval_73_smallest_change,"

long smallest_change(std::vector<long> arr) {
    int n = arr.size();
    int changes = 0;

    // Two pointers, one at the beginning and one at the end of the array
    int i = 0, j = n - 1;

    // While the two pointers do not cross
    while(i <= j) {
        // If the elements at the two pointers are not equal
        if(arr[i] != arr[j]) {
            // Increment the number of changes
            changes++;
        }
        // Move the pointers towards the center
        i++;
        j--;
    }

    // Return the number of changes
    return changes;
"
0,0.0,HumanEval_73_smallest_change,"
    long n = arr.size();
    long count = 0;
    for(long i = 0; i <= n/2; i++) {
        if(arr[i] != arr[n-i-1]) {
            count++;
        }
    }
    return count;"
1,1.0,HumanEval_73_smallest_change,"

long smallest_change(std::vector<long> arr) {
    long n = arr.size();
    long changes = 0;
    for(long i = 0; i < n/2; i++) {
        if(arr[i] != arr[n-1-i]) {
            changes++;
        }
    }
    return changes;
"
1,1.0,HumanEval_133_sum_squares,"

long sum_squares(std::vector<float> lst) {
    long sum = 0;
    for (float num : lst) {
        sum += std::ceil(num)*std::ceil(num);
    }
    return sum;
"
1,1.0,HumanEval_133_sum_squares,"

long sum_squares(std::vector<float> lst) {
    long sum = 0;
    for(int i = 0; i < lst.size(); i++) {
        sum += (long)ceil(lst[i]) * (long)ceil(lst[i]);
    }
    return sum;"
1,1.0,HumanEval_133_sum_squares,"

long sum_squares(std::vector<float> lst) {
    long sum = 0;
    for(float num : lst) {
        sum += std::ceil(num)*std::ceil(num);
    }
    return sum;"
1,1.0,HumanEval_133_sum_squares,"

long sum_squares(std::vector<float> lst) {
    long sum = 0;
    for (float num : lst) {
        num = ceil(num);
        sum += num * num;
    }
    return sum;"
1,1.0,HumanEval_133_sum_squares,"

long sum_squares(std::vector<float> lst) {
    long sum = 0;
    for (float num : lst) {
        int ceil_num = ceil(num);
        sum += ceil_num * ceil_num;
    }
    return sum;"
1,1.0,HumanEval_133_sum_squares,"

long sum_squares(std::vector<float> lst) {
    long sum = 0;
    for(float num : lst) {
        sum += std::ceil(num)*std::ceil(num);
    }
    return sum;"
0,0.0,HumanEval_133_sum_squares,"
    long sum = 0;
    for (float num : lst) {
        num = ceil(num);
        sum += num * num;
    }
    return sum;"
1,1.0,HumanEval_133_sum_squares,"

long sum_squares(std::vector<float> lst) {
    long sum = 0;
    for(auto &num : lst) {
        num = ceil(num);
        sum += num * num;
    }
    return sum;
"
1,1.0,HumanEval_133_sum_squares,"

long sum_squares(std::vector<float> lst) {
    long sum = 0;
    for(auto& num : lst) {
        num = ceil(num);
        sum += num * num;
    }
    return sum;"
1,1.0,HumanEval_133_sum_squares,"

long sum_squares(std::vector<float> lst) {
    long sum = 0;
    for(int i=0; i<lst.size(); i++) {
        sum += std::ceil(lst[i]) * std::ceil(lst[i]);
    }
    return sum;
"
1,0.0,HumanEval_141_file_name_check,"
std::string file_name_check(std::string file_name) {
    int count = 0;
    for (char c : file_name) {
        if (isdigit(c)) {
            count++;
        }
    }
    if (count > 3) {
        return ""No"";
    }
    
    size_t dot_position = file_name.find('.');
    if (dot_position == std::string::npos || dot_position == 0 || dot_position == file_name.length() - 1) {
        return ""No"";
    }
    
    std::string prefix = file_name.substr(0, dot_position);
    if (!isalpha(prefix[0])) {
        return ""No"";
    }
    
    std::string suffix = file_name.substr(dot_position + 1);
    if (suffix != ""txt"" && suffix != ""exe"" && suffix != ""dll"") {
        return ""No"";
    }
    
    return ""Yes"";
"
0,0.0,HumanEval_141_file_name_check,"
    // Check if the file name contains exactly one dot
    int count = std::count(file_name.begin(), file_name.end(), '.');
    if (count != 1) {
        return ""No"";
    }

    // Split the file name into two parts: before and after the dot
    std::string before_dot = file_name.substr(0, file_name.find('.'));
    std::string after_dot = file_name.substr(file_name.find('.') + 1);

    // Check if there are more than three digits in the file name
    int digit_count = std::count_if(file_name.begin(), file_name.end(), ::isdigit);
    if (digit_count > 3) {
        return ""No"";
    }

    // Check if the substring before the dot is not empty and starts with a letter
    if (before_dot.empty() || !std::isalpha(before_dot[0])) {
        return ""No"";
    }

    // Check if the substring after the dot is one of ['txt', 'exe', 'dll']
    if (after_dot != ""txt"" && after_dot != ""exe"" && after_dot != ""dll"") {
        return ""No"";
    }

    // If all conditions are met, return 'Yes'
    return ""Yes"";"
0,1.0,HumanEval_141_file_name_check,"
std::string file_name_check(std::string file_name) {
    int count_digits = 0;
    int dot_position = -1;
    int length = file_name.size();

    for (int i = 0; i < length; i++) {
        if (isdigit(file_name[i])) {
            count_digits++;
            if (count_digits > 3) {
                return ""No"";
            }
        }
        if (file_name[i] == '.') {
            dot_position = i;
        }
    }

    if (dot_position == -1 || dot_position == 0 || dot_position == length - 1) {
        return ""No"";
    }

    std::string extension = file_name.substr(dot_position + 1);
    if (extension != ""txt"" && extension != ""exe"" && extension != ""dll"") {
        return ""No"";
    }

    char first_char = file_name[0];
    if (!isalpha(first_char)) {
        return ""No"";
    }

    return ""Yes"";"
1,0.0,HumanEval_141_file_name_check,"

std::string file_name_check(std::string file_name) {
    // Check if the file name contains exactly one dot
    int dot_count = std::count(file_name.begin(), file_name.end(), '.');
    if (dot_count != 1) return ""No"";

    // Split the file name into two parts before and after the dot
    std::string before_dot = file_name.substr(0, file_name.find('.'));
    std::string after_dot = file_name.substr(file_name.find('.') + 1);

    // Check if the before part is not empty and starts with a letter
    if (!std::isalpha(before_dot[0])) return ""No"";

    // Check if there are more than three digits in the before part
    int digit_count = std::count_if(before_dot.begin(), before_dot.end(), ::isdigit);
    if (digit_count > 3) return ""No"";

    // Check if the after part is one of these: ['txt', 'exe', 'dll']
    if (after_dot != ""txt"" && after_dot != ""exe"" && after_dot != ""dll"") return ""No"";

    // If all checks pass, the file name is valid
    return ""Yes"";
"
0,0.0,HumanEval_141_file_name_check,"

std::string file_name_check(std::string file_name) {
    // Count number of digits in the file name
    int count_digits = std::count_if(file_name.begin(), file_name.end(), ::isdigit);

    // Check if file name contains exactly one dot
    int count_dots = std::count(file_name.begin(), file_name.end(), '.');
    if (count_dots != 1) return ""No"";

    // Find position of dot
    size_t dot_pos = file_name.find('.');

    // Check if substring before dot is not empty and starts with a letter
    if (dot_pos == 0 || dot_pos == file_name.length() - 1) return ""No"";

    // Check if there are no more than three digits in the file name
    if (count_digits > 3) return ""No"";

    // Check if substring after dot is one of ['txt', 'exe', 'dll']
    std::string extension = file_name.substr(dot_pos + 1);
    if (extension != ""txt"" && extension != ""exe"" && extension != ""dll"") return ""No"";

    return ""Yes"";"
0,0.0,HumanEval_141_file_name_check,"

std::string file_name_check(std::string file_name) {
    int count_digits = 0;
    int count_dots = 0;
    for(char c : file_name) {
        if(isdigit(c)) {
            count_digits++;
            if(count_digits > 3) {
                return ""No"";
            }
        }
        if(c == '.') {
            count_dots++;
        }
    }
    if(count_digits == 0 || count_dots != 1 || !isalpha(file_name[0]) || file_name.size() - file_name.find('.') - 1 <= 0) {
        return ""No"";
    }

    std::string extension = file_name.substr(file_name.find_last_of('.') + 1);
    if(extension != ""txt"" && extension != ""exe"" && extension != ""dll"") {
        return ""No"";
    }

    return ""Yes"";
"
1,0.0,HumanEval_141_file_name_check,"

std::string file_name_check(std::string file_name) {
    int count = 0;
    for(char c : file_name) {
        if(isdigit(c)) count++;
    }

    if(count > 3) return ""No"";

    size_t dot_position = file_name.find('.');
    if(dot_position == std::string::npos || dot_position == 0 || dot_position == file_name.length()-1) return ""No"";

    std::string extension = file_name.substr(dot_position+1);
    if(extension != ""txt"" && extension != ""exe"" && extension != ""dll"") return ""No"";

    char first_char = file_name[0];
    if(!isalpha(first_char)) return ""No"";

    return ""Yes"";"
0,1.0,HumanEval_141_file_name_check,"

std::string file_name_check(std::string file_name) {
    int dot_pos = file_name.find('.');
    if (dot_pos == std::string::npos || dot_pos == 0 || dot_pos == file_name.size()-1)
        return ""No"";

    int count_digits = 0;
    for (char c : file_name) {
        if (std::isdigit(c))
            count_digits++;
        if (count_digits > 3)
            return ""No"";
    }

    std::string extension = file_name.substr(dot_pos+1);
    if (extension != ""txt"" && extension != ""exe"" && extension != ""dll"")
        return ""No"";

    char first_char = file_name[0];
    if (!(std::isalpha(first_char) || (first_char == '_')))
        return ""No"";

    return ""Yes"";"
1,1.0,HumanEval_141_file_name_check,"

std::string file_name_check(std::string file_name) {
    // Check if the file name contains exactly one dot
    int count = std::count(file_name.begin(), file_name.end(), '.');
    if (count != 1) {
        return ""No"";
    }

    // Split the file name into two parts before and after the dot
    std::string before_dot = file_name.substr(0, file_name.find('.'));
    std::string after_dot = file_name.substr(file_name.find('.') + 1);

    // Check if the substring before the dot is not empty and starts with a letter
    if (before_dot.empty() || !std::isalpha(before_dot[0])) {
        return ""No"";
    }

    // Check if there are more than three digits in the substring before the dot
    int digit_count = std::count_if(before_dot.begin(), before_dot.end(), ::isdigit);
    if (digit_count > 3) {
        return ""No"";
    }

    // Check if the substring after the dot is one of ['txt', 'exe', 'dll']
    if (after_dot != ""txt"" && after_dot != ""exe"" && after_dot != ""dll"") {
        return ""No"";
    }

    // If all conditions are met, return 'Yes'
    return ""Yes"";"
0,0.0,HumanEval_141_file_name_check,"
    int count_digits = 0;
    int count_dots = 0;
    int count_letters = 0;
    for (char c : file_name) {
        if (isdigit(c)) {
            count_digits++;
            if (count_digits > 3) {
                return ""No"";
            }
        } else if (c == '.') {
            count_dots++;
            if (count_dots > 1) {
                return ""No"";
            }
        } else if (isalpha(c)) {
            count_letters++;
            if (count_letters > 1) {
                return ""No"";
            }
        }
    }
    if (count_digits == 0 && count_dots == 1 && count_letters == 1) {
        std::string extension = file_name.substr(file_name.find_last_of('.') + 1);
        if (extension == ""txt"" || extension == ""exe"" || extension == ""dll"") {
            return ""Yes"";
        }
    }
    return ""No"";"
1,1.0,HumanEval_40_triples_sum_to_zero,"
bool triples_sum_to_zero(std::vector<long> l) {
    int n = l.size();
    if (n < 3) return false;
    sort(l.begin(), l.end());
    for (int i = 0; i < n - 1; i++) {
        int start = i + 1;
        int end = n - 1;
        while (start < end) {
            if (l[i] + l[start] + l[end] == 0) {
                return true;
            } else if (l[i] + l[start] + l[end] < 0) {
                start++;
            } else {
                end--;
            }
        }
    }
    return false;
"
1,1.0,HumanEval_40_triples_sum_to_zero,"

bool triples_sum_to_zero(std::vector<long> l) {
    int n = l.size();
    if (n < 3) {
        return false;
    }
    sort(l.begin(), l.end());
    for (int i = 0; i < n - 1; i++) {
        int a = l[i];
        int start = i + 1;
        int end = n - 1;
        while (start < end) {
            if (a + l[start] + l[end] == 0) {
                return true;
            }
            else if (a + l[start] + l[end] < 0) {
                start += 1;
            }
            else {
                end -= 1;
            }
        }
    }
    return false;
"
1,1.0,HumanEval_40_triples_sum_to_zero,"
bool triples_sum_to_zero(std::vector<long> l) {
    if(l.size() < 3)
        return false;

    std::sort(l.begin(), l.end());

    for(int i = 0; i < l.size() - 2; i++) {
        if(i > 0 && l[i] == l[i-1])
            continue;
        int j = i + 1, k = l.size() - 1;
        while(j < k) {
            if(l[i] + l[j] + l[k] == 0) {
                return true;
            } else if(l[i] + l[j] + l[k] < 0) {
                j++;
            } else {
                k--;
            }
        }
    }
    return false;
"
1,1.0,HumanEval_40_triples_sum_to_zero,"

bool triples_sum_to_zero(std::vector<long> l) {
    int n = l.size();
    if (n < 3) return false;

    std::sort(l.begin(), l.end());

    for (int i = 0; i < n - 1; i++) {
        int a = l[i];
        int start = i + 1;
        int end = n - 1;

        while (start < end) {
            if (a + l[start] + l[end] == 0) {
                return true;
            } else if (a + l[start] + l[end] < 0) {
                start += 1;
            } else {
                end -= 1;
            }
        }
    }

    return false;
"
1,1.0,HumanEval_40_triples_sum_to_zero,"
bool triples_sum_to_zero(std::vector<long> l) {
    int n = l.size();
    if (n < 3) return false;
    std::sort(l.begin(), l.end());
    for (int i = 0; i < n - 1; i++) {
        int a = l[i];
        int start = i + 1;
        int end = n - 1;
        while (start < end) {
            if (a + l[start] + l[end] == 0) {
                return true;
            }
            else if (a + l[start] + l[end] < 0) {
                start += 1;
            }
            else {
                end -= 1;
            }
        }
    }
    return false;
"
1,1.0,HumanEval_40_triples_sum_to_zero,"
bool triples_sum_to_zero(std::vector<long> l) {
    if(l.size() < 3) return false;
    std::sort(l.begin(), l.end());
    for(int i = 0; i < l.size() - 2; i++) {
        int j = i + 1;
        int k = l.size() - 1;
        while(j < k) {
            if(l[i] + l[j] + l[k] == 0) {
                return true;
            } else if(l[i] + l[j] + l[k] < 0) {
                j++;
            } else {
                k--;
            }
        }
    }
    return false;
"
0,1.0,HumanEval_40_triples_sum_to_zero,"
bool triples_sum_to_zero(std::vector<long> l) {
    // Sort the vector
    sort(l.begin(), l.end());

    // Iterate over the vector
    for (int i = 0; i < l.size() - 2; i++) {
        // Initialize two pointers, one at the next position
        // and the other at the end of the vector
        int j = i + 1;
        int k = l.size() - 1;

        // While the two pointers don't meet
        while (j < k) {
            // If the sum of the elements at the three positions is 0
            if (l[i] + l[j] + l[k] == 0) {
                // Return true
                return true;
            }
            // If the sum is less than 0, move the j pointer one step to the right
            else if (l[i] + l[j] + l[k] < 0) {
                j++;
            }
            // If the sum is greater than 0, move the k pointer one step to the left
            else {
                k--;
            }
        }
    }

    // If no triplet was found, return false
    return false;"
1,1.0,HumanEval_40_triples_sum_to_zero,"
bool triples_sum_to_zero(std::vector<long> l) {
    int n = l.size();
    if (n < 3) return false;
    sort(l.begin(), l.end());
    for (int i = 0; i < n - 1; i++) {
        int a = l[i];
        int start = i + 1;
        int end = n - 1;
        while (start < end) {
            if (a + l[start] + l[end] == 0) {
                return true;
            }
            else if (a + l[start] + l[end] < 0) {
                start += 1;
            }
            else {
                end -= 1;
            }
        }
    }
    return false;
"
0,0.0,HumanEval_40_triples_sum_to_zero,"
    // Sort the vector
    std::sort(l.begin(), l.end());

    // Iterate over each element in the vector
    for (int i = 0; i < l.size() - 2; i++) {
        // Initialize two pointers, one at the next element and one at the last element
        int j = i + 1;
        int k = l.size() - 1;

        // While the two pointers do not meet
        while (j < k) {
            // If the sum of the three elements is zero, return true
            if (l[i] + l[j] + l[k] == 0) {
                return true;
            }
            // If the sum is less than zero, move the left pointer to the right
            else if (l[i] + l[j] + l[k] < 0) {
                j++;
            }
            // If the sum is greater than zero, move the right pointer to the left
            else {
                k--;
            }
        }
    }

    // If no three elements sum to zero, return false
    return false;"
1,1.0,HumanEval_40_triples_sum_to_zero,"
bool triples_sum_to_zero(std::vector<long> l) {
    int n = l.size();
    if (n < 3)
        return false;
    sort(l.begin(), l.end());
    for (int i = 0; i < n - 1; i++) {
        int a = l[i];
        int start = i + 1;
        int end = n - 1;
        while (start < end) {
            if (a + l[start] + l[end] == 0) {
                return true;
            } else if (a + l[start] + l[end] < 0) {
                start += 1;
            } else {
                end -= 1;
            }
        }
    }
    return false;
"
0,0.0,HumanEval_127_intersection,"

std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
    long start = std::max(std::get<0>(interval1), std::get<0>(interval2));
    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));

    if (start > end)
        return ""NO"";

    long length = end - start + 1;

    if (isPrime(length))
        return ""YES"";
    else
        return ""NO"";"
0,0.0,HumanEval_127_intersection,"

std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
    long start = std::max(std::get<0>(interval1), std::get<0>(interval2));
    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));

    // If the intervals don't intersect, return ""NO""
    if (start > end)
        return ""NO"";

    // Calculate the length of the intersection
    long length = end - start + 1;

    // If the length of the intersection is a prime number, return ""YES"", otherwise, return ""NO""
    return is_prime(length) ? ""YES"" : ""NO"";
"
0,0.0,HumanEval_127_intersection,"
std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
    long start = std::max(std::get<0>(interval1), std::get<0>(interval2));
    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));

    if (start > end) {
        return ""NO"";
    }

    long length = end - start + 1;
    if (length < 2) {
        return ""NO"";
    }

    for (long i = 2; i * i <= length; ++i) {
        if (length % i == 0) {
            return ""NO"";
        }
    }

    return ""YES"";
"
0,0.0,HumanEval_127_intersection,"
    // Get the start and end of the first interval
    long start1 = std::get<0>(interval1);
    long end1 = std::get<1>(interval1);

    // Get the start and end of the second interval
    long start2 = std::get<0>(interval2);
    long end2 = std::get<1>(interval2);

    // Calculate the start and end of the intersection
    long start_intersection = std::max(start1, start2);
    long end_intersection = std::min(end1, end2);

    // Calculate the length of the intersection
    long length_intersection = end_intersection - start_intersection + 1;

    // Check if the length of the intersection is a prime number
    if (length_intersection < 2) {
        return ""NO"";
    }
    for (long i = 2; i * i <= length_intersection; i++) {
        if (length_intersection % i == 0) {
            return ""NO"";
        }
    }
    return ""YES"";"
0,1.0,HumanEval_127_intersection,"

std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
    long start = std::max(std::get<0>(interval1), std::get<0>(interval2));
    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));

    if (start > end) 
        return ""NO"";

    long length = end - start + 1;

    if (isPrime(length)) 
        return ""YES"";
    else 
        return ""NO"";"
0,0.0,HumanEval_127_intersection,"
    long start = std::max(std::get<0>(interval1), std::get<0>(interval2));
    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));
    long length = end - start + 1;

    if (length < 2) {
        return ""NO"";
    }

    for (long i = 2; i * i <= length; ++i) {
        if (length % i == 0) {
            return ""NO"";
        }
    }

    return ""YES"";"
0,0.0,HumanEval_127_intersection,"

std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
    long start = std::max(std::get<0>(interval1), std::get<0>(interval2));
    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));
    if(start > end) return ""NO"";
    long length = end - start + 1;
    return isPrime(length) ? ""YES"" : ""NO"";"
0,0.0,HumanEval_127_intersection,"

std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
    long start = std::max(std::get<0>(interval1), std::get<0>(interval2));
    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));
    if (start > end) return ""NO"";
    return isPrime(end - start + 1) ? ""YES"" : ""NO"";"
0,0.0,HumanEval_127_intersection,"
std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
    long start1 = std::get<0>(interval1);
    long end1 = std::get<1>(interval1);
    long start2 = std::get<0>(interval2);
    long end2 = std::get<1>(interval2);

    // Find the intersection of the two intervals
    long start = std::max(start1, start2);
    long end = std::min(end1, end2);

    // If the intervals don't intersect, return ""NO""
    if (start > end) {
        return ""NO"";
    }

    // Calculate the length of the intersection
    long length = end - start + 1;

    // Check if the length is a prime number
    if (length < 2) {
        return ""NO"";
    }
    for (long i = 2; i * i <= length; i++) {
        if (length % i == 0) {
            return ""NO"";
        }
    }
    return ""YES"";"
0,0.0,HumanEval_127_intersection,"

std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
    long start = std::max(std::get<0>(interval1), std::get<0>(interval2));
    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));
    if (start > end) // No intersection
        return ""NO"";
    long length = end - start + 1; // +1 because the end is included
    return isPrime(length) ? ""YES"" : ""NO"";"
1,1.0,HumanEval_1_separate_paren_groups,"
std::vector<std::string> separate_paren_groups(std::string paren_string) {
    std::vector<std::string> result;
    std::string temp;
    int count = 0;

    for (char c : paren_string) {
        if (c == ' ') continue;
        if (c == '(') {
            count++;
            temp += c;
        }
        if (c == ')') {
            count--;
            temp += c;
            if (count == 0) {
                result.push_back(temp);
                temp.clear();
            }
        }
    }
    return result;"
1,1.0,HumanEval_1_separate_paren_groups,"
std::vector<std::string> separate_paren_groups(std::string paren_string) {
    std::vector<std::string> result;
    std::string temp = """";
    int count = 0;

    for (char c : paren_string) {
        if (c == ' ') continue;

        if (c == '(') {
            count++;
            temp += c;
        }

        if (c == ')') {
            count--;
            temp += c;
            if (count == 0) {
                result.push_back(temp);
                temp = """";
            }
        }
    }

    return result;"
0,0.0,HumanEval_1_separate_paren_groups,"
    std::vector<std::string> result;
    std::stack<char> stack;
    std::string temp;

    for (char c : paren_string) {
        if (c == '(') {
            stack.push(c);
            temp += c;
        } else if (c == ')') {
            stack.pop();
            temp += c;
            if (stack.empty()) {
                result.push_back(temp);
                temp.clear();
            }
        }
    }

    return result;
"
0,0.0,HumanEval_1_separate_paren_groups,"
std::vector<std::string> separate_paren_groups(std::string paren_string) {
    std::vector<std::string> groups;
    std::string group;
    int count = 0;

    for (char c : paren_string) {
        if (c == '(' || c == ' ') {
            if (c == '(') {
                count++;
            }
            continue;
        }
        if (c == ')') {
            count--;
            group += c;
            if (count == 0) {
                groups.push_back(group);
                group.clear();
            }
            continue;
        }
    }

    return groups;
"
1,1.0,HumanEval_1_separate_paren_groups,"

std::vector<std::string> separate_paren_groups(std::string paren_string) {
    std::vector<std::string> result;
    std::string temp = """";
    int count = 0;

    for (char c : paren_string) {
        if (c == ' ') continue;
        if (c == '(') {
            count++;
            temp += c;
        }
        if (c == ')') {
            count--;
            temp += c;
            if (count == 0) {
                result.push_back(temp);
                temp = """";
            }
        }
    }

    return result;
"
1,1.0,HumanEval_1_separate_paren_groups,"
std::vector<std::string> separate_paren_groups(std::string paren_string) {
    std::vector<std::string> result;
    std::string temp = """";
    int count = 0;

    for (char c : paren_string) {
        if (c == ' ') continue;
        if (c == '(') {
            count++;
            temp += c;
        }
        if (c == ')') {
            count--;
            temp += c;
            if (count == 0) {
                result.push_back(temp);
                temp = """";
            }
        }
    }

    return result;
"
1,1.0,HumanEval_1_separate_paren_groups,"
std::vector<std::string> separate_paren_groups(std::string paren_string) {
    std::vector<std::string> result;
    std::string temp;
    int balance = 0;

    for(auto c : paren_string) {
        if (c == ' ') continue;

        if (c == '(') {
            balance++;
            temp += c;
        }

        if (c == ')') {
            balance--;
            temp += c;
            if (balance == 0) {
                result.push_back(temp);
                temp.clear();
            }
        }
    }

    assert(balance == 0); // The string should be balanced

    return result;"
1,1.0,HumanEval_1_separate_paren_groups,"
std::vector<std::string> separate_paren_groups(std::string paren_string) {
    std::vector<std::string> result;
    std::string temp = """";
    int count = 0;
    for (char c : paren_string) {
        if (c == ' ') continue;
        if (c == '(') {
            count++;
            temp += c;
        }
        if (c == ')') {
            count--;
            temp += c;
            if (count == 0) {
                result.push_back(temp);
                temp = """";
            }
        }
    }
    return result;"
0,0.0,HumanEval_1_separate_paren_groups,"
    std::vector<std::string> result;
    std::string temp;
    int count = 0;
    for (char c : paren_string) {
        if (c == ' ') continue;
        if (c == '(') {
            count++;
            temp += c;
        }
        if (c == ')') {
            count--;
            temp += c;
            if (count == 0) {
                result.push_back(temp);
                temp.clear();
            }
        }
    }
    return result;"
0,1.0,HumanEval_1_separate_paren_groups,"
std::vector<std::string> separate_paren_groups(std::string paren_string) {
    std::vector<std::string> result;
    std::string temp;
    int count = 0;
    for (char c : paren_string) {
        if (c == ' ') continue;
        if (c == '(') {
            count++;
            temp += c;
        }
        if (c == ')') {
            count--;
            temp += c;
            if (count == 0) {
                result.push_back(temp);
                temp.clear();
            }
        }
    }
    return result;
"
1,1.0,HumanEval_152_compare,"
std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
    assert(game.size() == guess.size());
    std::vector<long> result(game.size());
    for (size_t i = 0; i < game.size(); ++i) {
        result[i] = std::abs(game[i] - guess[i]);
    }
    return result;"
0,1.0,HumanEval_152_compare,"
std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
    assert(game.size() == guess.size());
    std::vector<long> result(game.size());
    for (size_t i = 0; i < game.size(); ++i) {
        result[i] = std::abs(game[i] - guess[i]);
    }
    return result;
"
0,1.0,HumanEval_152_compare,"
std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
    assert(game.size() == guess.size());
    std::vector<long> result(game.size());
    for(size_t i = 0; i < game.size(); ++i) {
        result[i] = std::abs(game[i] - guess[i]);
    }
    return result;
"
0,1.0,HumanEval_152_compare,"
std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
    assert(game.size() == guess.size());
    std::vector<long> result(game.size());
    for (size_t i = 0; i < game.size(); ++i) {
        result[i] = std::abs(game[i] - guess[i]);
    }
    return result;
"
0,0.0,HumanEval_152_compare,"
    assert(game.size() == guess.size());
    std::vector<long> result(game.size());
    for(size_t i = 0; i < game.size(); ++i) {
        result[i] = std::abs(game[i] - guess[i]);
    }
    return result;
"
0,1.0,HumanEval_152_compare,"
std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
    assert(game.size() == guess.size());
    std::vector<long> result(game.size());
    for(size_t i = 0; i < game.size(); ++i) {
        result[i] = std::abs(game[i] - guess[i]);
    }
    return result;
"
0,0.0,HumanEval_152_compare,"
    assert(game.size() == guess.size());
    std::vector<long> result(game.size());
    for (size_t i = 0; i < game.size(); ++i) {
        result[i] = std::abs(game[i] - guess[i]);
    }
    return result;"
1,1.0,HumanEval_152_compare,"
std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
    assert(game.size() == guess.size());
    std::vector<long> result(game.size());
    for (size_t i = 0; i < game.size(); ++i) {
        result[i] = std::abs(game[i] - guess[i]);
    }
    return result;"
1,1.0,HumanEval_152_compare,"

std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
    assert(game.size() == guess.size());
    std::vector<long> result(game.size());
    for(size_t i = 0; i < game.size(); ++i) {
        result[i] = std::abs(game[i] - guess[i]);
    }
    return result;
"
1,1.0,HumanEval_152_compare,"
std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
    assert(game.size() == guess.size());
    std::vector<long> result(game.size());
    for (size_t i = 0; i < game.size(); ++i) {
        result[i] = std::abs(game[i] - guess[i]);
    }
    return result;"
0,1.0,HumanEval_83_starts_one_ends,"
long starts_one_ends(long n) {
    // base case
    if(n == 1) return 2;

    // dynamic programming table to store the count of n-digit numbers 
    // that start or end with 1
    vector<vector<long>> dp(n+1, vector<long>(2));

    // initial condition for n = 1
    dp[1][0] = dp[1][1] = 2;

    // fill up the dynamic programming table
    for(long i = 2; i <= n; i++) {
        dp[i][0] = dp[i-1][0] + dp[i-1][1];
        dp[i][1] = dp[i-1][0] + dp[i-1][1];
    }

    // total count of n-digit numbers that start or end with 1 is the sum of
    // counts of n-digit numbers that start with 1 and n-digit numbers that end with 1
    return dp[n][0] + dp[n][1];"
0,0.0,HumanEval_83_starts_one_ends,"
long starts_one_ends(long n) {
    // Base case
    if(n == 1)
        return 2;

    // Create a vector to store the counts of n-digit numbers 
    // that start or end with 1.
    vector<long> dp(n+1, 0);

    // Initialize the base cases
    dp[1] = 2;
    dp[2] = 4;

    // Calculate the counts for n > 2
    for(long i = 3; i <= n; i++) {
        dp[i] = 2 * dp[i-1] + pow(2, i-2);
    }

    return dp[n];
"
0,0.0,HumanEval_83_starts_one_ends,"
long starts_one_ends(long n) {
    // Create a 2D DP table where dp[i][j] represents the number of i-digit numbers
    // where the first/last digit is j.
    std::vector<std::vector<long>> dp(n+1, std::vector<long>(10));

    // Initialize the base cases
    for (int i = 0; i < 10; i++) {
        dp[1][i] = 1;
    }

    // Fill up the DP table
    for (int i = 2; i <= n; i++) {
        for (int j = 0; j < 10; j++) {
            // If the first/last digit is 1, then we can add 0-9 to the number
            if (j == 1) {
                dp[i][j] = dp[i-1][j] * 10;
            }
            // If the first/last digit is not 1, then we can add 1 to the number
            else {
                dp[i][j] = dp[i-1][j] * 9;
            }
        }
    }

    // Calculate the total number of n-digit numbers that start or end with 1
    long total = 0;
    for (int i = 1; i < 10; i++) {
        total += dp[n][i];
    }

    return total;
"
0,0.0,HumanEval_83_starts_one_ends,"
long starts_one_ends(long n) {
    if (n == 1) {
        return 2;
    } else if (n == 2) {
        return 4;
    } else {
        long long dp[n+1];
        dp[1] = 2;
        dp[2] = 4;
        for (long i = 3; i <= n; i++) {
            dp[i] = 2 * dp[i-1] + (1 << (i-1));
        }
        return dp[n];
    }"
0,1.0,HumanEval_83_starts_one_ends,"

long starts_one_ends(long n) {
    assert(n > 0);
    long dp[n+1][2];
    memset(dp, 0, sizeof(dp));
    dp[1][0] = dp[1][1] = 1;
    for(long i=2; i<=n; i++) {
        dp[i][0] = dp[i-1][0] + dp[i-1][1];
        dp[i][1] = dp[i-1][0];
    }
    return dp[n][0] + dp[n][1];"
0,0.0,HumanEval_83_starts_one_ends,"
long starts_one_ends(long n) {
    // Check if n is less than 1
    if(n < 1) {
        return 0;
    }
    // Check if n is 1
    else if(n == 1) {
        return 1;
    }
    else {
        return 2 * pow(10, n-2);
    }"
0,0.0,HumanEval_83_starts_one_ends,"
long starts_one_ends(long n) {
    assert(n > 0);
    long long dp[n+1][10][2];
    memset(dp, 0, sizeof(dp));
    for (int i = 1; i <= n; i++) {
        dp[i][1][0] = dp[i][1][1] = 1;
    }
    for (int i = 2; i <= n; i++) {
        for (int j = 0; j < 10; j++) {
            for (int k = 0; k < 2; k++) {
                for (int x = 0; x < 10; x++) {
                    if (j == 1) {
                        dp[i][x][1] += dp[i-1][j][k];
                    } else {
                        dp[i][x][k] += dp[i-1][j][k];
                    }
                }
            }
        }
    }
    long long ans = 0;
    for (int j = 0; j < 10; j++) {
        for (int k = 0; k < 2; k++) {
            ans += dp[n][j][k];
        }
    }
    return ans;
"
0,1.0,HumanEval_83_starts_one_ends,"
long starts_one_ends(long n) {
    if (n == 1) {
        return 2;
    }
    else {
        return pow(2, n - 1);
    }"
0,0.0,HumanEval_83_starts_one_ends,"
    assert(n > 0);
    if(n == 1)
        return 2;
    else
        return pow(2, n-1);
"
0,0.0,HumanEval_83_starts_one_ends,"
long starts_one_ends(long n) {
    // Base case
    if (n == 1)
        return 2;

    // DP array
    long dp[n+1];
    dp[1] = 2;
    dp[2] = 3;

    // DP relation: dp[i] = 2 * dp[i-1] + dp[i-2]
    for (long i = 3; i <= n; i++) {
        dp[i] = 2 * dp[i-1] + dp[i-2];
    }

    return dp[n];"
1,1.0,HumanEval_134_check_if_last_char_is_a_letter,"

bool check_if_last_char_is_a_letter(std::string txt) {
    // Check if string is empty
    if(txt.empty())
        return false;

    // Check if last character is an alphabetical character
    if(isalpha(txt[txt.size()-1])) {
        // Check if it is not a part of a word
        if(txt.size() == 1 || !isalpha(txt[txt.size()-2]))
            return true;
    }
    return false;"
1,1.0,HumanEval_134_check_if_last_char_is_a_letter,"
bool check_if_last_char_is_a_letter(std::string txt) {
    if(txt.empty())
        return false;

    // Check if the last character is a letter
    if(isalpha(txt[txt.size()-1])) {
        // Check if it is not part of a word
        if(txt.size() == 1 || !isalpha(txt[txt.size()-2]))
            return true;
    }

    return false;"
0,0.0,HumanEval_134_check_if_last_char_is_a_letter,"
    if(txt.empty())
        return false;

    if(!isalpha(txt[txt.size()-1]))
        return false;

    if(txt[txt.size()-2] == ' ')
        return true;

    return false;"
0,0.0,HumanEval_134_check_if_last_char_is_a_letter,"
    // Your code goes here
    if(txt.empty()) return false;

    char last_char = txt[txt.length() - 1];

    if(isalpha(last_char)) {
        if(txt.length() == 1 || txt[txt.length() - 2] == ' ') {
            return true;
        }
    }

    return false;"
1,1.0,HumanEval_134_check_if_last_char_is_a_letter,"

bool check_if_last_char_is_a_letter(std::string txt) {
    // Check if the string is empty
    if (txt.empty()) {
        return false;
    }

    // Check if the last character is a letter
    if (isalpha(txt[txt.length() - 1])) {
        // Check if the last character is not a part of a word
        if (txt.length() == 1 || !isalpha(txt[txt.length() - 2])) {
            return true;
        }
    }

    return false;"
0,0.0,HumanEval_134_check_if_last_char_is_a_letter,"
    // Check if the string is empty
    if (txt.empty()) {
        return false;
    }

    // Check if the last character is a letter
    if (isalpha(txt[txt.length() - 1])) {
        // Check if the last character is not part of a word
        if (txt.length() == 1 || !isalpha(txt[txt.length() - 2])) {
            return true;
        }
    }

    return false;"
0,1.0,HumanEval_134_check_if_last_char_is_a_letter,"
bool check_if_last_char_is_a_letter(std::string txt) {
    if(txt.empty()) {
        return false;
    }
    if(!isalpha(txt[txt.length()-1])) {
        return false;
    }
    if(txt[txt.length()-2] == ' ') {
        return true;
    }
    return false;
"
0,0.0,HumanEval_134_check_if_last_char_is_a_letter,"
    // Check if the string is empty
    if (txt.empty()) {
        return false;
    }
    
    // Remove trailing spaces
    while (txt.back() == ' ') {
        txt.pop_back();
    }
    
    // Check if the last character is a letter
    if (isalpha(txt.back())) {
        // Check if it's not part of a word
        if (txt.size() == 1 || !isalpha(txt[txt.size() - 2])) {
            return true;
        }
    }
    
    return false;"
1,1.0,HumanEval_134_check_if_last_char_is_a_letter,"

bool check_if_last_char_is_a_letter(std::string txt) {
    if(txt.empty()) {
        return false;
    }
    char lastChar = txt[txt.length() - 1];
    if(isalpha(lastChar)) {
        if(txt.length() == 1 || txt[txt.length() - 2] == ' ') {
            return true;
        }
    }
    return false;"
0,0.0,HumanEval_134_check_if_last_char_is_a_letter,"
    // Check if the string is empty
    if (txt.empty()) {
        return false;
    }

    // Check if the last character is an alphabetical character
    if (!isalpha(txt[txt.length() - 1])) {
        return false;
    }

    // Check if the last character is a part of a word
    if (txt[txt.length() - 2] == ' ' || txt.length() == 1) {
        return true;
    }
    else {
        return false;
    }
"
0,1.0,HumanEval_124_valid_date,"

bool valid_date(std::string date) {
    // Check if date string is empty
    if (date.empty())
        return false;

    // Check if date string is in correct format
    if (date[2] != '-' || date[5] != '-')
        return false;

    // Extract month, day and year from date string
    int month = std::stoi(date.substr(0, 2));
    int day = std::stoi(date.substr(3, 2));
    int year = std::stoi(date.substr(6, 4));

    // Check if month is valid
    if (month < 1 || month > 12)
        return false;

    // Check if day is valid for each month
    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && (day < 1 || day > 31))
        return false;
    else if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30))
        return false;
    else if (month == 2) {
        if (isLeap(year)) {
            if (day < 1 || day > 29)
                return false;
        } else {
            if (day < 1 || day > 28)
                return false;
        }
    }

    // If all checks pass, return true
    return true;"
1,1.0,HumanEval_124_valid_date,"
bool valid_date(std::string date) {
    // Check if the date string is not empty
    if(date.empty())
        return false;

    // Check if the date is in the correct format
    if(date[2]!='-' || date[5]!='-')
        return false;

    // Extract the month, day, and year from the date string
    std::string month = date.substr(0, 2);
    std::string day = date.substr(3, 2);
    std::string year = date.substr(6, 4);

    // Convert the month, day, and year to integers
    int m = std::stoi(month);
    int d = std::stoi(day);
    int y = std::stoi(year);

    // Check if the month is valid
    if(m < 1 || m > 12)
        return false;

    // Check if the day is valid for February
    if(m == 2) {
        if(d < 1 || d > 29)
            return false;
    }
    // Check if the day is valid for April, June, September, and November
    else if(m == 4 || m == 6 || m == 9 || m == 11) {
        if(d < 1 || d > 30)
            return false;
    }
    // Check if the day is valid for January, March, May, July, August, October, and December
    else if(m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) {
        if(d < 1 || d > 31)
            return false;
    }
    // If the day is valid for all other months, return true
    else 
        return false;

    return true;"
1,1.0,HumanEval_124_valid_date,"

bool valid_date(std::string date) {
    if (date.length() != 10 || date[2] != '-' || date[5] != '-') {
        return false;
    }

    int month = std::stoi(date.substr(0, 2));
    int day = std::stoi(date.substr(3, 2));
    int year = std::stoi(date.substr(6, 4));

    if (month < 1 || month > 12 || day < 1 || year < 1) {
        return false;
    }

    if (month == 2) {
        if (day > 29) {
            return false;
        }
    } else if (month == 4 || month == 6 || month == 9 || month == 11) {
        if (day > 30) {
            return false;
        }
    } else {
        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {
            if (day > 31) {
                return false;
            }
        }
    }

    return true;
"
1,1.0,HumanEval_124_valid_date,"

bool valid_date(std::string date) {
    if (date.size() != 10 || date[2] != '-' || date[5] != '-')
        return false;

    std::string month = date.substr(0, 2);
    std::string day = date.substr(3, 2);
    std::string year = date.substr(6, 4);

    if (stoi(month) < 1 || stoi(month) > 12 || stoi(day) < 1 || stoi(year) < 1)
        return false;

    if (stoi(month) == 2) {
        if (stoi(day) > 29)
            return false;
    }
    else if (stoi(month) == 4 || stoi(month) == 6 || stoi(month) == 9 || stoi(month) == 11) {
        if (stoi(day) > 30)
            return false;
    }
    else {
        if (stoi(day) > 31)
            return false;
    }

    return true;"
1,1.0,HumanEval_124_valid_date,"

bool valid_date(std::string date) {
    if (date.empty())
        return false;

    if (date.size() != 10 || date[2] != '-' || date[5] != '-')
        return false;

    int month = std::stoi(date.substr(0, 2));
    int day = std::stoi(date.substr(3, 2));
    int year = std::stoi(date.substr(6, 4));

    if (month < 1 || month > 12 || day < 1 || year < 1)
        return false;

    if (month == 2) {
        if (day > 29)
            return false;
    } 
    else if (month == 4 || month == 6 || month == 9 || month == 11) {
        if (day > 30)
            return false;
    } 
    else {
        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {
            if (day > 31)
                return false;
        }
    }

    return true;"
1,1.0,HumanEval_124_valid_date,"

bool valid_date(std::string date) {
    if(date.size() != 10 || date[2] != '-' || date[5] != '-') {
        return false;
    }
    
    int month = std::stoi(date.substr(0, 2));
    int day = std::stoi(date.substr(3, 2));
    int year = std::stoi(date.substr(6, 4));
    
    if(month < 1 || month > 12 || day < 1 || year < 1) {
        return false;
    }
    
    if(month == 2) {
        if(day > 29) {
            return false;
        }
    } else if(month == 4 || month == 6 || month == 9 || month == 11) {
        if(day > 30) {
            return false;
        }
    } else if(month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {
        if(day > 31) {
            return false;
        }
    }
    
    return true;
"
1,1.0,HumanEval_124_valid_date,"

bool valid_date(std::string date) {
    if (date.size() != 10 || date[2] != '-' || date[5] != '-')
        return false;

    int month = std::stoi(date.substr(0, 2));
    int day = std::stoi(date.substr(3, 2));
    int year = std::stoi(date.substr(6, 4));

    if (month < 1 || month > 12 || day < 1 || year < 1)
        return false;

    if (month == 2) {
        if (day > 29 || day < 1)
            return false;
    }
    else if (month == 4 || month == 6 || month == 9 || month == 11) {
        if (day > 30 || day < 1)
            return false;
    }
    else {
        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {
            if (day > 31 || day < 1)
                return false;
        }
    }

    return true;
"
1,0.0,HumanEval_124_valid_date,"
bool valid_date(std::string date) {
    if(date.size() != 10 || date[2] != '-' || date[5] != '-')
        return false;
    
    std::string month = date.substr(0, 2);
    std::string day = date.substr(3, 2);
    std::string year = date.substr(6, 4);

    if(stoi(month) < 1 || stoi(month) > 12 || stoi(day) < 1 || stoi(year) < 1)
        return false;

    if(stoi(month) == 2) {
        if(stoi(day) > 29)
            return false;
    }
    else if(stoi(month) == 4 || stoi(month) == 6 || stoi(month) == 9 || stoi(month) == 11) {
        if(stoi(day) > 30)
            return false;
    }
    else {
        if(stoi(day) > 31)
            return false;
    }

    return true;"
1,1.0,HumanEval_124_valid_date,"
bool valid_date(std::string date) {
    if(date.empty())
        return false;
    if(date.size() != 10)
        return false;
    if(date[2] != '-' || date[5] != '-')
        return false;

    std::string month = date.substr(0, 2);
    std::string day = date.substr(3, 2);
    std::string year = date.substr(6, 4);

    int m = std::stoi(month);
    int d = std::stoi(day);
    int y = std::stoi(year);

    if(m < 1 || m > 12)
        return false;
    if(d < 1 || d > 31)
        return false;

    if(m == 4 || m == 6 || m == 9 || m == 11) {
        if(d > 30)
            return false;
    }
    else if(m == 2) {
        if(d > 29)
            return false;
    }
    else {
        if(d > 31)
            return false;
    }

    return true;"
0,0.0,HumanEval_124_valid_date,"
    if (date.empty()) {
        return false;
    }

    if (date.size() != 10) {
        return false;
    }

    if (date[2] != '-' || date[5] != '-') {
        return false;
    }

    std::string month = date.substr(0, 2);
    std::string day = date.substr(3, 2);
    std::string year = date.substr(6, 4);

    if (stoi(month) < 1 || stoi(month) > 12) {
        return false;
    }

    if (stoi(day) < 1 || stoi(day) > 31) {
        return false;
    }

    if ((stoi(month) == 4 || stoi(month) == 6 || stoi(month) == 9 || stoi(month) == 11) && stoi(day) > 30) {
        return false;
    }

    if (stoi(month) == 2) {
        if (stoi(day) > 29) {
            return false;
        }
        if ((stoi(year) % 4 != 0 && stoi(day) == 29) || (stoi(year) % 100 == 0 && stoi(year) % 400 != 0 && stoi(day) == 29)) {
            return false;
        }
    }

    return true;
"
0,0.0,HumanEval_108_count_nums,"
long count_nums(std::vector<long> arr) {
    long count = 0;
    for(long num : arr) {
        long sum = 0;
        bool negative = false;
        if(num < 0) {
            negative = true;
            num = -num;
        }
        while(num > 0) {
            long digit = num % 10;
            if(negative) {
                digit = -digit;
            }
            sum += digit;
            num /= 10;
            negative = false;
        }
        if(sum > 0) {
            count++;
        }
    }
    return count;"
0,1.0,HumanEval_108_count_nums,"
long count_nums(std::vector<long> arr) {
    long count = 0;
    for (long num : arr) {
        long sum = 0;
        if (num < 0) {
            num = -num;
            while (num != 0) {
                sum += num % 10;
                num /= 10;
            }
            sum = -sum;
        } else {
            while (num != 0) {
                sum += num % 10;
                num /= 10;
            }
        }
        if (sum > 0) {
            count++;
        }
    }
    return count;"
0,0.0,HumanEval_108_count_nums,"

long count_nums(std::vector<long> arr) {
    long count = 0;
    for(long num : arr) {
        long sum = 0;
        if(num < 0) {
            num = -num;
            while(num != 0) {
                sum += num % 10;
                num /= 10;
            }
            sum = -sum;
        } else {
            while(num != 0) {
                sum += num % 10;
                num /= 10;
            }
        }
        if(sum > 0) {
            count++;
        }
    }
    return count;
"
0,1.0,HumanEval_108_count_nums,"
long count_nums(std::vector<long> arr) {
    long count = 0;
    for(long num : arr) {
        long sum = 0;
        while(num != 0) {
            sum += num % 10;
            num /= 10;
        }
        if(sum > 0) {
            count++;
        }
    }
    return count;
"
0,1.0,HumanEval_108_count_nums,"

long count_nums(std::vector<long> arr) {
    long count = 0;
    for(long num : arr) {
        long sum = 0;
        while(num != 0) {
            sum += num % 10;
            num /= 10;
        }
        if(sum > 0) {
            count++;
        }
    }
    return count;"
0,1.0,HumanEval_108_count_nums,"

long count_nums(std::vector<long> arr) {
    long count = 0;
    for(long num : arr) {
        long sum = 0;
        while(num != 0) {
            sum += num % 10;
            num /= 10;
        }
        if(sum > 0) count++;
    }
    return count;"
0,1.0,HumanEval_108_count_nums,"
long count_nums(std::vector<long> arr) {
    long count = 0;
    for(long num : arr) {
        long sum = 0;
        if(num < 0) {
            num = -num;
            while(num != 0) {
                sum += num % 10;
                num /= 10;
            }
            sum = -sum;
        } else {
            while(num != 0) {
                sum += num % 10;
                num /= 10;
            }
        }
        if(sum > 0) {
            count++;
        }
    }
    return count;"
0,0.0,HumanEval_108_count_nums,"
long count_nums(std::vector<long> arr) {
    long count = 0;
    for (long num : arr) {
        long sum = 0;
        bool isNegative = false;
        while (num != 0) {
            if (num < 0) {
                isNegative = true;
                num = -num;
            }
            long digit = num % 10;
            if (isNegative) {
                digit = -digit;
            }
            sum += digit;
            num /= 10;
        }
        if (sum > 0) {
            count++;
        }
    }
    return count;"
0,1.0,HumanEval_108_count_nums,"
long count_nums(std::vector<long> arr) {
    long count = 0;
    for (long num : arr) {
        long sum = 0;
        if (num < 0) {
            for (char digit : std::to_string(num).substr(1)) {
                sum += digit - '0';
            }
            sum = -sum;
        } else {
            for (char digit : std::to_string(num)) {
                sum += digit - '0';
            }
        }
        if (sum > 0) {
            count++;
        }
    }
    return count;
"
0,1.0,HumanEval_108_count_nums,"
long count_nums(std::vector<long> arr) {
    long count = 0;
    for (long num : arr) {
        long sum = 0;
        while (num != 0) {
            sum += num % 10;
            num /= 10;
        }
        if (sum > 0) {
            count++;
        }
    }
    return count;
"
1,1.0,HumanEval_86_anti_shuffle,"

std::string anti_shuffle(std::string s) {
    std::stringstream ss(s);
    std::string word;
    std::vector<std::string> words;

    while (ss >> word) {
        std::sort(word.begin(), word.end());
        words.push_back(word);
    }

    std::string result;
    for (size_t i = 0; i < words.size(); ++i) {
        if (i > 0) {
            result += ' ';
        }
        result += words[i];
    }

    return result;
"
0,0.0,HumanEval_86_anti_shuffle,"
    std::istringstream ss(s);
    std::string word;
    std::string result = """";
    while (ss >> word) {
        std::sort(word.begin(), word.end());
        result += word + "" "";
    }
    if (!result.empty())
        result.pop_back(); // remove the last space
    return result;
"
0,0.0,HumanEval_86_anti_shuffle,"
std::string anti_shuffle(std::string s) {
    std::istringstream iss(s);
    std::string result = """", word;

    while (iss >> word) {
        std::sort(word.begin(), word.end());
        result += word + "" "";
    }

    if (!result.empty())
        result.pop_back(); // Remove the trailing space

    return result;"
0,0.0,HumanEval_86_anti_shuffle,"
    std::istringstream ss(s);
    std::string word;
    std::string result = """";
    while (ss >> word) {
        std::sort(word.begin(), word.end());
        result += word + "" "";
    }
    if (!result.empty())
        result.pop_back(); // Remove the trailing space
    return result;
"
1,1.0,HumanEval_86_anti_shuffle,"
std::string anti_shuffle(std::string s) {
    std::istringstream iss(s);
    std::string result = """", word;
    while (iss >> word) {
        std::sort(word.begin(), word.end());
        result += word + "" "";
    }
    if (!result.empty())
        result.pop_back(); // remove trailing space
    return result;"
1,1.0,HumanEval_86_anti_shuffle,"

std::string anti_shuffle(std::string s) {
    std::istringstream iss(s);
    std::string result = """", word;
    while (iss >> word) {
        std::sort(word.begin(), word.end());
        result += word + ' ';
    }
    if (!result.empty()) {
        result.pop_back(); // Remove the trailing space
    }
    return result;
"
1,1.0,HumanEval_86_anti_shuffle,"
std::string anti_shuffle(std::string s) {
    std::istringstream ss(s);
    std::string word;
    std::string result;
    while (ss >> word) {
        std::sort(word.begin(), word.end());
        result += word + "" "";
    }
    if (!result.empty()) {
        result.pop_back(); // remove the last space
    }
    return result;
"
0,0.0,HumanEval_86_anti_shuffle,"
    std::istringstream ss(s);
    std::string word;
    std::string result;
    while (ss >> word) {
        std::sort(word.begin(), word.end());
        result += word + ' ';
    }
    if (!result.empty()) {
        result.pop_back(); // Remove trailing space
    }
    return result;
"
0,0.0,HumanEval_86_anti_shuffle,"
    std::stringstream ss(s);
    std::string word, result;
    while (ss >> word) {
        std::sort(word.begin(), word.end());
        result += word + ' ';
    }
    if (!result.empty()) {
        result.pop_back(); // remove the trailing space
    }
    return result;
"
1,1.0,HumanEval_86_anti_shuffle,"

std::string anti_shuffle(std::string s) {
    std::istringstream ss(s);
    std::string word;
    std::string result = """";

    while (ss >> word) {
        std::sort(word.begin(), word.end());
        result += word + "" "";
    }

    if (!result.empty())
        result.pop_back(); // remove the last space
    return result;"
0,0.0,HumanEval_48_is_palindrome,"
    int start = 0;
    int end = text.size() - 1;
    while (start < end) {
        if (text[start] != text[end]) {
            return false;
        }
        start++;
        end--;
    }
    return true;"
1,1.0,HumanEval_48_is_palindrome,"
bool is_palindrome(std::string text) {
    int start = 0;
    int end = text.size() - 1;
    while (start < end) {
        if (text[start] != text[end]) {
            return false;
        }
        start++;
        end--;
    }
    return true;"
0,0.0,HumanEval_48_is_palindrome,"
    int start = 0;
    int end = text.size() - 1;
    while (start < end) {
        if (text[start] != text[end]) {
            return false;
        }
        start++;
        end--;
    }
    return true;"
1,1.0,HumanEval_48_is_palindrome,"
bool is_palindrome(std::string text) {
    int start = 0;
    int end = text.size() - 1;

    while (start < end) {
        if (text[start] != text[end]) {
            return false;
        }
        start++;
        end--;
    }

    return true;"
0,0.0,HumanEval_48_is_palindrome,"
    int start = 0;
    int end = text.size() - 1;
    while (start < end) {
        if (text[start] != text[end]) {
            return false;
        }
        start++;
        end--;
    }
    return true;"
1,1.0,HumanEval_48_is_palindrome,"
bool is_palindrome(std::string text) {
    int start = 0;
    int end = text.size() - 1;
    
    while (start < end) {
        if (text[start] != text[end]) {
            return false;
        }
        start++;
        end--;
    }
    return true;
"
0,0.0,HumanEval_48_is_palindrome,"
    int start = 0;
    int end = text.size() - 1;
    while (start < end) {
        if (text[start] != text[end]) {
            return false;
        }
        start++;
        end--;
    }
    return true;"
0,0.0,HumanEval_48_is_palindrome,"
    int start = 0;
    int end = text.size() - 1;
    while (start < end)
    {
        if (text[start] != text[end])
            return false;
        start++;
        end--;
    }
    return true;"
1,1.0,HumanEval_48_is_palindrome,"

bool is_palindrome(std::string text) {
    int start = 0;
    int end = text.size() - 1;
    while (start < end) {
        if (text[start] != text[end]) {
            return false;
        }
        start++;
        end--;
    }
    return true;
"
1,1.0,HumanEval_48_is_palindrome,"
bool is_palindrome(std::string text) {
    int start = 0;
    int end = text.size() - 1;
    while (start < end) {
        if (text[start] != text[end]) {
            return false;
        }
        start++;
        end--;
    }
    return true;
"
1,1.0,HumanEval_118_get_closest_vowel,"
std::string get_closest_vowel(std::string word) {
    std::string vowels = ""aeiouAEIOU"";
    for (int i = word.size() - 2; i > 0; --i) {
        if (vowels.find(word[i]) != std::string::npos && 
            vowels.find(word[i-1]) == std::string::npos &&
            vowels.find(word[i+1]) == std::string::npos) {
            return std::string(1, word[i]);
        }
    }
    return """";"
1,1.0,HumanEval_118_get_closest_vowel,"

std::string get_closest_vowel(std::string word) {
    std::string vowels = ""aeiouAEIOU"";
    for (int i = word.size()-2; i > 0; --i) {
        if (vowels.find(word[i]) != std::string::npos && 
            vowels.find(word[i-1]) == std::string::npos && 
            vowels.find(word[i+1]) == std::string::npos) {
            return std::string(1, word[i]);
        }
    }
    return """";
"
0,1.0,HumanEval_118_get_closest_vowel,"

std::string get_closest_vowel(std::string word) {
    for (int i = word.size() - 2; i > 0; --i) {
        if (!isVowel(word[i]) && !isVowel(word[i-1]) && isVowel(word[i+1])) {
            return std::string(1, word[i]);
        }
    }
    return """";"
1,1.0,HumanEval_118_get_closest_vowel,"
std::string get_closest_vowel(std::string word) {
    std::string vowels = ""aeiouAEIOU"";
    for (int i = word.size() - 2; i > 0; --i) {
        if (vowels.find(word[i]) != std::string::npos && 
            vowels.find(word[i-1]) == std::string::npos && 
            vowels.find(word[i+1]) == std::string::npos) {
            return std::string(1, word[i]);
        }
    }
    return """";"
0,0.0,HumanEval_118_get_closest_vowel,"
    std::string vowels = ""aeiouAEIOU"";
    for (int i = word.size() - 2; i > 0; --i) {
        if (vowels.find(word[i]) != std::string::npos && 
            vowels.find(word[i-1]) == std::string::npos && 
            vowels.find(word[i+1]) == std::string::npos) {
            return std::string(1, word[i]);
        }
    }
    return """";"
1,1.0,HumanEval_118_get_closest_vowel,"
std::string get_closest_vowel(std::string word) {
    std::string vowels = ""aeiouAEIOU"";
    for(int i = word.size() - 2; i > 0; i--){
        if(vowels.find(word[i]) != std::string::npos && 
           vowels.find(word[i-1]) == std::string::npos && 
           vowels.find(word[i+1]) == std::string::npos){
            return std::string(1, word[i]);
        }
    }
    return """";
"
1,1.0,HumanEval_118_get_closest_vowel,"

std::string get_closest_vowel(std::string word) {
    std::string vowels = ""aeiouAEIOU"";
    for (int i = word.length() - 2; i > 0; --i) {
        if (vowels.find(word[i]) != std::string::npos && 
            vowels.find(word[i-1]) == std::string::npos && 
            vowels.find(word[i+1]) == std::string::npos) {
            return std::string(1, word[i]);
        }
    }
    return """";
"
1,1.0,HumanEval_118_get_closest_vowel,"
std::string get_closest_vowel(std::string word) {
    std::string vowels = ""aeiouAEIOU"";
    for (int i = word.size() - 2; i > 0; --i) {
        if (vowels.find(word[i]) != std::string::npos && 
            vowels.find(word[i-1]) == std::string::npos && 
            vowels.find(word[i+1]) == std::string::npos) {
            return std::string(1, word[i]);
        }
    }
    return """";
"
1,1.0,HumanEval_118_get_closest_vowel,"
std::string get_closest_vowel(std::string word) {
    std::string vowels = ""aeiouAEIOU"";
    for (int i = word.length() - 2; i > 0; --i) {
        if (vowels.find(word[i]) != std::string::npos && 
            vowels.find(word[i-1]) == std::string::npos && 
            vowels.find(word[i+1]) == std::string::npos) {
            return std::string(1, word[i]);
        }
    }
    return """";"
1,1.0,HumanEval_118_get_closest_vowel,"

std::string get_closest_vowel(std::string word) {
    std::string vowels = ""aeiouAEIOU"";
    for (int i = word.size() - 2; i > 0; i--) {
        if (vowels.find(word[i]) != std::string::npos && 
            vowels.find(word[i-1]) == std::string::npos && 
            vowels.find(word[i+1]) == std::string::npos) {
            return std::string(1, word[i]);
        }
    }
    return """";"
1,1.0,HumanEval_31_is_prime,"
bool is_prime(long n) {
    if (n <= 1) {
        return false;
    }
    if (n <= 3) {
        return true;
    }
    if (n % 2 == 0 || n % 3 == 0) {
        return false;
    }
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
    }
    return true;"
1,1.0,HumanEval_31_is_prime,"
bool is_prime(long n) {
    // 0 and 1 are not prime numbers
    if (n <= 1) {
        return false;
    }
    // 2 and 3 are prime numbers
    if (n <= 3) {
        return true;
    }
    // check for divisibility by 2 and 3
    if (n % 2 == 0 || n % 3 == 0) {
        return false;
    }
    // check for divisibility by numbers of the form 6k ± 1 up to sqrt(n)
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
    }
    // if no divisors found, n is prime
    return true;
"
1,1.0,HumanEval_31_is_prime,"
bool is_prime(long n) {
    if (n <= 1) {
        return false;
    }
    if (n <= 3) {
        return true;
    }
    if (n % 2 == 0 || n % 3 == 0) {
        return false;
    }
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
    }
    return true;"
1,1.0,HumanEval_31_is_prime,"

bool is_prime(long n) {
    if (n <= 1) {
        return false;
    }
    if (n <= 3) {
        return true;
    }
    if (n % 2 == 0 || n % 3 == 0) {
        return false;
    }
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
    }
    return true;
"
1,1.0,HumanEval_31_is_prime,"
bool is_prime(long n) {
    if (n <= 1) {
        return false;
    }
    if (n == 2) {
        return true;
    }
    if (n % 2 == 0) {
        return false;
    }
    for (long i = 3; i * i <= n; i += 2) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
"
0,0.0,HumanEval_31_is_prime,"
    // Check if the number is less than 2, if so, it is not a prime number
    if (n < 2) {
        return false;
    }

    // Check if the number is divisible by any number up to its square root
    for (long i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            return false;
        }
    }

    // If the number is not divisible by any number up to its square root, it is a prime number
    return true;"
0,1.0,HumanEval_31_is_prime,"
    // Check if the number is less than 2 (the smallest prime number)
    if (n < 2) {
        return false;
    }
    // Check if the number is 2 or 3 (the smallest prime numbers)
    if (n <= 3) {
        return true;
    }
    // Check if the number is divisible by 2 or 3
    if (n % 2 == 0 || n % 3 == 0) {
        return false;
    }
    // Check the rest of the numbers
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
    }
    return true;"
0,0.0,HumanEval_31_is_prime,"
    if (n <= 1) {
        return false;
    }
    if (n <= 3) {
        return true;
    }
    if (n % 2 == 0 || n % 3 == 0) {
        return false;
    }
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
    }
    return true;
"
1,1.0,HumanEval_31_is_prime,"
bool is_prime(long n) {
    // Corner cases
    if (n <= 1)  return false;
    if (n <= 3)  return true;
  
    // This is checked so that we can skip 
    // middle five numbers in below loop
    if (n%2 == 0 || n%3 == 0) return false;
  
    for (long i=5; i*i<=n; i=i+6)
        if (n%i == 0 || n%(i+2) == 0)
           return false;
  
    return true;"
1,1.0,HumanEval_31_is_prime,"
bool is_prime(long n) {
    // Edge cases
    if (n <= 1) return false;
    if (n <= 3) return true;

    // This is checked so that we can skip middle five numbers in below loop
    if (n % 2 == 0 || n % 3 == 0) return false;

    for (long i = 5; i * i <= n; i += 6)
        if (n % i == 0 || n % (i + 2) == 0)
            return false;

    return true;"
0,0.0,HumanEval_144_simplify,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

// Function to convert string to integer
int convert(string s) {
    int num = 0;
    for (int i = 0; i < s.size(); i++) {
        num = num * 10 + (s[i] - '0');
    }
    return num;
}

// Function to simplify the fraction
pair<int, int> simplify(string x) {
    int pos = x.find('/');
    int num = convert(x.substr(0, pos));
    int den = convert(x.substr(pos + 1));
    int gcd = __gcd(num, den);
    return make_pair(num / gcd, den / gcd);
}

// Main function
bool simplify(string x, string n) {
    pair<int, int> frac1 = simplify(x);
    pair<int, int> frac2 = simplify(n);
    return (frac1.first == frac2.first && frac1.second == frac2.second);"
0,0.0,HumanEval_144_simplify,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

bool simplify(string x, string n) {
    size_t pos = x.find(""/"");
    string num1 = x.substr(0, pos);
    string den1 = x.substr(pos + 1);

    pos = n.find(""/"");
    string num2 = n.substr(0, pos);
    string den2 = n.substr(pos + 1);

    string num = to_string(stoi(num1) * stoi(num2));
    string den = to_string(stoi(den1) * stoi(den2));

    int gcd = __gcd(stoi(num), stoi(den));

    num = to_string(stoi(num) / gcd);
    den = to_string(stoi(den) / gcd);

    return num == den;
"
0,0.0,HumanEval_144_simplify,"
bool simplify(std::string x, std::string n) {
    std::size_t pos = x.find(""/"");
    int num1 = std::stoi(x.substr(0, pos));
    int den1 = std::stoi(x.substr(pos + 1));

    pos = n.find(""/"");
    int num2 = std::stoi(n.substr(0, pos));
    int den2 = std::stoi(n.substr(pos + 1));

    return ((num1 * den2) == (num2 * den1));
"
1,0.0,HumanEval_144_simplify,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

// Function to convert string to int
int stringToInt(string s) {
    int num = 0;
    for(int i = 0; i < s.length(); i++)
        num = num * 10 + (s[i] - '0');
    return num;
}

// Function to simplify the expression
bool simplify(string x, string n) {
    // Split the strings into numerator and denominator
    string x_num_str = x.substr(0, x.find(""/""));
    string x_den_str = x.substr(x.find(""/"") + 1);
    string n_num_str = n.substr(0, n.find(""/""));
    string n_den_str = n.substr(n.find(""/"") + 1);

    // Convert strings to int
    int x_num = stringToInt(x_num_str);
    int x_den = stringToInt(x_den_str);
    int n_num = stringToInt(n_num_str);
    int n_den = stringToInt(n_den_str);

    // Simplify the expression
    int new_num = x_num * n_num;
    int new_den = x_den * n_den;

    // Check if the result is a whole number
    return new_num % new_den == 0;
"
1,0.0,HumanEval_144_simplify,"

bool simplify(std::string x, std::string n) {
    // Find the position of the slash in the strings
    size_t pos = x.find('/');

    // Extract the numerator and denominator of x
    int x_numerator = std::stoi(x.substr(0, pos));
    int x_denominator = std::stoi(x.substr(pos + 1));

    // Find the position of the slash in the strings
    pos = n.find('/');

    // Extract the numerator and denominator of n
    int n_numerator = std::stoi(n.substr(0, pos));
    int n_denominator = std::stoi(n.substr(pos + 1));

    // Check if x * n evaluates to a whole number
    return (x_numerator * n_numerator) % (x_denominator * n_denominator) == 0;"
0,1.0,HumanEval_144_simplify,"
bool simplify(std::string x, std::string n) {
    int num1 = convert_to_int(x.substr(0, x.find('/')));
    int den1 = convert_to_int(x.substr(x.find('/') + 1));
    int num2 = convert_to_int(n.substr(0, n.find('/')));
    int den2 = convert_to_int(n.substr(n.find('/') + 1));

    // Check if the expression is a whole number
    if((num1 * den2) % (num2 * den1) == 0)
        return true;
    else
        return false;"
0,1.0,HumanEval_144_simplify,"

bool simplify(std::string x, std::string n) {
    // Find the position of the slash in the strings
    size_t pos = x.find('/');

    // Extract the numerator and denominator from the strings
    int numerator_x = std::stoi(x.substr(0, pos));
    int denominator_x = std::stoi(x.substr(pos + 1));

    pos = n.find('/');
    int numerator_n = std::stoi(n.substr(0, pos));
    int denominator_n = std::stoi(n.substr(pos + 1));

    // Check if the result of the multiplication is a whole number
    if ((numerator_x * numerator_n) % (denominator_x * denominator_n) == 0) {
        return true;
    } else {
        return false;
    }"
1,0.0,HumanEval_144_simplify,"

bool simplify(std::string x, std::string n) {
    // Extract numerators and denominators
    std::string x_num = x.substr(0, x.find('/'));
    std::string x_den = x.substr(x.find('/') + 1);
    std::string n_num = n.substr(0, n.find('/'));
    std::string n_den = n.substr(n.find('/') + 1);

    // Convert strings to integers
    int x_numerator = std::stoi(x_num);
    int x_denominator = std::stoi(x_den);
    int n_numerator = std::stoi(n_num);
    int n_denominator = std::stoi(n_den);

    // Multiply numerators and denominators
    int new_num = x_numerator * n_numerator;
    int new_den = x_denominator * n_denominator;

    // Check if the new number is an integer
    if (new_num % new_den == 0) {
        return true;
    } else {
        return false;
    }
"
0,1.0,HumanEval_144_simplify,"

bool simplify(std::string x, std::string n) {
    // Extract numerator and denominator from the strings
    size_t pos = x.find(""/"");
    int x_numerator = std::stoi(x.substr(0, pos));
    int x_denominator = std::stoi(x.substr(pos + 1));

    pos = n.find(""/"");
    int n_numerator = std::stoi(n.substr(0, pos));
    int n_denominator = std::stoi(n.substr(pos + 1));

    // Check if the result of the multiplication is a whole number
    return (x_numerator * n_denominator) % x_denominator == 0 && (n_numerator * x_denominator) % n_denominator == 0;
"
0,0.0,HumanEval_144_simplify,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

// Function to calculate gcd of two numbers
int gcd(int a, int b) {
    if (b == 0)
        return a;
    return gcd(b, a % b);
}

// Function to simplify the expression
bool simplify(string x, string n) {
    // Extract numerator and denominator from the string
    int x_num = stoi(x.substr(0, x.find(""/"")));
    int x_den = stoi(x.substr(x.find(""/"") + 1));
    int n_num = stoi(n.substr(0, n.find(""/"")));
    int n_den = stoi(n.substr(n.find(""/"") + 1));

    // Calculate gcd of numerators and denominators
    int g = gcd(x_num * n_den, n_num * x_den);

    // Check if the expression is a whole number
    if ((x_num * n_den * n_num * x_den) % (g * g) == 0)
        return true;
    else
        return false;
"
0,1.0,HumanEval_78_hex_key,"
long hex_key(std::string num) {
    std::string prime_hex = ""2357BDF"";
    long count = 0;
    for (char c : num) {
        if (prime_hex.find(c) != std::string::npos) {
            count++;
        }
    }
    return count;"
0,1.0,HumanEval_78_hex_key,"
long hex_key(std::string num) {
    std::string primes = ""2357BDF"";
    long count = 0;
    for (char c : num) {
        if (primes.find(c) != std::string::npos) {
            count++;
        }
    }
    return count;"
1,1.0,HumanEval_78_hex_key,"
long hex_key(std::string num) {
    std::set<char> primes = {'2', '3', '5', '7', 'B', 'D'};
    long count = 0;
    for (char c : num) {
        if (primes.count(c)) {
            count++;
        }
    }
    return count;"
1,1.0,HumanEval_78_hex_key,"
long hex_key(std::string num) {
    std::set<char> primes = {'2', '3', '5', '7', 'B', 'D'};
    long count = 0;
    for (char c : num) {
        if (primes.find(c) != primes.end()) {
            count++;
        }
    }
    return count;"
0,1.0,HumanEval_78_hex_key,"

long hex_key(std::string num) {
    std::string prime_hex = ""2357BDF""; // Prime hexadecimal digits
    long count = 0;
    for(char c : num) {
        if(prime_hex.find(c) != std::string::npos) {
            count++;
        }
    }
    return count;"
0,1.0,HumanEval_78_hex_key,"
long hex_key(std::string num) {
    std::string prime_hex = ""2357BDF"";
    long count = 0;
    for(char c : num) {
        if(prime_hex.find(c) != std::string::npos) {
            count++;
        }
    }
    return count;"
0,1.0,HumanEval_78_hex_key,"
long hex_key(std::string num) {
    std::string prime_hex = ""2357BDF"";
    long count = 0;
    for (char c : num) {
        if (prime_hex.find(c) != std::string::npos) {
            count++;
        }
    }
    return count;
"
0,0.0,HumanEval_78_hex_key,"
    long count = 0;
    for (char c : num) {
        if (c >= '0' && c <= '9') {
            if (c == '2' || c == '3' || c == '5' || c == '7') {
                count++;
            }
        } else if (c == 'A' || c == 'B' || c == 'D') {
            count++;
        }
    }
    return count;
"
0,1.0,HumanEval_78_hex_key,"

long hex_key(std::string num) {
    std::string prime_hex_digits = ""2357BDF"";
    long count = 0;
    for (char c : num) {
        if (prime_hex_digits.find(c) != std::string::npos) {
            count++;
        }
    }
    return count;
"
0,1.0,HumanEval_78_hex_key,"
long hex_key(std::string num) {
    std::string primes = ""2357BDF"";
    long count = 0;
    for(char c : num) {
        if(primes.find(c) != std::string::npos) {
            count++;
        }
    }
    return count;"
0,1.0,HumanEval_143_words_in_sentence,"

std::string words_in_sentence(std::string sentence) {
    std::string result = """";
    std::string word = """";
    for (int i = 0; i < sentence.length(); i++) {
        if (sentence[i] == ' ') {
            if (is_prime(word.length())) {
                if (result != """") 
                    result += "" "";
                result += word;
            }
            word = """";
        } else {
            word += sentence[i];
        }
    }
    if (is_prime(word.length())) {
        if (result != """") 
            result += "" "";
        result += word;
    }
    return result;
"
0,1.0,HumanEval_143_words_in_sentence,"

std::string words_in_sentence(std::string sentence) {
    stringstream ss(sentence);
    string word;
    string result = """";
    while (ss >> word) {
        if (isPrime(word.length())) {
            result += word + "" "";
        }
    }
    if (result.length() > 0) result.pop_back(); // remove the last space
    return result;"
0,0.0,HumanEval_143_words_in_sentence,"
    std::string result = """";
    std::istringstream ss(sentence);
    std::string word;
    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};

    while (ss >> word) {
        if (std::find(primes.begin(), primes.end(), word.length()) != primes.end()) {
            result += word + "" "";
        }
    }

    if (result.length() > 0) {
        result.pop_back(); // remove the last space
    }

    return result;
"
0,0.0,HumanEval_143_words_in_sentence,"
    std::istringstream ss(sentence);
    std::string word;
    std::vector<std::string> words;
    while (ss >> word) {
        words.push_back(word);
    }

    auto is_prime = [](int n) {
        if (n <= 1) return false;
        if (n == 2) return true;
        if (n % 2 == 0) return false;
        for (int i = 3; i * i <= n; i += 2) {
            if (n % i == 0) return false;
        }
        return true;
    };

    std::string result;
    for (const auto& word : words) {
        if (is_prime(word.size())) {
            if (!result.empty()) result += "" "";
            result += word;
        }
    }
    return result;"
0,1.0,HumanEval_143_words_in_sentence,"

std::string words_in_sentence(std::string sentence) {
    std::stringstream ss(sentence);
    std::string word;
    std::string result = """";
    while (ss >> word) {
        if (isPrime(word.length())) {
            if (!result.empty())
                result += "" "";
            result += word;
        }
    }
    return result;"
0,1.0,HumanEval_143_words_in_sentence,"

std::string words_in_sentence(std::string sentence) {
    std::string word = """";
    std::string result = """";
    for (int i = 0; i < sentence.length(); i++) {
        if (sentence[i] == ' ') {
            if (is_prime(word.length())) {
                if (!result.empty())
                    result += "" "";
                result += word;
            }
            word = """";
        } else {
            word += sentence[i];
        }
    }
    if (is_prime(word.length())) {
        if (!result.empty())
            result += "" "";
        result += word;
    }
    return result;"
0,0.0,HumanEval_143_words_in_sentence,"
    std::string result = """";
    std::string word = """";
    std::vector<std::string> words;
    for (int i = 0; i < sentence.length(); i++) {
        if (sentence[i] == ' ') {
            words.push_back(word);
            word = """";
        } else {
            word += sentence[i];
        }
    }
    words.push_back(word);

    auto isPrime = [](int num) {
        if (num <= 1) {
            return false;
        }
        for (int i = 2; i * i <= num; i++) {
            if (num % i == 0) {
                return false;
            }
        }
        return true;
    };

    for (auto &w : words) {
        if (isPrime(w.length())) {
            if (!result.empty()) {
                result += "" "";
            }
            result += w;
        }
    }
    return result;
"
0,0.0,HumanEval_143_words_in_sentence,"

std::string words_in_sentence(std::string sentence) {
    std::stringstream ss(sentence);
    std::string word;
    std::string result;
    while (ss >> word) {
        if (is_prime(word.length())) {
            result += word + "" "";
        }
    }
    if (!result.empty())
        result.pop_back();
    return result;"
0,1.0,HumanEval_143_words_in_sentence,"

std::string words_in_sentence(std::string sentence) {
    stringstream ss(sentence);
    string word;
    string result = """";
    while (ss >> word) {
        if (isPrime(word.length())) {
            result += word + "" "";
        }
    }
    if (!result.empty()) result.pop_back(); // remove the trailing space
    return result;"
0,1.0,HumanEval_143_words_in_sentence,"

std::string words_in_sentence(std::string sentence) {
    stringstream ss(sentence);
    string word;
    string result = """";
    
    while(ss >> word) {
        if(isPrime(word.length())) {
            result += word + "" "";
        }
    }
    
    if(result.length() > 0)
        result.pop_back(); // remove the last space
        
    return result;
"
1,0.0,HumanEval_111_histogram,"

std::map<std::string,long> histogram(std::string test) {
    std::map<std::string, long> count_map;
    std::istringstream iss(test);
    std::string word;
    while (iss >> word) {
        count_map[word]++;
    }

    long max_count = 0;
    for (auto &p : count_map) {
        max_count = std::max(max_count, p.second);
    }

    std::map<std::string, long> result;
    for (auto &p : count_map) {
        if (p.second == max_count) {
            result[p.first] = p.second;
        }
    }
    return result;
"
1,1.0,HumanEval_111_histogram,"

std::map<std::string,long> histogram(std::string test) {
    std::map<std::string, long> count;
    std::istringstream iss(test);
    std::string word;
    
    while (iss >> word) {
        count[word]++;
    }
    
    long maxCount = 0;
    for (auto it = count.begin(); it != count.end(); ++it) {
        maxCount = std::max(maxCount, it->second);
    }
    
    std::map<std::string,long> result;
    for (auto it = count.begin(); it != count.end(); ++it) {
        if (it->second == maxCount) {
            result[it->first] = it->second;
        }
    }
    
    return result;
"
1,1.0,HumanEval_111_histogram,"

std::map<std::string,long> histogram(std::string test) {
    std::map<std::string, long> freq;
    std::istringstream iss(test);
    std::string word;

    while (iss >> word) {
        freq[word]++;
    }

    long maxCount = 0;
    for (auto &it : freq) {
        maxCount = std::max(maxCount, it.second);
    }

    std::map<std::string, long> result;
    for (auto &it : freq) {
        if (it.second == maxCount) {
            result[it.first] = it.second;
        }
    }

    return result;
"
1,0.0,HumanEval_111_histogram,"

std::map<std::string,long> histogram(std::string test) {
    std::map<std::string,long> frequency;
    std::stringstream ss(test);
    std::string word;

    while (ss >> word) {
        frequency[word]++;
    }

    long max_count = 0;
    for (auto it = frequency.begin(); it != frequency.end(); ++it) {
        max_count = std::max(max_count, it->second);
    }

    std::map<std::string,long> result;
    for (auto it = frequency.begin(); it != frequency.end(); ++it) {
        if (it->second == max_count) {
            result[it->first] = it->second;
        }
    }

    return result;"
1,0.0,HumanEval_111_histogram,"

std::map<std::string,long> histogram(std::string test) {
    std::map<std::string, long> count;
    std::istringstream iss(test);
    std::string word;

    while(iss >> word) {
        count[word]++;
    }

    long maxCount = 0;
    for(auto const& pair: count) {
        maxCount = std::max(maxCount, pair.second);
    }

    std::map<std::string, long> result;
    for(auto const& pair: count) {
        if(pair.second == maxCount) {
            result[pair.first] = pair.second;
        }
    }

    return result;
"
1,0.0,HumanEval_111_histogram,"
std::map<std::string,long> histogram(std::string test) {
    std::map<std::string,long> count;
    std::stringstream ss(test);
    std::string word;
    while (ss >> word) {
        count[word]++;
    }

    long maxCount = 0;
    for(auto& pair : count) {
        if(pair.second > maxCount) {
            maxCount = pair.second;
        }
    }

    std::map<std::string,long> result;
    for(auto& pair : count) {
        if(pair.second == maxCount) {
            result[pair.first] = pair.second;
        }
    }

    return result;"
1,0.0,HumanEval_111_histogram,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

map<string,long> histogram(string test) {
    map<string, long> count;
    stringstream ss(test);
    string word;
    while (ss >> word) {
        count[word]++;
    }

    long max_count = 0;
    for (auto& pair : count) {
        max_count = max(max_count, pair.second);
    }

    map<string, long> result;
    for (auto& pair : count) {
        if (pair.second == max_count) {
            result[pair.first] = pair.second;
        }
    }

    return result;
"
1,0.0,HumanEval_111_histogram,"

std::map<std::string,long> histogram(std::string test) {
    std::map<std::string,long> result;
    std::stringstream ss(test);
    std::string word;
    while (ss >> word) {
        result[word]++;
    }
    long maxCount = 0;
    for (auto& pair : result) {
        maxCount = std::max(maxCount, pair.second);
    }
    std::map<std::string,long> finalResult;
    for (auto& pair : result) {
        if (pair.second == maxCount) {
            finalResult[pair.first] = pair.second;
        }
    }
    return finalResult;"
1,0.0,HumanEval_111_histogram,"

std::map<std::string,long> histogram(std::string test) {
    std::map<std::string, long> hist;
    std::stringstream ss(test);
    std::string word;
    while (ss >> word) {
        hist[word]++;
    }

    long maxCount = 0;
    for(auto const& x : hist) {
        if(x.second > maxCount) {
            maxCount = x.second;
        }
    }

    std::map<std::string,long> result;
    for(auto const& x : hist) {
        if(x.second == maxCount) {
            result[x.first] = x.second;
        }
    }

    return result;"
1,0.0,HumanEval_111_histogram,"

std::map<std::string,long> histogram(std::string test) {
    std::map<std::string,long> result;
    std::istringstream ss(test);
    std::string word;
    while(ss >> word) {
        result[word]++;
    }

    long maxCount = 0;
    for(auto it = result.begin(); it != result.end(); ++it) {
        maxCount = std::max(maxCount, it->second);
    }

    for(auto it = result.begin(); it != result.end();) {
        if(it->second != maxCount) {
            result.erase(it++);
        } else {
            ++it;
        }
    }

    return result;"
0,0.0,HumanEval_87_get_row,"
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
    std::vector<std::tuple<long, long>> result;

    for (long i = 0; i < lst.size(); i++) {
        for (long j = 0; j < lst[i].size(); j++) {
            if (lst[i][j] == x) {
                result.push_back(std::make_tuple(i, j));
            }
        }
    }

    // Sort coordinates initially by rows in ascending order.
    std::sort(result.begin(), result.end());

    // Also, sort coordinates of the row by columns in descending order.
    for (auto& row : result) {
        long col = std::get<1>(row);
        std::sort(result.begin(), result.end(), [col](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {
            return std::get<1>(a) == col ? std::get<0>(b) < std::get<0>(a) : std::get<1>(a) > std::get<1>(b);
        });
    }

    return result;"
0,0.0,HumanEval_87_get_row,"
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
    std::vector<std::tuple<long, long>> result;

    for (long i = 0; i < lst.size(); i++) {
        for (long j = 0; j < lst[i].size(); j++) {
            if (lst[i][j] == x) {
                result.push_back(std::make_tuple(i, j));
            }
        }
    }

    // Sort coordinates by rows in ascending order
    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {
        return std::get<0>(a) < std::get<0>(b);
    });

    // Sort coordinates of the row by columns in descending order
    for (auto& row : result) {
        long row_index = std::get<0>(row);
        std::vector<std::tuple<long, long>> temp;
        for (long j = 0; j < lst[row_index].size(); j++) {
            temp.push_back(std::make_tuple(row_index, j));
        }
        std::sort(temp.begin(), temp.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {
            return std::get<1>(b) < std::get<1>(a);
        });
        long k = 0;
        for (auto& t : temp) {
            std::get<1>(row) = k++;
            row = t;
        }
    }

    return result;
"
0,0.0,HumanEval_87_get_row,"

std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
    std::vector<std::tuple<long, long>> result;
    for(long i = 0; i < lst.size(); i++) {
        for(long j = 0; j < lst[i].size(); j++) {
            if(lst[i][j] == x) {
                result.push_back(std::make_tuple(i, j));
            }
        }
    }
    // Sort coordinates initially by rows in ascending order.
    std::sort(result.begin(), result.end());
    // Also, sort coordinates of the row by columns in descending order.
    for(auto &row : result) {
        long col = std::get<1>(row);
        std::sort(result.begin(), result.end(), [col](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {
            return std::get<1>(a) == col ? std::get<0>(b) < std::get<0>(a) : std::get<1>(a) > std::get<1>(b);
        });
    }
    return result;"
0,0.0,HumanEval_87_get_row,"

std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
    std::vector<std::tuple<long, long>> result;
    for (long i = 0; i < lst.size(); i++) {
        for (long j = 0; j < lst[i].size(); j++) {
            if (lst[i][j] == x) {
                result.push_back(std::make_tuple(i, j));
            }
        }
    }
    // Sort coordinates by rows in ascending order
    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {
        return std::get<0>(a) < std::get<0>(b);
    });
    // Sort coordinates of the row by columns in descending order
    for (auto& row : result) {
        std::vector<long> cols;
        for (long i = 0; i < lst[std::get<0>(row)].size(); i++) {
            if (lst[std::get<0>(row)][i] == x) {
                cols.push_back(i);
            }
        }
        std::sort(cols.begin(), cols.end(), std::greater<long>());
        for (long i = 0; i < cols.size(); i++) {
            if (std::get<1>(row) == cols[i]) {
                std::get<1>(row) = i;
                break;
            }
        }
    }
    return result;"
0,0.0,HumanEval_87_get_row,"
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
    std::vector<std::tuple<long, long>> result;
    for (long i = 0; i < lst.size(); i++) {
        for (long j = 0; j < lst[i].size(); j++) {
            if (lst[i][j] == x) {
                result.push_back(std::make_tuple(i, j));
            }
        }
    }
    // Sort coordinates by rows in ascending order
    std::sort(result.begin(), result.end());
    // Sort coordinates of the row by columns in descending order
    for (auto& row : result) {
        long row_index = std::get<0>(row);
        std::vector<long> columns;
        for (long j = 0; j < lst[row_index].size(); j++) {
            if (lst[row_index][j] == x) {
                columns.push_back(j);
            }
        }
        std::sort(columns.begin(), columns.end(), std::greater<long>());
        for (long j = 0; j < columns.size(); j++) {
            result[j] = std::make_tuple(row_index, columns[j]);
        }
    }
    return result;"
0,0.0,HumanEval_87_get_row,"
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
    std::vector<std::tuple<long, long>> coordinates;
    for (long i = 0; i < lst.size(); i++) {
        for (long j = 0; j < lst[i].size(); j++) {
            if (lst[i][j] == x) {
                coordinates.push_back(std::make_tuple(i, j));
            }
        }
    }

    // Sort coordinates by rows in ascending order.
    std::sort(coordinates.begin(), coordinates.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {
        return std::get<0>(a) < std::get<0>(b);
    });

    // Sort coordinates of the row by columns in descending order.
    for (auto& row : coordinates) {
        std::sort(coordinates.begin(), coordinates.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {
            return std::get<1>(a) > std::get<1>(b);
        });
    }

    return coordinates;"
1,1.0,HumanEval_87_get_row,"
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
    std::vector<std::tuple<long, long>> result;

    for(long i = 0; i < lst.size(); i++) {
        for(long j = 0; j < lst[i].size(); j++) {
            if(lst[i][j] == x) {
                result.push_back(std::make_tuple(i, j));
            }
        }
    }

    // Sort coordinates initially by rows in ascending order.
    // Also, sort coordinates of the row by columns in descending order.
    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {
        if(std::get<0>(a) == std::get<0>(b)) {
            return std::get<1>(a) > std::get<1>(b);
        }
        return std::get<0>(a) < std::get<0>(b);
    });

    return result;"
0,0.0,HumanEval_87_get_row,"
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
    std::vector<std::tuple<long, long>> result;
    for (long i = 0; i < lst.size(); ++i) {
        for (long j = 0; j < lst[i].size(); ++j) {
            if (lst[i][j] == x) {
                result.push_back(std::make_tuple(i, j));
            }
        }
    }
    // Sort coordinates by rows in ascending order
    std::sort(result.begin(), result.end());
    // Sort coordinates of the row by columns in descending order
    for (auto& row : result) {
        long col = std::get<1>(row);
        std::sort(result.begin(), result.end(), [col](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {
            return std::get<1>(a) > std::get<1>(b);
        });
    }
    return result;"
0,0.0,HumanEval_87_get_row,"
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
    std::vector<std::tuple<long, long>> result;
    for(long i = 0; i < lst.size(); i++) {
        for(long j = 0; j < lst[i].size(); j++) {
            if(lst[i][j] == x) {
                result.push_back(std::make_tuple(i, j));
            }
        }
    }
    // Sort coordinates by rows in ascending order
    std::sort(result.begin(), result.end());
    // Sort coordinates of the row by columns in descending order
    for(auto& row : result) {
        long col = std::get<1>(row);
        std::sort(result.begin(), result.end(), [col](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {
            return std::get<1>(a) != col ? std::get<1>(a) > std::get<1>(b) : std::get<0>(a) < std::get<0>(b);
        });
    }
    return result;
"
1,1.0,HumanEval_87_get_row,"
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
    std::vector<std::tuple<long, long>> result;

    // iterate over rows
    for (long i = 0; i < lst.size(); i++) {
        // iterate over columns in each row
        for (long j = 0; j < lst[i].size(); j++) {
            // if the value at the current position equals x, add the coordinate to the result
            if (lst[i][j] == x) {
                result.push_back(std::make_tuple(i, j));
            }
        }
    }

    // sort the result by rows in ascending order and by columns in descending order
    std::sort(result.begin(), result.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {
        if (std::get<0>(a) == std::get<0>(b)) {
            return std::get<1>(a) > std::get<1>(b);
        }
        return std::get<0>(a) < std::get<0>(b);
    });

    return result;"
1,1.0,HumanEval_123_get_odd_collatz,"
std::vector<long> get_odd_collatz(long n) {
    std::vector<long> collatz;
    while (n != 1) {
        if (n % 2 != 0) {
            collatz.push_back(n);
        }
        n = n % 2 ? n*3 + 1 : n / 2;
    }
    collatz.push_back(1);
    std::sort(collatz.begin(), collatz.end());
    return collatz;"
0,0.0,HumanEval_123_get_odd_collatz,"
    std::vector<long> collatz;
    while (n != 1) {
        if (n % 2 != 0) {
            collatz.push_back(n);
        }
        n = n % 2 ? n * 3 + 1 : n / 2;
    }
    collatz.push_back(1);
    std::sort(collatz.begin(), collatz.end());
    return collatz;
"
1,1.0,HumanEval_123_get_odd_collatz,"

std::vector<long> get_odd_collatz(long n) {
    std::vector<long> collatz;
    while (n != 1) {
        if (n % 2 != 0) {
            collatz.push_back(n);
        }
        n = n % 2 ? n * 3 + 1 : n / 2;
    }
    collatz.push_back(1);
    std::sort(collatz.begin(), collatz.end());
    return collatz;"
0,0.0,HumanEval_123_get_odd_collatz,"
    assert(n > 0);
    std::vector<long> collatz;
    while (n != 1) {
        if (n % 2 != 0) {
            collatz.push_back(n);
        }
        n = n % 2 ? n * 3 + 1 : n / 2;
    }
    collatz.push_back(1);
    std::sort(collatz.begin(), collatz.end());
    return collatz;
"
1,1.0,HumanEval_123_get_odd_collatz,"
std::vector<long> get_odd_collatz(long n) {
    std::vector<long> collatz;
    while (n != 1) {
        if (n % 2 != 0) {
            collatz.push_back(n);
        }
        n = n % 2 ? n * 3 + 1 : n / 2;
    }
    collatz.push_back(1);
    std::sort(collatz.begin(), collatz.end());
    return collatz;"
1,1.0,HumanEval_123_get_odd_collatz,"
std::vector<long> get_odd_collatz(long n) {
    std::vector<long> collatz;
    while (n != 1) {
        if (n % 2 != 0) {
            collatz.push_back(n);
        }
        n = n % 2 ? n * 3 + 1 : n / 2;
    }
    collatz.push_back(1);
    std::sort(collatz.begin(), collatz.end());
    return collatz;
"
1,1.0,HumanEval_123_get_odd_collatz,"
std::vector<long> get_odd_collatz(long n) {
    std::vector<long> collatz;
    while (n != 1) {
        collatz.push_back(n);
        if (n % 2 == 0) {
            n = n / 2;
        } else {
            n = 3 * n + 1;
        }
    }
    collatz.push_back(1);

    std::vector<long> odds;
    for (long num : collatz) {
        if (num % 2 != 0) {
            odds.push_back(num);
        }
    }
    std::sort(odds.begin(), odds.end());
    return odds;
"
1,1.0,HumanEval_123_get_odd_collatz,"

std::vector<long> get_odd_collatz(long n) {
    std::vector<long> collatz;
    while (n != 1) {
        collatz.push_back(n);
        n = n % 2 == 0 ? n / 2 : 3 * n + 1;
    }
    collatz.push_back(1);

    std::vector<long> odd_numbers;
    for (long num : collatz) {
        if (num % 2 != 0) {
            odd_numbers.push_back(num);
        }
    }

    std::sort(odd_numbers.begin(), odd_numbers.end());
    return odd_numbers;
"
1,1.0,HumanEval_123_get_odd_collatz,"
std::vector<long> get_odd_collatz(long n) {
    std::vector<long> collatz;
    while (n != 1) {
        if (n % 2 != 0) {
            collatz.push_back(n);
        }
        n = n % 2 ? n*3 + 1 : n / 2;
    }
    collatz.push_back(1);
    std::sort(collatz.begin(), collatz.end());
    return collatz;"
1,1.0,HumanEval_123_get_odd_collatz,"
std::vector<long> get_odd_collatz(long n) {
    std::vector<long> collatz;
    while (n != 1) {
        if (n % 2 != 0) {
            collatz.push_back(n);
        }
        n = (n % 2 == 0) ? n / 2 : 3 * n + 1;
    }
    collatz.push_back(1);
    std::sort(collatz.begin(), collatz.end());
    return collatz;
"
0,0.0,HumanEval_135_can_arrange,"
    long n = arr.size();
    long max_idx = -1;
    for(long i = n - 1; i > 0; --i) {
        if(arr[i] < arr[i-1]) {
            max_idx = i;
        } else {
            max_idx = i-1;
            break;
        }
    }
    return max_idx;"
1,1.0,HumanEval_135_can_arrange,"
long can_arrange(std::vector<long> arr) {
    long n = arr.size();
    for (long i = n - 1; i > 0; i--) {
        if (arr[i] < arr[i - 1]) {
            return i;
        }
    }
    return -1;"
1,1.0,HumanEval_135_can_arrange,"
long can_arrange(std::vector<long> arr) {
    long n = arr.size();
    for(long i = n - 1; i > 0; --i) {
        if(arr[i] < arr[i-1])
            return i;
    }
    return -1;
"
0,1.0,HumanEval_135_can_arrange,"

long can_arrange(std::vector<long> arr) {
    long max_idx = -1;
    for (long i = arr.size() - 1; i > 0; i--) {
        if (arr[i] < arr[i-1]) {
            max_idx = i;
        } else {
            max_idx = -1;
            break;
        }
    }
    return max_idx;"
0,0.0,HumanEval_135_can_arrange,"
    long n = arr.size();
    long max_index = -1;
    for (long i = n - 1; i > 0; i--) {
        if (arr[i] < arr[i - 1]) {
            max_index = i;
            break;
        }
    }
    return max_index;
"
1,1.0,HumanEval_135_can_arrange,"

long can_arrange(std::vector<long> arr) {
    long n = arr.size();
    for(long i = n - 1; i > 0; i--) {
        if(arr[i] < arr[i-1]) {
            return i;
        }
    }
    return -1;
"
1,1.0,HumanEval_135_can_arrange,"

long can_arrange(std::vector<long> arr) {
    long n = arr.size();
    for(long i = n - 1; i > 0; i--) {
        if(arr[i] < arr[i-1]) {
            return i;
        }
    }
    return -1;"
1,1.0,HumanEval_135_can_arrange,"

long can_arrange(std::vector<long> arr) {
    long n = arr.size();
    if(n == 0) return -1;
    long max_index = -1;
    for(long i = n-1; i > 0; i--) {
        if(arr[i] < arr[i-1]) {
            max_index = i;
            break;
        }
    }
    return max_index;"
1,1.0,HumanEval_135_can_arrange,"
long can_arrange(std::vector<long> arr) {
    long n = arr.size();
    for(long i = n - 1; i > 0; --i) {
        if(arr[i] < arr[i-1]) {
            return i;
        }
    }
    return -1;"
1,1.0,HumanEval_135_can_arrange,"
long can_arrange(std::vector<long> arr) {
    long n = arr.size();
    for(long i = n - 1; i > 0; i--) {
        if(arr[i] < arr[i-1]) {
            return i;
        }
    }
    return -1;"
1,1.0,HumanEval_19_sort_numbers,"
std::string sort_numbers(std::string numbers) {
    std::unordered_map<std::string, int> word_to_num = {{""zero"", 0}, {""one"", 1}, {""two"", 2}, {""three"", 3}, 
                                                       {""four"", 4}, {""five"", 5}, {""six"", 6}, {""seven"", 7}, 
                                                       {""eight"", 8}, {""nine"", 9}};
    std::unordered_map<int, std::string> num_to_word = {{0, ""zero""}, {1, ""one""}, {2, ""two""}, {3, ""three""}, 
                                                       {4, ""four""}, {5, ""five""}, {6, ""six""}, {7, ""seven""}, 
                                                       {8, ""eight""}, {9, ""nine""}};

    std::istringstream iss(numbers);
    std::vector<std::string> words((std::istream_iterator<std::string>(iss)),
                                     std::istream_iterator<std::string>());

    std::vector<int> nums;
    for (const auto &word : words) {
        nums.push_back(word_to_num[word]);
    }

    std::sort(nums.begin(), nums.end());

    std::string sorted_numbers = """";
    for (const auto &num : nums) {
        if (!sorted_numbers.empty()) {
            sorted_numbers += "" "";
        }
        sorted_numbers += num_to_word[num];
    }

    return sorted_numbers;
"
1,1.0,HumanEval_19_sort_numbers,"

std::string sort_numbers(std::string numbers) {
    std::unordered_map<std::string, std::string> num_map = {{""zero"", ""0""}, {""one"", ""1""}, {""two"", ""2""}, {""three"", ""3""}, {""four"", ""4""}, {""five"", ""5""}, {""six"", ""6""}, {""seven"", ""7""}, {""eight"", ""8""}, {""nine"", ""9""}};
    std::unordered_map<std::string, std::string> inv_map = {{""0"", ""zero""}, {""1"", ""one""}, {""2"", ""two""}, {""3"", ""three""}, {""4"", ""four""}, {""5"", ""five""}, {""6"", ""six""}, {""7"", ""seven""}, {""8"", ""eight""}, {""9"", ""nine""}};

    std::stringstream ss(numbers);
    std::string word;
    std::vector<std::string> nums;

    while (ss >> word) {
        nums.push_back(num_map[word]);
    }

    std::sort(nums.begin(), nums.end());

    std::string sorted_numbers = """";
    for (auto num : nums) {
        sorted_numbers += (inv_map[num] + "" "");
    }

    return sorted_numbers.substr(0, sorted_numbers.size() - 1);  // Remove trailing space"
1,0.0,HumanEval_19_sort_numbers,"

std::string sort_numbers(std::string numbers) {
    std::unordered_map<std::string, std::string> num_map = {
        {""zero"", ""0""},
        {""one"", ""1""},
        {""two"", ""2""},
        {""three"", ""3""},
        {""four"", ""4""},
        {""five"", ""5""},
        {""six"", ""6""},
        {""seven"", ""7""},
        {""eight"", ""8""},
        {""nine"", ""9""}
    };
    
    std::unordered_map<std::string, std::string> rev_map = {
        {""0"", ""zero""},
        {""1"", ""one""},
        {""2"", ""two""},
        {""3"", ""three""},
        {""4"", ""four""},
        {""5"", ""five""},
        {""6"", ""six""},
        {""7"", ""seven""},
        {""8"", ""eight""},
        {""9"", ""nine""}
    };
    
    std::istringstream iss(numbers);
    std::vector<std::string> tokens{std::istream_iterator<std::string>{iss}, std::istream_iterator<std::string>{}};
    
    std::sort(tokens.begin(), tokens.end(), [&](std::string a, std::string b) {
        return num_map[a] < num_map[b];
    });
    
    std::string sorted_numbers = """";
    for(auto& token : tokens) {
        sorted_numbers += rev_map[num_map[token]] + "" "";
    }
    
    return sorted_numbers.substr(0, sorted_numbers.size()-1);"
0,1.0,HumanEval_19_sort_numbers,"

std::string sort_numbers(std::string numbers) {
    std::map<std::string, std::string> words_to_nums = {{""zero"", ""0""}, {""one"", ""1""}, {""two"", ""2""}, {""three"", ""3""}, {""four"", ""4""}, {""five"", ""5""}, {""six"", ""6""}, {""seven"", ""7""}, {""eight"", ""8""}, {""nine"", ""9""}};
    std::map<std::string, std::string> nums_to_words = {{""0"", ""zero""}, {""1"", ""one""}, {""2"", ""two""}, {""3"", ""three""}, {""4"", ""four""}, {""5"", ""five""}, {""6"", ""six""}, {""7"", ""seven""}, {""8"", ""eight""}, {""9"", ""nine""}};

    std::istringstream iss(numbers);
    std::vector<std::string> tokens{std::istream_iterator<std::string>{iss}, std::istream_iterator<std::string>{}};

    std::vector<std::string> nums;
    for(auto &token : tokens) {
        assert(words_to_nums.count(token));
        nums.push_back(words_to_nums[token]);
    }

    std::sort(nums.begin(), nums.end());

    std::vector<std::string> sorted_tokens;
    for(auto &num : nums) {
        assert(nums_to_words.count(num));
        sorted_tokens.push_back(nums_to_words[num]);
    }

    std::ostringstream oss;
    std::copy(sorted_tokens.begin(), sorted_tokens.end() - 1,
        std::ostream_iterator<std::string>(oss, "" ""));
    oss << sorted_tokens.back();

    return oss.str();"
1,1.0,HumanEval_19_sort_numbers,"

std::string sort_numbers(std::string numbers) {
    std::unordered_map<std::string, std::string> word_to_digit = {
        {""zero"", ""0""},
        {""one"", ""1""},
        {""two"", ""2""},
        {""three"", ""3""},
        {""four"", ""4""},
        {""five"", ""5""},
        {""six"", ""6""},
        {""seven"", ""7""},
        {""eight"", ""8""},
        {""nine"", ""9""}
    };

    std::unordered_map<std::string, std::string> digit_to_word;

    for (auto const &pair: word_to_digit) {
        digit_to_word[pair.second] = pair.first;
    }

    std::stringstream ss(numbers);
    std::string word;
    std::vector<std::string> words;

    while (ss >> word) {
        words.push_back(word);
    }

    std::sort(words.begin(), words.end(), [&](std::string a, std::string b) {
        return word_to_digit[a] < word_to_digit[b];
    });

    std::string sorted_numbers = """";

    for (std::string word: words) {
        sorted_numbers += digit_to_word[word_to_digit[word]] + "" "";
    }

    return sorted_numbers.substr(0, sorted_numbers.size() - 1);  // Remove trailing space
"
0,1.0,HumanEval_19_sort_numbers,"

std::string sort_numbers(std::string numbers) {
    std::unordered_map<std::string, std::string> words_to_nums = {
        {""zero"", ""0""},
        {""one"", ""1""},
        {""two"", ""2""},
        {""three"", ""3""},
        {""four"", ""4""},
        {""five"", ""5""},
        {""six"", ""6""},
        {""seven"", ""7""},
        {""eight"", ""8""},
        {""nine"", ""9""}
    };

    std::unordered_map<std::string, std::string> nums_to_words;
    for (auto &pair : words_to_nums) {
        nums_to_words[pair.second] = pair.first;
    }

    std::istringstream iss(numbers);
    std::vector<std::string> words((std::istream_iterator<std::string>(iss)),
                                     std::istream_iterator<std::string>());

    std::sort(words.begin(), words.end(), [&](std::string &a, std::string &b) {
        return words_to_nums[a] < words_to_nums[b];
    });

    std::string result;
    for (auto &word : words) {
        result += nums_to_words[word] + "" "";
    }

    return result.substr(0, result.size() - 1);  // Remove the trailing space"
0,0.0,HumanEval_19_sort_numbers,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

string sort_numbers(string numbers) {
    unordered_map<string, int> str_to_num = {{""zero"", 0}, {""one"", 1}, {""two"", 2}, {""three"", 3}, {""four"", 4},
                                             {""five"", 5}, {""six"", 6}, {""seven"", 7}, {""eight"", 8}, {""nine"", 9}};
    unordered_map<int, string> num_to_str = {{0, ""zero""}, {1, ""one""}, {2, ""two""}, {3, ""three""}, {4, ""four""},
                                             {5, ""five""}, {6, ""six""}, {7, ""seven""}, {8, ""eight""}, {9, ""nine""}};

    stringstream ss(numbers);
    string word;
    vector<int> nums;

    while (ss >> word) {
        nums.push_back(str_to_num[word]);
    }

    sort(nums.begin(), nums.end());

    string sorted_numbers = """";

    for (int num : nums) {
        sorted_numbers += num_to_str[num] + "" "";
    }

    // Remove the trailing space
    sorted_numbers.pop_back();

    return sorted_numbers;
"
1,1.0,HumanEval_19_sort_numbers,"
std::string sort_numbers(std::string numbers) {
    std::unordered_map<std::string, std::string> num_map = {{""zero"", ""0""}, {""one"", ""1""}, {""two"", ""2""}, {""three"", ""3""}, {""four"", ""4""}, {""five"", ""5""}, {""six"", ""6""}, {""seven"", ""7""}, {""eight"", ""8""}, {""nine"", ""9""}};
    std::unordered_map<std::string, std::string> rev_map = {{""0"", ""zero""}, {""1"", ""one""}, {""2"", ""two""}, {""3"", ""three""}, {""4"", ""four""}, {""5"", ""five""}, {""6"", ""six""}, {""7"", ""seven""}, {""8"", ""eight""}, {""9"", ""nine""}};
    
    std::istringstream iss(numbers);
    std::vector<std::string> words((std::istream_iterator<std::string>(iss)), std::istream_iterator<std::string>());
    
    std::vector<std::string> nums;
    for(auto& word : words) {
        nums.push_back(num_map[word]);
    }
    
    std::sort(nums.begin(), nums.end());
    
    std::vector<std::string> sorted_words;
    for(auto& num : nums) {
        sorted_words.push_back(rev_map[num]);
    }
    
    std::string sorted_numbers = std::accumulate(std::begin(sorted_words), std::end(sorted_words), std::string(""""), [](const std::string& a, const std::string& b) { return a.empty() ? b : a + "" "" + b; });
    
    return sorted_numbers;"
1,1.0,HumanEval_19_sort_numbers,"
std::string sort_numbers(std::string numbers) {
    std::unordered_map<std::string, std::string> num_map = {
        {""zero"", ""0""}, {""one"", ""1""}, {""two"", ""2""}, {""three"", ""3""}, {""four"", ""4""},
        {""five"", ""5""}, {""six"", ""6""}, {""seven"", ""7""}, {""eight"", ""8""}, {""nine"", ""9""}
    };

    std::unordered_map<std::string, std::string> rev_map = {
        {""0"", ""zero""}, {""1"", ""one""}, {""2"", ""two""}, {""3"", ""three""}, {""4"", ""four""},
        {""5"", ""five""}, {""6"", ""six""}, {""7"", ""seven""}, {""8"", ""eight""}, {""9"", ""nine""}
    };

    std::istringstream iss(numbers);
    std::vector<std::string> words((std::istream_iterator<std::string>(iss)),
                                     std::istream_iterator<std::string>());

    std::vector<std::string> nums;
    for(auto word : words){
        assert(num_map.find(word) != num_map.end());
        nums.push_back(num_map[word]);
    }

    std::sort(nums.begin(), nums.end());

    std::string result = """";
    for(auto num : nums){
        result += rev_map[num] + "" "";
    }

    return result.substr(0, result.size()-1);  // remove the trailing space
"
1,1.0,HumanEval_19_sort_numbers,"

std::string sort_numbers(std::string numbers) {
    std::map<std::string, int> num_map;
    num_map[""zero""] = 0;
    num_map[""one""] = 1;
    num_map[""two""] = 2;
    num_map[""three""] = 3;
    num_map[""four""] = 4;
    num_map[""five""] = 5;
    num_map[""six""] = 6;
    num_map[""seven""] = 7;
    num_map[""eight""] = 8;
    num_map[""nine""] = 9;

    std::vector<std::string> num_vec;
    std::string temp = """";
    for(int i = 0; i < numbers.size(); i++) {
        if(numbers[i] == ' ') {
            num_vec.push_back(temp);
            temp = """";
        } else {
            temp += numbers[i];
        }
    }
    num_vec.push_back(temp);

    std::sort(num_vec.begin(), num_vec.end(), [&](std::string a, std::string b){
        return num_map[a] < num_map[b];
    });

    std::string result = """";
    for(int i = 0; i < num_vec.size(); i++) {
        result += num_vec[i];
        if(i != num_vec.size() - 1) {
            result += "" "";
        }
    }

    return result;
"
0,0.0,HumanEval_65_circular_shift,"

std::string circular_shift(long x, long shift) {
    std::string str = std::to_string(x);
    int n = str.length();

    if (shift >= n) {
        std::reverse(str.begin(), str.end());
        return str;
    }

    std::rotate(str.begin(), str.begin()+str.size()-shift, str.end());
    return str;"
0,0.0,HumanEval_65_circular_shift,"

std::string circular_shift(long x, long shift) {
    std::string x_str = std::to_string(x);
    int n = x_str.size();

    if(shift >= n) {
        std::reverse(x_str.begin(), x_str.end());
    } else {
        std::rotate(x_str.begin(), x_str.begin()+n-shift, x_str.end());
    }

    return x_str;"
0,0.0,HumanEval_65_circular_shift,"

std::string circular_shift(long x, long shift) {
    std::string str = std::to_string(x);
    int n = str.length();

    if(shift >= n) {
        std::reverse(str.begin(), str.end());
    } else {
        std::rotate(str.begin(), str.begin()+str.length()-shift, str.end());
    }

    return str;
"
0,0.0,HumanEval_65_circular_shift,"

std::string circular_shift(long x, long shift) {
    std::string s = std::to_string(x);
    int n = s.size();

    if (shift >= n) {
        std::reverse(s.begin(), s.end());
    } else {
        std::rotate(s.begin(), s.begin() + n - shift, s.end());
    }

    return s;"
0,0.0,HumanEval_65_circular_shift,"

std::string circular_shift(long x, long shift) {
    std::string str = std::to_string(x);
    int n = str.size();

    if (shift >= n) {
        std::reverse(str.begin(), str.end());
        return str;
    }

    std::rotate(str.begin(), str.begin() + n - shift, str.end());
    return str;"
0,0.0,HumanEval_65_circular_shift,"

std::string circular_shift(long x, long shift) {
    std::string str = std::to_string(x);
    int n = str.length();

    if(shift >= n) {
        std::reverse(str.begin(), str.end());
        return str;
    }

    std::rotate(str.begin(), str.begin() + str.size() - shift, str.end());
    return str;"
0,0.0,HumanEval_65_circular_shift,"
    std::string x_str = std::to_string(x);
    int n = x_str.size();

    if (shift >= n) {
        std::reverse(x_str.begin(), x_str.end());
    } else {
        std::rotate(x_str.rbegin(), x_str.rbegin() + (n - shift), x_str.rend());
    }

    return x_str;
"
0,1.0,HumanEval_65_circular_shift,"

std::string circular_shift(long x, long shift) {
    std::string digits = std::to_string(x);
    int n = digits.size();
    if (shift >= n) {
        std::reverse(digits.begin(), digits.end());
    } else {
        std::rotate(digits.begin(), digits.begin() + n - shift, digits.end());
    }
    return digits;"
0,0.0,HumanEval_65_circular_shift,"
std::string circular_shift(long x, long shift) {
    std::string str = std::to_string(x);
    int n = str.size();

    if(shift >= n) {
        std::reverse(str.begin(), str.end());
    } else {
        std::rotate(str.rbegin(), str.rbegin()+shift, str.rend());
    }

    return str;"
0,0.0,HumanEval_65_circular_shift,"

std::string circular_shift(long x, long shift) {
    std::string s = std::to_string(x);
    int n = s.size();
    
    if(shift >= n) {
        std::reverse(s.begin(), s.end());
    } else {
        std::rotate(s.begin(), s.begin()+n-shift, s.end());
    }
    
    return s;"
0,1.0,HumanEval_142_sum_squares,"

long sum_squares(std::vector<long> lst) {
    long sum = 0;
    for(int i = 0; i < lst.size(); i++) {
        if(i % 3 == 0) {
            sum += lst[i] * lst[i] * lst[i]; // cube the number if index is multiple of 3
        } else if(i % 4 == 0) {
            sum += lst[i] * lst[i]; // square the number if index is multiple of 4 but not 3
        } else {
            sum += lst[i]; // add the number if index is not a multiple of 3 or 4
        }
    }
    return sum;"
0,1.0,HumanEval_142_sum_squares,"
long sum_squares(std::vector<long> lst) {
    long sum = 0;
    for(int i = 0; i < lst.size(); i++) {
        if(i % 3 == 0 && i % 4 != 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else if(i % 4 == 0) {
            sum += lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;
"
0,1.0,HumanEval_142_sum_squares,"

long sum_squares(std::vector<long> lst) {
    long sum = 0;
    for (int i = 0; i < lst.size(); i++) {
        if (i % 3 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else if (i % 4 == 0) {
            sum += lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;
"
0,1.0,HumanEval_142_sum_squares,"
long sum_squares(std::vector<long> lst) {
    long sum = 0;
    for (int i = 0; i < lst.size(); i++) {
        if (i % 3 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else if (i % 4 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;
"
0,1.0,HumanEval_142_sum_squares,"
long sum_squares(std::vector<long> lst) {
    long sum = 0;
    for (int i = 0; i < lst.size(); i++) {
        if (i % 3 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else if (i % 4 == 0) {
            sum += lst[i] * lst[i] * lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;"
0,0.0,HumanEval_142_sum_squares,"
    long sum = 0;
    for(int i = 0; i < lst.size(); i++){
        if(i % 3 == 0){
            sum += lst[i] * lst[i] * lst[i];
        }
        else if(i % 4 == 0){
            sum += lst[i] * lst[i];
        }
        else{
            sum += lst[i];
        }
    }
    return sum;
"
0,1.0,HumanEval_142_sum_squares,"
long sum_squares(std::vector<long> lst) {
    long sum = 0;
    for(int i = 0; i < lst.size(); i++) {
        if(i % 3 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else if(i % 4 == 0) {
            sum += lst[i] * lst[i] * lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;
"
0,0.0,HumanEval_142_sum_squares,"
    long sum = 0;
    for (size_t i = 0; i < lst.size(); i++) {
        if (i % 3 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else if (i % 4 == 0) {
            sum += lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;
"
1,1.0,HumanEval_142_sum_squares,"
long sum_squares(std::vector<long> lst) {
    long sum = 0;
    for(int i = 0; i < lst.size(); i++) {
        if(i % 3 == 0) {
            sum += lst[i] * lst[i];
        } else if(i % 4 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;"
0,1.0,HumanEval_142_sum_squares,"

long sum_squares(std::vector<long> lst) {
    long sum = 0;
    for(int i = 0; i < lst.size(); i++) {
        if(i % 3 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else if(i % 4 == 0) {
            sum += lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;
"
0,1.0,HumanEval_94_skjkasdkd,"

long skjkasdkd(std::vector<long> lst) {
    long max_prime = -1;
    for (long num : lst) {
        if (isPrime(num) && num > max_prime) {
            max_prime = num;
        }
    }
    return sumOfDigits(max_prime);
"
0,1.0,HumanEval_94_skjkasdkd,"

long skjkasdkd(std::vector<long> lst) {
    long max_prime = -1;
    for (long i = 0; i < lst.size(); i++) {
        if (isPrime(lst[i])) {
            max_prime = max(max_prime, lst[i]);
        }
    }
    return sumOfDigits(max_prime);"
0,1.0,HumanEval_94_skjkasdkd,"

long skjkasdkd(std::vector<long> lst) {
    long maxPrime = 0;
    for(long i = 0; i < lst.size(); i++) {
        if(isPrime(lst[i])) {
            maxPrime = max(maxPrime, lst[i]);
        }
    }
    return sumOfDigits(maxPrime);"
1,1.0,HumanEval_94_skjkasdkd,"
long skjkasdkd(std::vector<long> lst) {
    auto is_prime = [](long n) {
        if (n <= 1) return false;
        if (n <= 3) return true;
        if (n % 2 == 0 || n % 3 == 0) return false;
        for (long i = 5; i * i <= n; i += 6)
            if (n % i == 0 || n % (i + 2) == 0)
                return false;
        return true;
    };

    long max_prime = -1;
    for (long num : lst) {
        if (is_prime(num) && num > max_prime)
            max_prime = num;
    }

    if (max_prime == -1)
        return 0;

    long sum = 0;
    while (max_prime > 0) {
        sum += max_prime % 10;
        max_prime /= 10;
    }

    return sum;"
1,1.0,HumanEval_94_skjkasdkd,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

bool isPrime(long num) {
    if(num <= 1) return false;
    if(num == 2) return true;
    if(num % 2 == 0) return false;
    for(long i = 3; i * i <= num; i += 2) {
        if(num % i == 0) return false;
    }
    return true;
}

long skjkasdkd(vector<long> lst) {
    vector<long> primes;
    for(long num : lst) {
        if(isPrime(num)) primes.push_back(num);
    }
    if(primes.empty()) return 0;
    long maxPrime = *max_element(primes.begin(), primes.end());
    long sum = 0;
    while(maxPrime > 0) {
        sum += maxPrime % 10;
        maxPrime /= 10;
    }
    return sum;"
1,1.0,HumanEval_94_skjkasdkd,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

bool isPrime(long n) {
    if (n <= 1)
        return false;
    if (n <= 3)
        return true;
    if (n % 2 == 0 || n % 3 == 0)
        return false;
    for (long i = 5; i * i <= n; i += 6)
        if (n % i == 0 || n % (i + 2) == 0)
            return false;
    return true;
}

long sumOfDigits(long n) {
    long sum = 0;
    while (n != 0) {
        sum += n % 10;
        n = n / 10;
    }
    return sum;
}

long skjkasdkd(vector<long> lst) {
    long max_prime = 0;
    for (long num : lst) {
        if (isPrime(num) && num > max_prime) {
            max_prime = num;
        }
    }
    return sumOfDigits(max_prime);"
0,1.0,HumanEval_94_skjkasdkd,"

long skjkasdkd(std::vector<long> lst) {
    long max_prime = -1;
    for(long num : lst) {
        if(isPrime(num))
            max_prime = std::max(max_prime, num);
    }
    long sum = 0;
    while(max_prime > 0) {
        sum += max_prime % 10;
        max_prime /= 10;
    }
    return sum;
"
0,1.0,HumanEval_94_skjkasdkd,"

long skjkasdkd(std::vector<long> lst) {
    long maxPrime = 0;
    for (long num : lst) {
        if (isPrime(num) && num > maxPrime) {
            maxPrime = num;
        }
    }
    return sumOfDigits(maxPrime);
"
0,1.0,HumanEval_94_skjkasdkd,"

long skjkasdkd(std::vector<long> lst) {
    long largestPrime = -1;
    for (long num : lst) {
        if (isPrime(num) && num > largestPrime) {
            largestPrime = num;
        }
    }
    if (largestPrime != -1)
        return sumDigits(largestPrime);
    else
        return 0;"
0,0.0,HumanEval_94_skjkasdkd,"
    assert(lst.size() > 0);

    // Function to check if a number is prime
    auto is_prime = [](long n) {
        if (n <= 1) return false;
        if (n <= 3) return true;

        if (n % 2 == 0 || n % 3 == 0) return false;

        for (long i = 5; i * i <= n; i += 6) {
            if (n % i == 0 || n % (i + 2) == 0) return false;
        }

        return true;
    };

    // Find the largest prime number in the vector
    long largest_prime = -1;
    for (long num : lst) {
        if (is_prime(num) && num > largest_prime) {
            largest_prime = num;
        }
    }

    // Calculate the sum of digits of the largest prime number
    long sum_of_digits = 0;
    while (largest_prime > 0) {
        sum_of_digits += largest_prime % 10;
        largest_prime /= 10;
    }

    return sum_of_digits;"
1,1.0,HumanEval_8_sum_product,"
std::tuple<long, long> sum_product(std::vector<long> numbers) {
    long sum = 0;
    long product = 1;
    for (long num : numbers) {
        sum += num;
        product *= num;
    }
    return std::make_tuple(sum, product);
"
1,1.0,HumanEval_8_sum_product,"

std::tuple<long, long> sum_product(std::vector<long> numbers) {
    long sum = 0, product = 1;
    for(long num : numbers){
        sum += num;
        product *= num;
    }
    return std::make_tuple(sum, product);
"
1,1.0,HumanEval_8_sum_product,"

std::tuple<long, long> sum_product(std::vector<long> numbers) {
    long sum = 0;
    long product = 1;

    for(long num : numbers) {
        sum += num;
        product *= num;
    }

    return std::make_tuple(sum, product);"
1,1.0,HumanEval_8_sum_product,"

std::tuple<long, long> sum_product(std::vector<long> numbers) {
    long sum = 0;
    long product = 1;
    for(long num : numbers) {
        sum += num;
        product *= num;
    }
    return std::make_tuple(sum, product);"
0,0.0,HumanEval_8_sum_product,"
    long sum = 0;
    long product = 1;
    for (long num : numbers) {
        sum += num;
        product *= num;
    }
    return std::make_tuple(sum, product);"
1,1.0,HumanEval_8_sum_product,"

std::tuple<long, long> sum_product(std::vector<long> numbers) {
    long sum = 0, product = 1;
    for(long num : numbers) {
        sum += num;
        product *= num;
    }
    return std::make_tuple(sum, product);
"
1,1.0,HumanEval_8_sum_product,"
std::tuple<long, long> sum_product(std::vector<long> numbers) {
    long sum = 0;
    long product = 1;
    for(long num : numbers) {
        sum += num;
        product *= num;
    }
    return std::make_tuple(sum, product);"
1,1.0,HumanEval_8_sum_product,"
std::tuple<long, long> sum_product(std::vector<long> numbers) {
    long sum = 0;
    long product = 1;
    for(long num : numbers){
        sum += num;
        product *= num;
    }
    return std::make_tuple(sum, product);"
0,0.0,HumanEval_8_sum_product,"
    long sum = 0;
    long product = 1;
    for(long num : numbers) {
        sum += num;
        product *= num;
    }
    return std::make_tuple(sum, product);
"
1,1.0,HumanEval_8_sum_product,"
std::tuple<long, long> sum_product(std::vector<long> numbers) {
    long sum = 0;
    long product = 1;

    for(long num : numbers) {
        sum += num;
        product *= num;
    }

    return std::make_tuple(sum, product);
"
0,1.0,HumanEval_102_choose_num,"

long choose_num(long x, long y) {
    // If x is greater than y, return -1
    if(x > y) {
        return -1;
    }

    // If x is even, return x
    if(x % 2 == 0) {
        return x;
    }

    // If y is even, return y
    if(y % 2 == 0) {
        return y;
    }

    // If x and y are both odd, return y - 1
    // because y is the largest number and it is even
    return y - 1;"
0,0.0,HumanEval_102_choose_num,"
long choose_num(long x, long y) {
    if (x > y) {
        return -1;
    }
    if (x % 2 == 0) {
        if (y % 2 == 0) {
            return y;
        }
        else {
            return y - 1;
        }
    }
    else {
        if (y % 2 == 0) {
            return y - 1;
        }
        else {
            return y - 2;
        }
    }"
0,0.0,HumanEval_102_choose_num,"

long choose_num(long x, long y) {
    if(x > y) {
        return -1;
    }

    if(x % 2 == 0) {
        if(y % 2 == 0) {
            return y;
        }
        else {
            return y - 1;
        }
    }
    else {
        if(y % 2 == 0) {
            return y - 1;
        }
        else {
            return y - 2;
        }
    }
"
1,1.0,HumanEval_102_choose_num,"
long choose_num(long x, long y) {
    if(x > y) {
        return -1;
    }
    for(long i = y; i >= x; i--) {
        if(i % 2 == 0) {
            return i;
        }
    }
    return -1;
"
0,1.0,HumanEval_102_choose_num,"
long choose_num(long x, long y) {
    assert(x > 0 && y > 0);
    assert(x <= y);

    // Start from the upper limit and go down
    for (long i = y; i >= x; i--) {
        // Check if the number is even
        if (i % 2 == 0) {
            return i;
        }
    }

    // If no even number found, return -1
    return -1;"
0,0.0,HumanEval_102_choose_num,"
    assert(x > 0 && y > 0);
    if (x > y)
        return -1;
    else if (x % 2 == 0)
        return y;
    else if (y % 2 == 0)
        return y - 1;
    else
        return y - 2;
"
0,0.0,HumanEval_102_choose_num,"
    // If x is greater than y, return -1
    if(x > y) {
        return -1;
    }
    // If x is even, return x
    if(x % 2 == 0) {
        return x;
    }
    // If y is even, return y
    if(y % 2 == 0) {
        return y;
    }
    // If both x and y are odd, return the next even number after y
    return y + 2;
"
0,1.0,HumanEval_102_choose_num,"
long choose_num(long x, long y) {
    if(x > y) {
        return -1;
    }
    if(x % 2 == 0) {
        if(y % 2 == 0) {
            if(x == y) {
                return x;
            } else {
                return y;
            }
        } else {
            return y - 1;
        }
    } else {
        if(y % 2 == 0) {
            return y - 1;
        } else {
            if(y - x >= 2) {
                return y - 2;
            } else {
                return -1;
            }
        }
    }"
0,0.0,HumanEval_102_choose_num,"
    assert(x >= 0 && y >= 0);
    if (x > y) {
        return -1;
    }
    // Check if x is even
    if (x % 2 == 0) {
        if (x >= y) {
            return x;
        } else {
            // If x is even and not larger than y, then increment x by 1 to make it even
            x++;
            // Check if incremented x is still in range [x, y]
            if (x > y) {
                return -1;
            } else {
                return x;
            }
        }
    } else {
        // If x is odd, then increment x by 1 to make it even
        x++;
        // Check if incremented x is still in range [x, y]
        if (x > y) {
            return -1;
        } else {
            return x;
        }
    }
"
0,0.0,HumanEval_102_choose_num,"
    assert(x >= 0 && y >= 0);
    assert(x <= y);

    for (long i = y; i >= x; i--) {
        if (i % 2 == 0) {
            return i;
        }
    }

    return -1;"
1,0.0,HumanEval_136_largest_smallest_integers,"
std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
    long largestNegative = LONG_MIN;
    long smallestPositive = LONG_MAX;
    bool hasNegative = false, hasPositive = false;

    for(long num : lst) {
        if(num < 0 && num > largestNegative) {
            largestNegative = num;
            hasNegative = true;
        }
        else if(num > 0 && num < smallestPositive) {
            smallestPositive = num;
            hasPositive = true;
        }
    }

    std::optional<long> a, b;
    if(hasNegative) a = largestNegative;
    if(hasPositive) b = smallestPositive;

    return std::make_tuple(a, b);
"
0,0.0,HumanEval_136_largest_smallest_integers,"
    std::optional<long> largest = std::nullopt;
    std::optional<long> smallest = std::nullopt;

    for (const auto& num : lst) {
        if (num < 0 && (!largest.has_value() || num > *largest)) {
            largest = num;
        } else if (num > 0 && (!smallest.has_value() || num < *smallest)) {
            smallest = num;
        }
    }

    return std::make_tuple(largest, smallest);"
1,1.0,HumanEval_136_largest_smallest_integers,"
std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
    std::optional<long> largestNegative = std::nullopt;
    std::optional<long> smallestPositive = std::nullopt;

    for (const auto& num : lst) {
        if (num < 0 && (!largestNegative.has_value() || num > *largestNegative)) {
            largestNegative = num;
        } else if (num > 0 && (!smallestPositive.has_value() || num < *smallestPositive)) {
            smallestPositive = num;
        }
    }

    return std::make_tuple(largestNegative, smallestPositive);"
1,1.0,HumanEval_136_largest_smallest_integers,"

std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
    std::optional<long> largest_negative;
    std::optional<long> smallest_positive;

    for(auto &num : lst) {
        if(num < 0 && (!largest_negative.has_value() || num > *largest_negative)) {
            largest_negative = num;
        }
        if(num > 0 && (!smallest_positive.has_value() || num < *smallest_positive)) {
            smallest_positive = num;
        }
    }

    return std::make_tuple(largest_negative, smallest_positive);"
1,1.0,HumanEval_136_largest_smallest_integers,"
std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
    std::optional<long> max_neg = std::nullopt;
    std::optional<long> min_pos = std::nullopt;

    for (const auto& num : lst) {
        if (num < 0 && (!max_neg.has_value() || num > *max_neg)) {
            max_neg = num;
        } else if (num > 0 && (!min_pos.has_value() || num < *min_pos)) {
            min_pos = num;
        }
    }

    return std::make_tuple(max_neg, min_pos);"
0,1.0,HumanEval_136_largest_smallest_integers,"

std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
    // Find the largest negative number
    auto max_neg = std::max_element(lst.begin(), lst.end(), [](long a, long b){ return a > b && a < 0; });
    std::optional<long> a = max_neg != lst.end() ? *max_neg : std::nullopt;

    // Find the smallest positive number
    auto min_pos = std::min_element(lst.begin(), lst.end(), [](long a, long b){ return a < b && a > 0; });
    std::optional<long> b = min_pos != lst.end() ? *min_pos : std::nullopt;

    return std::make_tuple(a, b);"
0,0.0,HumanEval_136_largest_smallest_integers,"
    std::optional<long> largest = std::nullopt;
    std::optional<long> smallest = std::nullopt;

    for(const auto& num : lst) {
        if(num < 0 && (!largest.has_value() || num > *largest)) {
            largest = num;
        } else if(num > 0 && (!smallest.has_value() || num < *smallest)) {
            smallest = num;
        }
    }

    return std::make_tuple(largest, smallest);"
0,0.0,HumanEval_136_largest_smallest_integers,"
std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
    long largestNegative = std::numeric_limits<long>::min();
    long smallestPositive = std::numeric_limits<long>::max();
    bool hasNegative = false, hasPositive = false;

    for(long num : lst) {
        if(num < 0 && num > largestNegative) {
            largestNegative = num;
            hasNegative = true;
        }
        else if(num > 0 && num < smallestPositive) {
            smallestPositive = num;
            hasPositive = true;
        }
    }

    std::optional<long> a = hasNegative ? largestNegative : std::nullopt;
    std::optional<long> b = hasPositive ? smallestPositive : std::nullopt;

    return std::make_tuple(a, b);"
1,1.0,HumanEval_136_largest_smallest_integers,"

std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
    std::optional<long> max_neg = std::nullopt;
    std::optional<long> min_pos = std::nullopt;

    for(const auto& num : lst) {
        if(num < 0 && (!max_neg.has_value() || num > *max_neg)) {
            max_neg = num;
        }
        else if(num > 0 && (!min_pos.has_value() || num < *min_pos)) {
            min_pos = num;
        }
    }

    return std::make_tuple(max_neg, min_pos);"
1,1.0,HumanEval_136_largest_smallest_integers,"
std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
    std::optional<long> largest = std::nullopt;
    std::optional<long> smallest = std::nullopt;

    for (long num : lst) {
        if (num > 0) {
            if (!smallest.has_value() || num < smallest.value())
                smallest = num;
        } else if (num < 0) {
            if (!largest.has_value() || num > largest.value())
                largest = num;
        }
    }

    return std::make_tuple(largest, smallest);"
1,1.0,HumanEval_16_count_distinct_characters,"
#include<assert.h>
#include<bits/stdc++.h>

long count_distinct_characters(std::string str) {
    // Create a set to store distinct characters
    std::set<char> distinct_chars;

    // Convert the string to lowercase
    std::transform(str.begin(), str.end(), str.begin(), ::tolower);

    // Iterate over the string and add each character to the set
    for(char c : str) {
        distinct_chars.insert(c);
    }

    // The size of the set is the number of distinct characters
    return distinct_chars.size();
"
1,1.0,HumanEval_16_count_distinct_characters,"
#include<assert.h>
#include<bits/stdc++.h>

long count_distinct_characters(std::string str) {
    std::transform(str.begin(), str.end(), str.begin(), ::toupper);
    std::set<char> distinct_chars;
    for (char c : str) {
        distinct_chars.insert(c);
    }
    return distinct_chars.size();"
1,1.0,HumanEval_16_count_distinct_characters,"
#include<assert.h>
#include<bits/stdc++.h>

// Given a string, find out how many distinct characters (regardless of case) does it consist of
long count_distinct_characters(std::string str) {
    // Convert the string to lowercase
    std::transform(str.begin(), str.end(), str.begin(), ::tolower);

    // Use a set to store the distinct characters
    std::set<char> distinct_chars;

    // Iterate over the string and add each character to the set
    for (char c : str) {
        distinct_chars.insert(c);
    }

    // The size of the set is the number of distinct characters
    return distinct_chars.size();"
1,1.0,HumanEval_16_count_distinct_characters,"
#include<assert.h>
#include<bits/stdc++.h>

long count_distinct_characters(std::string str) {
    std::set<char> distinct_chars;
    for(char c: str) {
        distinct_chars.insert(std::tolower(c));
    }
    return distinct_chars.size();"
1,1.0,HumanEval_16_count_distinct_characters,"
#include<assert.h>
#include<bits/stdc++.h>

long count_distinct_characters(std::string str) {
    std::transform(str.begin(), str.end(), str.begin(), ::toupper);
    std::set<char> distinct_chars;
    for(char c : str) {
        distinct_chars.insert(c);
    }
    return distinct_chars.size();
"
1,1.0,HumanEval_16_count_distinct_characters,"
#include<assert.h>
#include<bits/stdc++.h>

long count_distinct_characters(std::string str) {
    std::unordered_set<char> distinct_chars;
    for(char c : str) {
        distinct_chars.insert(std::tolower(c));
    }
    return distinct_chars.size();"
1,1.0,HumanEval_16_count_distinct_characters,"
#include<assert.h>
#include<bits/stdc++.h>

long count_distinct_characters(std::string str) {
    std::unordered_set<char> distinct_chars;
    for(char c : str) {
        distinct_chars.insert(std::tolower(c));
    }
    return distinct_chars.size();"
1,1.0,HumanEval_16_count_distinct_characters,"
#include<assert.h>
#include<bits/stdc++.h>

long count_distinct_characters(std::string str) {
    std::set<char> distinct_chars;
    for(char c : str) {
        distinct_chars.insert(tolower(c));
    }
    return distinct_chars.size();
"
1,1.0,HumanEval_16_count_distinct_characters,"

long count_distinct_characters(std::string string) {
    std::set<char> distinct_characters;
    for (char c : string) {
        distinct_characters.insert(std::tolower(c));
    }
    return distinct_characters.size();
"
1,1.0,HumanEval_16_count_distinct_characters,"
#include<assert.h>
#include<bits/stdc++.h>

long count_distinct_characters(std::string str) {
    std::unordered_set<char> distinct_chars;

    for(char c : str) {
        distinct_chars.insert(std::tolower(c));
    }

    return distinct_chars.size();"
1,1.0,HumanEval_100_make_a_pile,"
std::vector<long> make_a_pile(long n) {
    std::vector<long> result;
    long current_stones = n;
    for (long i = 0; i < n; i++) {
        result.push_back(current_stones);
        if (current_stones % 2 == 0) {
            current_stones += 2;
        } else {
            current_stones += 2;
        }
    }
    return result;"
1,1.0,HumanEval_100_make_a_pile,"
std::vector<long> make_a_pile(long n) {
    std::vector<long> result;
    for (long i = 0; i < n; i++) {
        if (n % 2 == 0) {
            result.push_back(n + 2 * i);
        } else {
            result.push_back(n + 2 * i);
        }
    }
    return result;
"
1,1.0,HumanEval_100_make_a_pile,"
std::vector<long> make_a_pile(long n) {
    std::vector<long> result;
    for (long i = 0; i < n; i++) {
        if (n % 2 == 0) {
            result.push_back(n + (2 * i));
        } else {
            result.push_back(n + (2 * i));
        }
    }
    return result;"
1,1.0,HumanEval_100_make_a_pile,"
std::vector<long> make_a_pile(long n) {
    std::vector<long> result;
    for (long i = 0; i < n; i++) {
        long stones = n + (2 * i);
        result.push_back(stones);
    }
    return result;"
1,1.0,HumanEval_100_make_a_pile,"
std::vector<long> make_a_pile(long n) {
    std::vector<long> result;
    for (long i = 0; i < n; i++) {
        if (n % 2 == 0) {
            result.push_back(n + 2 * i);
        } else {
            result.push_back(n + 2 * i);
        }
    }
    return result;"
0,0.0,HumanEval_100_make_a_pile,"
    // Initialize vector with the first level
    std::vector<long> pile = {n};

    // Loop through the remaining levels
    for (long i = 1; i < n; i++) {
        // If the previous level has an even number of stones, add the next even number
        if (pile[i-1] % 2 == 0) {
            pile.push_back(pile[i-1] + 2);
        }
        // If the previous level has an odd number of stones, add the next odd number
        else {
            pile.push_back(pile[i-1] + 2);
        }
    }

    // Return the final pile of stones
    return pile;
"
1,1.0,HumanEval_100_make_a_pile,"
std::vector<long> make_a_pile(long n) {
    std::vector<long> result;
    for (long i = 0; i < n; i++) {
        if (n % 2 == 0) {
            result.push_back(n + (2 * i));
        } else {
            result.push_back(n + (2 * i));
        }
    }
    return result;"
1,1.0,HumanEval_100_make_a_pile,"
std::vector<long> make_a_pile(long n) {
    std::vector<long> result;
    for (long i = 0; i < n; i++) {
        if (n % 2 == 0) {
            result.push_back(n + 2 * i);
        } else {
            result.push_back(n + 2 * i);
        }
    }
    return result;"
1,1.0,HumanEval_100_make_a_pile,"
std::vector<long> make_a_pile(long n) {
    std::vector<long> result;
    for (long i = 0; i < n; i++) {
        long stones = n + (2 * i);
        result.push_back(stones);
    }
    return result;
"
0,0.0,HumanEval_100_make_a_pile,"
    std::vector<long> pile;
    for(long i = 0; i < n; i++) {
        if(n % 2 == 0) {
            pile.push_back(n + (2 * i));
        } else {
            pile.push_back(n + (2 * i));
        }
    }
    return pile;
"
1,1.0,HumanEval_128_prod_signs,"
std::optional<long> prod_signs(std::vector<long> arr) {
    if(arr.empty()) {
        return std::nullopt;
    }
    long sum_magnitudes = 0;
    long prod_signs = 1;
    for(auto num : arr) {
        sum_magnitudes += std::abs(num);
        if(num < 0) {
            prod_signs *= -1;
        } else if(num > 0) {
            prod_signs *= 1;
        } else {
            return 0;
        }
    }
    return sum_magnitudes * prod_signs;"
1,0.0,HumanEval_128_prod_signs,"
std::optional<long> prod_signs(std::vector<long> arr) {
    if(arr.empty())
        return std::nullopt;
    
    long sum = 0, prod = 1;
    for(auto num : arr) {
        if(num < 0)
            prod *= -1;
        else if(num > 0)
            prod *= 1;
        else
            return 0;
        sum += std::abs(num);
    }
    return sum * prod;"
1,0.0,HumanEval_128_prod_signs,"

std::optional<long> prod_signs(std::vector<long> arr) {
    if (arr.empty())
        return std::nullopt;

    long product = 1;
    long sum = 0;

    for (long num : arr) {
        if (num < 0)
            product *= -1;
        else if (num > 0)
            product *= 1;
        else
            return 0;

        sum += std::abs(num);
    }

    return sum * product;
"
1,0.0,HumanEval_128_prod_signs,"

std::optional<long> prod_signs(std::vector<long> arr) {
    if(arr.empty()) {
        return std::nullopt;
    }

    long sum_of_magnitudes = 0;
    long product_of_signs = 1;

    for(long num : arr) {
        sum_of_magnitudes += std::abs(num);
        if(num < 0) {
            product_of_signs *= -1;
        } else if(num > 0) {
            product_of_signs *= 1;
        } else {
            return 0;
        }
    }

    return sum_of_magnitudes * product_of_signs;"
0,0.0,HumanEval_128_prod_signs,"
std::optional<long> prod_signs(std::vector<long> arr) {
    if (arr.empty())
        return std::nullopt;
    
    long product = 1;
    long sum = 0;
    for (long num : arr) {
        if (num < 0)
            product *= -1;
        else if (num > 0)
            product *= 1;
        sum += std::abs(num);
    }
    return product * sum;
"
1,1.0,HumanEval_128_prod_signs,"
std::optional<long> prod_signs(std::vector<long> arr) {
    if(arr.empty()) {
        return std::nullopt;
    }

    long sum = 0;
    long prod = 1;

    for(long num : arr) {
        if(num < 0) {
            prod *= -1;
        } else if(num > 0) {
            prod *= 1;
        } else {
            return 0;
        }
        sum += std::abs(num);
    }

    return sum * prod;
"
1,0.0,HumanEval_128_prod_signs,"
std::optional<long> prod_signs(std::vector<long> arr) {
    if (arr.empty()) {
        return std::nullopt;
    }

    long sum = 0;
    long prod = 1;

    for (long num : arr) {
        if (num < 0) {
            prod *= -1;
        } else if (num > 0) {
            prod *= 1;
        } else {
            return 0;
        }

        sum += std::abs(num);
    }

    return sum * prod;"
1,0.0,HumanEval_128_prod_signs,"
std::optional<long> prod_signs(std::vector<long> arr) {
    if (arr.empty()) {
        return std::nullopt;
    }

    long sum = 0;
    long product = 1;
    for (long num : arr) {
        if (num < 0) {
            product *= -1;
        } else if (num > 0) {
            product *= 1;
        } else {
            return 0;
        }
        sum += std::abs(num);
    }
    return sum * product;"
1,0.0,HumanEval_128_prod_signs,"
std::optional<long> prod_signs(std::vector<long> arr) {
    if(arr.empty()) {
        return std::nullopt;
    }
    long sum_magnitudes = 0;
    long prod_signs = 1;
    for(auto num : arr) {
        if(num < 0) {
            prod_signs *= -1;
            sum_magnitudes += -num;
        } else if(num > 0) {
            prod_signs *= 1;
            sum_magnitudes += num;
        } else {
            return 0;
        }
    }
    return prod_signs * sum_magnitudes;"
1,0.0,HumanEval_128_prod_signs,"
std::optional<long> prod_signs(std::vector<long> arr) {
    if(arr.empty())
        return std::nullopt;

    long sum = 0;
    long prod = 1;

    for(auto num : arr) {
        if(num < 0) {
            prod *= -1;
            num = -num;
        } else if(num > 0) {
            prod *= 1;
        } else {
            return 0;
        }
        sum += num;
    }

    return prod * sum;"
0,1.0,HumanEval_114_minSubArraySum,"

long minSubArraySum(std::vector<long> nums) {
    long min_so_far = nums[0];
    long min_ending_here = nums[0];

    for(long i = 1; i < nums.size(); i++){
        min_ending_here = min(nums[i], min_ending_here + nums[i]);
        min_so_far = min(min_so_far, min_ending_here);
    }

    return min_so_far;
"
1,1.0,HumanEval_114_minSubArraySum,"
long minSubArraySum(std::vector<long> nums) {
    long min_sum = nums[0];
    long cur_sum = nums[0];

    for(size_t i = 1; i < nums.size(); i++) {
        cur_sum = std::min(nums[i], cur_sum + nums[i]);
        min_sum = std::min(min_sum, cur_sum);
    }

    return min_sum;
"
1,1.0,HumanEval_114_minSubArraySum,"
long minSubArraySum(std::vector<long> nums) {
    long min_sum = nums[0];
    long cur_sum = nums[0];

    for(size_t i = 1; i < nums.size(); i++) {
        cur_sum = std::min(nums[i], cur_sum + nums[i]);
        min_sum = std::min(min_sum, cur_sum);
    }

    return min_sum;"
1,1.0,HumanEval_114_minSubArraySum,"
long minSubArraySum(std::vector<long> nums) {
    long current_min = nums[0];
    long global_min = nums[0];

    for(size_t i = 1; i < nums.size(); ++i) {
        current_min = std::min(nums[i], current_min + nums[i]);
        if(current_min < global_min)
            global_min = current_min;
    }

    return global_min;
"
1,1.0,HumanEval_114_minSubArraySum,"
long minSubArraySum(std::vector<long> nums) {
    long min_sum = std::numeric_limits<long>::max();
    long current_sum = 0;
    
    for(long num : nums) {
        current_sum += num;
        min_sum = std::min(min_sum, current_sum);
        if(current_sum > 0) {
            current_sum = 0;
        }
    }
    
    return min_sum;
"
1,1.0,HumanEval_114_minSubArraySum,"
long minSubArraySum(std::vector<long> nums) {
    long sum = 0;
    long minSum = LONG_MAX;
    for(long num : nums) {
        sum += num;
        minSum = std::min(minSum, sum);
        if(sum > 0) {
            sum = 0;
        }
    }
    return minSum;"
0,0.0,HumanEval_114_minSubArraySum,"
    long min_sum = LONG_MAX;
    long curr_sum = 0;
    for(long num : nums) {
        curr_sum = std::min(curr_sum + num, num);
        min_sum = std::min(min_sum, curr_sum);
    }
    return min_sum;
"
1,1.0,HumanEval_114_minSubArraySum,"
long minSubArraySum(std::vector<long> nums) {
    long current_sum = nums[0];
    long min_sum = nums[0];

    for(size_t i = 1; i < nums.size(); i++) {
        if(current_sum > 0) {
            current_sum = nums[i];
        } else {
            current_sum += nums[i];
        }

        if(current_sum < min_sum) {
            min_sum = current_sum;
        }
    }

    return min_sum;"
0,1.0,HumanEval_114_minSubArraySum,"

long minSubArraySum(std::vector<long> nums) {
    long current_sum = nums[0];
    long min_sum = nums[0];

    for(int i = 1; i < nums.size(); i++) {
        current_sum = min(nums[i], current_sum + nums[i]);
        min_sum = min(min_sum, current_sum);
    }

    return min_sum;"
1,1.0,HumanEval_114_minSubArraySum,"
long minSubArraySum(std::vector<long> nums) {
    long min_sum = nums[0];
    long cur_sum = nums[0];

    for(size_t i = 1; i < nums.size(); i++) {
        cur_sum = std::min(nums[i], cur_sum + nums[i]);
        min_sum = std::min(min_sum, cur_sum);
    }

    return min_sum;"
1,1.0,HumanEval_15_string_sequence,"

std::string string_sequence(long n) {
    std::stringstream ss;
    for (long i = 0; i <= n; ++i) {
        ss << i;
        if (i < n) {
            ss << "" "";
        }
    }
    return ss.str();"
1,1.0,HumanEval_15_string_sequence,"
std::string string_sequence(long n) {
    std::stringstream ss;
    for (long i = 0; i <= n; ++i) {
        ss << i;
        if (i < n) {
            ss << "" "";
        }
    }
    return ss.str();
"
1,1.0,HumanEval_15_string_sequence,"
std::string string_sequence(long n) {
    std::stringstream ss;
    for(long i = 0; i <= n; i++) {
        ss << i;
        if(i < n)
            ss << "" "";
    }
    return ss.str();
"
1,1.0,HumanEval_15_string_sequence,"
std::string string_sequence(long n) {
    std::stringstream ss;
    for(long i=0; i<=n; i++) {
        ss << i;
        if(i < n) {
            ss << "" "";
        }
    }
    return ss.str();
"
1,1.0,HumanEval_15_string_sequence,"

std::string string_sequence(long n) {
    std::stringstream ss;
    for(long i = 0; i <= n; i++) {
        ss << i;
        if(i < n)
            ss << "" "";
    }
    return ss.str();"
1,1.0,HumanEval_15_string_sequence,"
std::string string_sequence(long n) {
    std::stringstream ss;
    for(long i = 0; i <= n; i++) {
        ss << i;
        if(i < n)
            ss << "" "";
    }
    return ss.str();
"
1,1.0,HumanEval_15_string_sequence,"

std::string string_sequence(long n) {
    std::stringstream ss;
    for (long i = 0; i <= n; i++) {
        ss << i;
        if (i < n) {
            ss << "" "";
        }
    }
    return ss.str();"
1,1.0,HumanEval_15_string_sequence,"

std::string string_sequence(long n) {
    std::stringstream ss;
    for (long i = 0; i <= n; i++) {
        ss << i;
        if (i < n) {
            ss << "" "";
        }
    }
    return ss.str();"
1,1.0,HumanEval_15_string_sequence,"
std::string string_sequence(long n) {
    std::stringstream ss;
    for (long i = 0; i <= n; ++i) {
        ss << i;
        if (i < n) {
            ss << "" "";
        }
    }
    return ss.str();"
1,1.0,HumanEval_15_string_sequence,"
std::string string_sequence(long n) {
    std::stringstream ss;
    for (long i = 0; i <= n; ++i) {
        ss << i;
        if (i < n) {
            ss << "" "";
        }
    }
    return ss.str();
"
1,1.0,HumanEval_154_cycpattern_check,"
bool cycpattern_check(std::string a, std::string b) {
    // Check if b is a substring of a
    if (a.find(b) != std::string::npos) {
        return true;
    }

    // Check if any rotation of b is a substring of a
    for (size_t i = 0; i < b.size(); ++i) {
        std::rotate(b.begin(), b.begin() + 1, b.end());
        if (a.find(b) != std::string::npos) {
            return true;
        }
    }

    // If no rotation of b is a substring of a, return false
    return false;
"
1,1.0,HumanEval_154_cycpattern_check,"
bool cycpattern_check(std::string a, std::string b) {
    if (b.size() > a.size()) {
        return false;
    }

    for (int i = 0; i < b.size(); i++) {
        std::string rotation = b.substr(i) + b.substr(0, i);
        if (a.find(rotation) != std::string::npos) {
            return true;
        }
    }

    return false;"
1,1.0,HumanEval_154_cycpattern_check,"

bool cycpattern_check(std::string a, std::string b) {
    if(a.find(b) != std::string::npos) {
        return true;
    }

    for(int i = 0; i < b.size(); i++) {
        std::rotate(b.begin(), b.begin()+1, b.end());
        if(a.find(b) != std::string::npos) {
            return true;
        }
    }

    return false;"
1,1.0,HumanEval_154_cycpattern_check,"

bool cycpattern_check(std::string a, std::string b) {
    if (b.size() > a.size()) {
        return false;
    }
    std::string temp;
    for (int i = 0; i < b.size(); ++i) {
        temp = b.substr(i) + b.substr(0, i);
        if (a.find(temp) != std::string::npos) {
            return true;
        }
    }
    return false;"
1,1.0,HumanEval_154_cycpattern_check,"

bool cycpattern_check(std::string a, std::string b) {
    // Check if b is a substring of a
    if (a.find(b) != std::string::npos) {
        return true;
    }

    // Check if any rotation of b is a substring of a
    for (int i = 0; i < b.size(); i++) {
        std::rotate(b.begin(), b.begin()+1, b.end());
        if (a.find(b) != std::string::npos) {
            return true;
        }
    }

    // If no rotation of b is a substring of a, return false
    return false;
"
1,1.0,HumanEval_154_cycpattern_check,"

bool cycpattern_check(std::string a, std::string b) {
    // Check if b is a substring of a
    if (a.find(b) != std::string::npos) {
        return true;
    }

    // Check if any rotation of b is a substring of a
    for (size_t i = 0; i < b.size(); i++) {
        std::rotate(b.begin(), b.begin() + 1, b.end());
        if (a.find(b) != std::string::npos) {
            return true;
        }
    }

    // If no rotation of b is a substring of a, return false
    return false;
"
0,1.0,HumanEval_154_cycpattern_check,"

bool cycpattern_check(std::string a, std::string b) {
    // Create a string that is double of input string
    std::string a2 = a + a;

    // If string b is not a substring of a2, return false
    if (a2.find(b) == std::string::npos) {
        return false;
    }

    // If we reach here, we found a rotation of b in a
    return true;
"
1,1.0,HumanEval_154_cycpattern_check,"

bool cycpattern_check(std::string a, std::string b) {
    int a_len = a.length();
    int b_len = b.length();

    if(a_len < b_len) {
        return false;
    }

    for(int i = 0; i < b_len; i++) {
        std::string temp = b.substr(i) + b.substr(0, i);
        if(a.find(temp) != std::string::npos) {
            return true;
        }
    }

    return false;"
0,0.0,HumanEval_154_cycpattern_check,"

bool cycpattern_check(std::string a, std::string b) {
    int a_len = a.length();
    int b_len = b.length();

    if (a_len < b_len) {
        return false;
    }

    for (int i = 0; i < b_len; i++) {
        std::string a_rotation = a.substr(i) + a.substr(0, i);
        if (a_rotation.find(b) != std::string::npos) {
            return true;
        }
    }

    return false;"
1,1.0,HumanEval_154_cycpattern_check,"
bool cycpattern_check(std::string a, std::string b) {
    if(a.size() < b.size()) return false;
    for(int i = 0; i < b.size(); i++) {
        std::string temp = b.substr(i) + b.substr(0, i);
        if(a.find(temp) != std::string::npos) {
            return true;
        }
    }
    return false;
"
1,1.0,HumanEval_57_monotonic,"
bool monotonic(std::vector<long> l) {
    if(l.size() <= 2) {
        return true;
    }
    bool increasing = false, decreasing = false;
    for(int i=0; i<l.size()-1; i++) {
        if(l[i] < l[i+1]) {
            increasing = true;
        }
        if(l[i] > l[i+1]) {
            decreasing = true;
        }
        if(increasing && decreasing) {
            return false;
        }
    }
    return true;"
1,1.0,HumanEval_57_monotonic,"

bool monotonic(std::vector<long> l) {
    if (l.size() < 2) {
        return true;
    }

    // Check if the vector is increasing or decreasing
    bool increasing = true;
    bool decreasing = true;

    for (size_t i = 1; i < l.size(); ++i) {
        if (l[i-1] > l[i]) {
            increasing = false;
        }
        if (l[i-1] < l[i]) {
            decreasing = false;
        }
    }

    return increasing || decreasing;"
1,1.0,HumanEval_57_monotonic,"
bool monotonic(std::vector<long> l) {
    if (l.size() <= 2) {
        return true;  // A vector of size 0 or 1 or 2 is always monotonic
    }

    // Check if the vector is increasing or decreasing
    bool increasing = true;
    bool decreasing = true;

    for (size_t i = 1; i < l.size(); ++i) {
        if (l[i - 1] > l[i]) {
            increasing = false;
        }
        if (l[i - 1] < l[i]) {
            decreasing = false;
        }
    }

    return increasing || decreasing;
"
1,1.0,HumanEval_57_monotonic,"

bool monotonic(std::vector<long> l) {
    if (l.size() <= 2)
        return true;

    bool increasing = true, decreasing = true;

    for (int i = 1; i < l.size(); i++) {
        if (l[i-1] > l[i])
            increasing = false;
        if (l[i-1] < l[i])
            decreasing = false;
    }

    return increasing || decreasing;
"
1,1.0,HumanEval_57_monotonic,"
bool monotonic(std::vector<long> l) {
    if (l.size() <= 2) return true;

    bool increasing = true;
    bool decreasing = true;

    for (size_t i = 1; i < l.size(); i++) {
        if (l[i-1] > l[i]) increasing = false;
        if (l[i-1] < l[i]) decreasing = false;
    }

    return increasing || decreasing;
"
1,1.0,HumanEval_57_monotonic,"
bool monotonic(std::vector<long> l) {
    if (l.size() < 2) {
        return true;
    }

    bool increasing = true;
    bool decreasing = true;

    for (size_t i = 1; i < l.size(); ++i) {
        if (l[i-1] > l[i]) {
            increasing = false;
        }
        if (l[i-1] < l[i]) {
            decreasing = false;
        }
    }

    return increasing || decreasing;"
1,1.0,HumanEval_57_monotonic,"
bool monotonic(std::vector<long> l) {
    if (l.size() <= 2) {
        return true;
    }

    bool increasing = true;
    bool decreasing = true;

    for (size_t i = 1; i < l.size(); ++i) {
        if (l[i] < l[i - 1]) {
            increasing = false;
        }
        if (l[i] > l[i - 1]) {
            decreasing = false;
        }
    }

    return increasing || decreasing;"
1,1.0,HumanEval_57_monotonic,"

bool monotonic(std::vector<long> l) {
    if (l.size() <= 2) return true;

    bool increasing = false, decreasing = false;

    for (size_t i = 1; i < l.size(); ++i) {
        if (l[i-1] < l[i]) {
            if (decreasing) return false;
            increasing = true;
        } else if (l[i-1] > l[i]) {
            if (increasing) return false;
            decreasing = true;
        }
    }

    return true;
"
1,1.0,HumanEval_57_monotonic,"

bool monotonic(std::vector<long> l) {
    if (l.size() <= 2) {
        return true;
    }

    bool increasing = false;
    bool decreasing = false;

    for (size_t i = 1; i < l.size(); ++i) {
        if (l[i] == l[i - 1]) {
            continue;
        }
        if (l[i] > l[i - 1]) {
            increasing = true;
        } else {
            decreasing = true;
        }
        if (increasing && decreasing) {
            return false;
        }
    }

    return true;
"
1,1.0,HumanEval_57_monotonic,"
bool monotonic(std::vector<long> l) {
    if (l.size() < 2) {
        return true;
    }

    bool increasing = true;
    bool decreasing = true;

    for (size_t i = 1; i < l.size(); ++i) {
        if (l[i] < l[i - 1]) {
            increasing = false;
        }
        if (l[i] > l[i - 1]) {
            decreasing = false;
        }
    }

    return increasing || decreasing;"
1,1.0,HumanEval_12_longest,"
std::optional<std::string> longest(std::vector<std::string> strings) {
    if(strings.empty()) {
        return std::nullopt;
    }

    std::string longest = strings[0];
    for(const std::string& s : strings) {
        if(s.size() > longest.size()) {
            longest = s;
        }
    }

    return longest;
"
0,0.0,HumanEval_12_longest,"
    if (strings.empty()) {
        return std::nullopt;
    }

    std::string longest = strings[0];
    for (const auto& str : strings) {
        if (str.size() > longest.size()) {
            longest = str;
        }
    }

    return longest;
"
1,1.0,HumanEval_12_longest,"
std::optional<std::string> longest(std::vector<std::string> strings) {
    if(strings.empty()) {
        return std::nullopt;
    }

    std::string longest = strings[0];
    for(const auto& str : strings) {
        if(str.size() > longest.size()) {
            longest = str;
        }
    }

    return longest;
"
1,1.0,HumanEval_12_longest,"

std::optional<std::string> longest(std::vector<std::string> strings) {
    if (strings.empty()) {
        return std::nullopt;
    }

    std::string longest = strings[0];
    for (const auto& str : strings) {
        if (str.size() > longest.size()) {
            longest = str;
        }
    }
    return longest;
"
1,1.0,HumanEval_12_longest,"
std::optional<std::string> longest(std::vector<std::string> strings) {
    if(strings.empty()) {
        return std::nullopt;
    }

    std::string longest = strings[0];
    for(const auto& str : strings) {
        if(str.size() > longest.size()) {
            longest = str;
        }
    }

    return longest;
"
1,1.0,HumanEval_12_longest,"
std::optional<std::string> longest(std::vector<std::string> strings) {
    if (strings.empty()) {
        return std::nullopt;
    }

    std::string longest = strings[0];
    for (const auto &s : strings) {
        if (s.length() > longest.length()) {
            longest = s;
        }
    }

    return longest;"
1,1.0,HumanEval_12_longest,"

std::optional<std::string> longest(std::vector<std::string> strings) {
    if (strings.empty()) {
        return std::nullopt;
    }
    
    std::string longest = strings[0];
    for (const auto& str : strings) {
        if (str.size() > longest.size()) {
            longest = str;
        }
    }
    
    return longest;
"
1,1.0,HumanEval_12_longest,"
std::optional<std::string> longest(std::vector<std::string> strings) {
    if (strings.empty()) {
        return std::nullopt;
    }

    std::string longest = strings[0];
    for (const std::string& s : strings) {
        if (s.size() > longest.size()) {
            longest = s;
        }
    }

    return longest;"
1,1.0,HumanEval_12_longest,"

std::optional<std::string> longest(std::vector<std::string> strings) {
    if (strings.empty()) {
        return std::nullopt;
    }

    std::string longest = strings[0];
    for (const auto& str : strings) {
        if (str.size() > longest.size()) {
            longest = str;
        }
    }

    return longest;
"
1,1.0,HumanEval_12_longest,"

std::optional<std::string> longest(std::vector<std::string> strings) {
    if (strings.empty()) {
        return std::nullopt;
    }

    std::string longest = strings[0];
    for (const auto& s : strings) {
        if (s.size() > longest.size()) {
            longest = s;
        }
    }

    return longest;"
1,1.0,HumanEval_52_below_threshold,"

bool below_threshold(std::vector<long> l, long t) {
    for(long num : l) {
        if(num >= t) {
            return false;
        }
    }
    return true;
"
1,1.0,HumanEval_52_below_threshold,"
bool below_threshold(std::vector<long> l, long t) {
    for(long num : l) {
        if(num >= t) {
            return false;
        }
    }
    return true;
"
1,1.0,HumanEval_52_below_threshold,"

bool below_threshold(std::vector<long> l, long t) {
    for(auto i : l) {
        if(i >= t) {
            return false;
        }
    }
    return true;"
1,1.0,HumanEval_52_below_threshold,"

bool below_threshold(std::vector<long> l, long t) {
    for(auto i: l) {
        if(i >= t) {
            return false;
        }
    }
    return true;"
0,0.0,HumanEval_52_below_threshold,"
    for(long num : l) {
        if(num >= t) {
            return false;
        }
    }
    return true;
"
1,1.0,HumanEval_52_below_threshold,"
bool below_threshold(std::vector<long> l, long t) {
    for(long num : l) {
        if(num >= t) {
            return false;
        }
    }
    return true;"
0,0.0,HumanEval_52_below_threshold,"
    for(auto num : l) {
        if(num >= t) {
            return false;
        }
    }
    return true;
"
1,1.0,HumanEval_52_below_threshold,"

bool below_threshold(std::vector<long> l, long t) {
    for(long i : l) {
        if(i >= t) {
            return false;
        }
    }
    return true;
"
1,1.0,HumanEval_52_below_threshold,"
bool below_threshold(std::vector<long> l, long t) {
    for(long num : l) {
        if(num >= t) {
            return false;
        }
    }
    return true;"
0,0.0,HumanEval_52_below_threshold,"
    // Loop through the vector and check each element
    for(long num : l) {
        if(num >= t) {
            // If any element is greater than or equal to the threshold, return false
            return false;
        }
    }
    // If all elements are below the threshold, return true
    return true;
"
0,1.0,HumanEval_75_is_multiply_prime,"

bool is_multiply_prime(long a) {
    if (a <= 1) return false;
    int count = 0;
    while (a % 2 == 0) {
        a = a / 2;
        count++;
    }
    if (count > 1) return false;

    for (int i = 3; i <= sqrt(a); i += 2) {
        count = 0;
        while (a % i == 0) {
            a = a / i;
            count++;
        }
        if (count > 1) return false;
    }

    if (a > 2) return false;

    return true;"
0,0.0,HumanEval_75_is_multiply_prime,"
    if (a <= 1) {
        return false;
    }
    int count = 0;
    for (int i = 2; i * i <= a; i++) {
        while (a % i == 0) {
            a /= i;
            count++;
        }
    }
    if (a > 1) {
        count++;
    }
    return count == 3;
"
0,0.0,HumanEval_75_is_multiply_prime,"

bool is_multiply_prime(long a) {
    if (a < 2) return false;
    int count = 0;
    while (a % 2 == 0) {
        a /= 2;
        count++;
    }
    if (count > 1) return false;

    for (int i = 3; i <= sqrt(a); i += 2) {
        count = 0;
        while (a % i == 0) {
            a /= i;
            count++;
        }
        if (count > 1) return false;
    }
    return a == 1 || a % a == 0;"
0,0.0,HumanEval_75_is_multiply_prime,"
bool is_multiply_prime(long a) {
    if (a < 2) {
        return false;
    }
    if (a % 2 == 0) {
        return false;
    }
    for (long i = 3; i * i <= a; i += 2) {
        if (a % i == 0) {
            return false;
        }
    }
    return true;
"
0,0.0,HumanEval_75_is_multiply_prime,"

bool is_multiply_prime(long a) {
    if(a <= 1) return false;
    long count = 0;
    for(long i=2; i*i<=a; i++) {
        if(a%i==0) {
            if(is_prime(i)) count++;
            if(is_prime(a/i)) count++;
        }
    }
    if(a%2==0 && is_prime(a/2)) count++;
    return count>=3;"
0,0.0,HumanEval_75_is_multiply_prime,"

bool is_multiply_prime(long a) {
    if (a <= 1)
        return false;
    int prime_count = 0;
    for (long i = 2; i * i <= a; i++) {
        if (a % i == 0) {
            if (is_prime(i))
                prime_count++;
            if (is_prime(a / i))
                prime_count++;
        }
    }
    // check if the square root of a is a prime number
    long sqrt_a = sqrt(a);
    if (sqrt_a * sqrt_a == a && is_prime(sqrt_a))
        prime_count++;
    return prime_count == 3;
"
0,0.0,HumanEval_75_is_multiply_prime,"

bool is_multiply_prime(long a) {
    if (a <= 1) return false;
    int count = 0;
    while (a % 2 == 0) {
        a = a / 2;
        count++;
    }
    if (count > 1) return false;

    for (long i = 3; i <= sqrt(a); i += 2) {
        if (a % i == 0) {
            if (!isPrime(i)) return false;
            while (a % i == 0) {
                a = a / i;
                count++;
            }
            if (count > 1) return false;
        }
    }
    if (a > 2 && isPrime(a)) count++;
    return count == 3;
"
0,0.0,HumanEval_75_is_multiply_prime,"

bool is_multiply_prime(long a) {
    if (a < 2) {
        return false;
    }
    if (a % 2 == 0) {
        return false;
    }
    int prime_factors = 0;
    for (long i = 3; i * i <= a; i += 2) {
        if (a % i == 0) {
            while (a % i == 0) {
                a /= i;
                prime_factors++;
            }
            if (prime_factors == 2) {
                return a % i == 0;
            }
        }
    }
    return a % a == 0 && prime_factors == 2;"
0,1.0,HumanEval_75_is_multiply_prime,"

bool is_multiply_prime(long a) {
    if (a <= 1) return false;
    long primeFactors = 0;
    for (long i = 2; i * i <= a; i++) {
        if (a % i == 0) {
            if (isPrime(i)) primeFactors++;
            while (a % i == 0) a /= i;
            if (isPrime(a)) primeFactors++;
        }
    }
    if (a > 1 && isPrime(a)) primeFactors++;
    return primeFactors == 3;
"
0,0.0,HumanEval_75_is_multiply_prime,"
    if (a < 2) {
        return false;
    }
    while (a % 2 == 0) {
        a /= 2;
    }
    if (a == 1) {
        return false;
    }
    for (long i = 3; i * i <= a; i += 2) {
        if (a % i == 0) {
            a /= i;
            while (a % i == 0) {
                a /= i;
            }
            if (a == 1) {
                return true;
            }
        }
    }
    return a > 1;"
0,1.0,HumanEval_30_get_positive,"

std::vector<long> get_positive(std::vector<long> l) {
    l.erase(std::remove_if(l.begin(), l.end(), [](long i){ return i < 0; }), l.end());
    return l;"
1,1.0,HumanEval_30_get_positive,"
std::vector<long> get_positive(std::vector<long> l) {
    std::vector<long> positive;
    for(long num : l) {
        if(num > 0) {
            positive.push_back(num);
        }
    }
    return positive;
"
1,1.0,HumanEval_30_get_positive,"

std::vector<long> get_positive(std::vector<long> l) {
    std::vector<long> positive_numbers;
    for(long num : l) {
        if(num > 0) {
            positive_numbers.push_back(num);
        }
    }
    return positive_numbers;
"
1,1.0,HumanEval_30_get_positive,"

std::vector<long> get_positive(std::vector<long> l) {
    std::vector<long> positive_numbers;
    for (long num : l) {
        if (num > 0) {
            positive_numbers.push_back(num);
        }
    }
    return positive_numbers;
"
1,1.0,HumanEval_30_get_positive,"

std::vector<long> get_positive(std::vector<long> l) {
    std::vector<long> positive_numbers;
    for(long num : l) {
        if(num > 0) {
            positive_numbers.push_back(num);
        }
    }
    return positive_numbers;"
1,1.0,HumanEval_30_get_positive,"

std::vector<long> get_positive(std::vector<long> l) {
    std::vector<long> positive;
    for(long num : l) {
        if(num > 0) {
            positive.push_back(num);
        }
    }
    return positive;"
1,1.0,HumanEval_30_get_positive,"

std::vector<long> get_positive(std::vector<long> l) {
    std::vector<long> positive;
    for(long num : l) {
        if(num > 0) {
            positive.push_back(num);
        }
    }
    return positive;
"
1,1.0,HumanEval_30_get_positive,"

std::vector<long> get_positive(std::vector<long> l) {
    std::vector<long> positive_numbers;
    for(long num : l) {
        if(num > 0) {
            positive_numbers.push_back(num);
        }
    }
    return positive_numbers;"
1,1.0,HumanEval_30_get_positive,"
std::vector<long> get_positive(std::vector<long> l) {
    std::vector<long> positive_nums;
    for (long num : l) {
        if (num > 0) {
            positive_nums.push_back(num);
        }
    }
    return positive_nums;
"
0,1.0,HumanEval_30_get_positive,"
    std::vector<long> positive;
    for (long num : l) {
        if (num > 0) {
            positive.push_back(num);
        }
    }
    return positive;
"
0,1.0,HumanEval_33_sort_third,"
std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> sorted_third;
    for (int i = 0; i < l.size(); i++) {
        if ((i+1) % 3 == 0) {
            sorted_third.push_back(l[i]);
        }
    }
    std::sort(sorted_third.begin(), sorted_third.end());
    for (int i = 0, j = 0; i < l.size(); i++) {
        if ((i+1) % 3 == 0) {
            l[i] = sorted_third[j++];
        }
    }
    return l;
"
0,1.0,HumanEval_33_sort_third,"

std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> sorted_third;
    for (size_t i = 2; i < l.size(); i += 3) {
        sorted_third.push_back(l[i]);
    }
    std::sort(sorted_third.begin(), sorted_third.end());
    for (size_t i = 2, j = 0; i < l.size(); i += 3, ++j) {
        l[i] = sorted_third[j];
    }
    return l;"
1,1.0,HumanEval_33_sort_third,"
std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> sorted_third;
    for (size_t i = 0; i < l.size(); ++i) {
        if (i % 3 == 0) {
            sorted_third.push_back(l[i]);
        }
    }
    std::sort(sorted_third.begin(), sorted_third.end());
    for (size_t i = 0, j = 0; i < l.size(); ++i) {
        if (i % 3 == 0) {
            l[i] = sorted_third[j++];
        }
    }
    return l;"
0,1.0,HumanEval_33_sort_third,"

std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> sorted_third;
    for (size_t i = 0; i < l.size(); i++) {
        if ((i+1) % 3 == 0) {
            sorted_third.push_back(l[i]);
        }
    }
    std::sort(sorted_third.begin(), sorted_third.end());
    for (size_t i = 0, j = 0; i < l.size(); i++) {
        if ((i+1) % 3 == 0) {
            l[i] = sorted_third[j++];
        }
    }
    return l;"
1,1.0,HumanEval_33_sort_third,"
std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> sorted_third;
    for (size_t i = 0; i < l.size(); ++i) {
        if (i % 3 == 0) {
            sorted_third.push_back(l[i]);
        }
    }
    std::sort(sorted_third.begin(), sorted_third.end());
    for (size_t i = 0, j = 0; i < l.size(); ++i) {
        if (i % 3 == 0) {
            l[i] = sorted_third[j++];
        }
    }
    return l;"
0,1.0,HumanEval_33_sort_third,"
std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> third_elements;
    for (size_t i = 2; i < l.size(); i += 3) {
        third_elements.push_back(l[i]);
    }
    std::sort(third_elements.begin(), third_elements.end());
    for (size_t i = 2, j = 0; i < l.size(); i += 3, ++j) {
        l[i] = third_elements[j];
    }
    return l;"
0,0.0,HumanEval_33_sort_third,"
std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> sorted_third_indices;
    for (int i = 0; i < l.size(); i++) {
        if ((i+1) % 3 == 0) {
            sorted_third_indices.push_back(l[i]);
        }
    }
    std::sort(sorted_third_indices.begin(), sorted_third_indices.end());
    for (int i = 0; i < l.size(); i++) {
        if ((i+1) % 3 == 0) {
            l[i] = sorted_third_indices[i/3];
        }
    }
    return l;
"
0,1.0,HumanEval_33_sort_third,"

std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> sorted_third;
    for (size_t i = 0; i < l.size(); i++) {
        if ((i+1) % 3 == 0) {
            sorted_third.push_back(l[i]);
        }
    }
    std::sort(sorted_third.begin(), sorted_third.end());
    for (size_t i = 0, j = 0; i < l.size(); i++) {
        if ((i+1) % 3 == 0) {
            l[i] = sorted_third[j++];
        }
    }
    return l;
"
0,1.0,HumanEval_33_sort_third,"
std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> sorted_third;
    for(int i = 0; i < l.size(); i++) {
        if((i+1) % 3 == 0) {
            sorted_third.push_back(l[i]);
        }
    }
    std::sort(sorted_third.begin(), sorted_third.end());
    for(int i = 0, j = 0; i < l.size(); i++) {
        if((i+1) % 3 == 0) {
            l[i] = sorted_third[j++];
        }
    }
    return l;"
0,1.0,HumanEval_33_sort_third,"

std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> sorted_third;
    for(size_t i = 0; i < l.size(); i++) {
        if((i+1) % 3 == 0) {
            sorted_third.push_back(l[i]);
        }
    }
    std::sort(sorted_third.begin(), sorted_third.end());
    for(size_t i = 0, j = 0; i < l.size(); i++) {
        if((i+1) % 3 == 0) {
            l[i] = sorted_third[j++];
        }
    }
    return l;"
1,1.0,HumanEval_6_parse_nested_parens,"
std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> result;
    std::istringstream iss(paren_string);
    std::string group;

    while (iss >> group) {
        long maxDepth = 0;
        long currentDepth = 0;

        for (char c : group) {
            if (c == '(') {
                currentDepth++;
                maxDepth = std::max(maxDepth, currentDepth);
            } else if (c == ')') {
                currentDepth--;
            }
        }

        result.push_back(maxDepth);
    }

    return result;"
1,1.0,HumanEval_6_parse_nested_parens,"
std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> result;
    std::istringstream ss(paren_string);
    std::string group;
    
    while (std::getline(ss, group, ' ')) {
        long max_depth = 0;
        long current_depth = 0;
        
        for (char c : group) {
            if (c == '(') {
                current_depth++;
                if (current_depth > max_depth) {
                    max_depth = current_depth;
                }
            } else if (c == ')') {
                current_depth--;
            }
        }
        
        result.push_back(max_depth);
    }
    
    return result;
"
1,1.0,HumanEval_6_parse_nested_parens,"
std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> result;
    std::stringstream ss(paren_string);
    std::string group;
    while (std::getline(ss, group, ' ')) {
        long max_depth = 0;
        long current_depth = 0;
        for (char c : group) {
            if (c == '(') {
                current_depth++;
                if (current_depth > max_depth) {
                    max_depth = current_depth;
                }
            } else if (c == ')') {
                current_depth--;
            }
        }
        result.push_back(max_depth);
    }
    return result;
"
0,0.0,HumanEval_6_parse_nested_parens,"
    std::vector<long> results;
    std::stringstream ss(paren_string);
    std::string group;
    
    while (std::getline(ss, group, ' ')) {
        long max_depth = 0;
        long current_depth = 0;
        
        for (char c : group) {
            if (c == '(') {
                current_depth++;
                if (current_depth > max_depth) {
                    max_depth = current_depth;
                }
            } else if (c == ')') {
                current_depth--;
            }
        }
        
        assert(current_depth == 0);  // All parentheses should be balanced
        results.push_back(max_depth);
    }
    
    return results;"
1,1.0,HumanEval_6_parse_nested_parens,"
std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> result;
    std::stringstream ss(paren_string);
    std::string group;

    while (std::getline(ss, group, ' ')) {
        long maxDepth = 0;
        long currentDepth = 0;

        for (char c : group) {
            if (c == '(') {
                currentDepth++;
                maxDepth = std::max(maxDepth, currentDepth);
            } else if (c == ')') {
                currentDepth--;
            }
        }

        result.push_back(maxDepth);
    }

    return result;"
1,1.0,HumanEval_6_parse_nested_parens,"
std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> levels;
    std::istringstream ss(paren_string);
    std::string group;

    while (std::getline(ss, group, ' ')) {
        long max_level = 0;
        long current_level = 0;

        for (char c : group) {
            if (c == '(') {
                current_level++;
                if (current_level > max_level) {
                    max_level = current_level;
                }
            } else if (c == ')') {
                current_level--;
            }
        }

        levels.push_back(max_level);
    }

    return levels;
"
1,1.0,HumanEval_6_parse_nested_parens,"
std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> result;
    std::stringstream ss(paren_string);
    std::string group;
    
    while (std::getline(ss, group, ' ')) {
        long maxDepth = 0;
        long currentDepth = 0;
        
        for (char c : group) {
            if (c == '(') {
                currentDepth++;
                maxDepth = std::max(maxDepth, currentDepth);
            } else if (c == ')') {
                currentDepth--;
            }
        }
        
        result.push_back(maxDepth);
    }
    
    return result;
"
1,1.0,HumanEval_6_parse_nested_parens,"
std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> levels;
    std::stringstream ss(paren_string);
    std::string group;

    while (std::getline(ss, group, ' ')) {
        long max_level = 0;
        long current_level = 0;

        for (char c : group) {
            if (c == '(') {
                current_level++;
                max_level = std::max(max_level, current_level);
            } else if (c == ')') {
                current_level--;
            }
        }

        levels.push_back(max_level);
    }

    return levels;
"
1,1.0,HumanEval_6_parse_nested_parens,"

std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> result;
    std::stringstream ss(paren_string);
    std::string paren_group;

    while (getline(ss, paren_group, ' ')) {
        long max_depth = 0;
        long current_depth = 0;
        for (char c : paren_group) {
            if (c == '(') {
                current_depth++;
                if (current_depth > max_depth) {
                    max_depth = current_depth;
                }
            } else if (c == ')') {
                current_depth--;
            }
        }
        result.push_back(max_depth);
    }

    return result;"
1,1.0,HumanEval_6_parse_nested_parens,"
std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> results;
    std::stringstream ss(paren_string);
    std::string group;

    while (std::getline(ss, group, ' ')) {
        long count = 0;
        long max_count = 0;
        for (char c : group) {
            if (c == '(') {
                count++;
                if (count > max_count) {
                    max_count = count;
                }
            } else if (c == ')') {
                count--;
            }
        }
        results.push_back(max_count);
    }

    return results;
"
1,1.0,HumanEval_45_triangle_area,"
float triangle_area(long a, long h) {
    float area = 0.5 * a * h;
    return area;
"
1,1.0,HumanEval_45_triangle_area,"
float triangle_area(long a, long h) {
    return 0.5 * a * h;
"
1,1.0,HumanEval_45_triangle_area,"
float triangle_area(long a, long h) {
    return 0.5 * a * h;"
0,0.0,HumanEval_45_triangle_area,"
    // Area of a triangle is 0.5 * base * height.
    float area = 0.5 * a * h;
    return area;
"
1,1.0,HumanEval_45_triangle_area,"
float triangle_area(long a, long h) {
    return (0.5f * a * h);"
0,0.0,HumanEval_45_triangle_area,"
    // The formula for calculating the area of a triangle is 0.5 * base * height
    float area = 0.5 * a * h;
    return area;
"
1,1.0,HumanEval_45_triangle_area,"
float triangle_area(long a, long h) {
    return 0.5f * a * h;"
0,0.0,HumanEval_45_triangle_area,"
    // Calculate the area of the triangle using formula (0.5 * base * height)
    float area = 0.5f * a * h;
    return area;
"
1,1.0,HumanEval_45_triangle_area,"
float triangle_area(long a, long h) {
    return 0.5 * a * h;
"
0,0.0,HumanEval_45_triangle_area,"
    assert(a > 0 && h > 0); // Ensure the inputs are positive.
    return 0.5 * a * h;"
1,1.0,HumanEval_97_multiply,"
long multiply(long a, long b) {
    // get the unit digits of a and b
    long unit_digit_a = abs(a % 10);
    long unit_digit_b = abs(b % 10);

    // return the product of their unit digits
    return unit_digit_a * unit_digit_b;"
0,0.0,HumanEval_97_multiply,"
    // Extract the unit digits of the numbers
    long unit_digit_a = abs(a % 10);
    long unit_digit_b = abs(b % 10);

    // Multiply the unit digits
    long result = unit_digit_a * unit_digit_b;

    return result;
"
0,0.0,HumanEval_97_multiply,"
    long unit_digit_a = abs(a % 10);
    long unit_digit_b = abs(b % 10);
    return unit_digit_a * unit_digit_b;
"
0,0.0,HumanEval_97_multiply,"
    // Get the unit digit of each number
    long unit_digit_a = abs(a % 10);
    long unit_digit_b = abs(b % 10);

    // Return the product of the unit digits
    return unit_digit_a * unit_digit_b;
"
0,0.0,HumanEval_97_multiply,"
    // Get the unit digits of the numbers
    long a_unit = abs(a % 10);
    long b_unit = abs(b % 10);

    // Return the product of their unit digits
    return a_unit * b_unit;"
1,1.0,HumanEval_97_multiply,"
long multiply(long a, long b) {
    // get the unit digit of a and b
    long a_unit_digit = abs(a % 10);
    long b_unit_digit = abs(b % 10);

    // multiply the unit digits
    long result = a_unit_digit * b_unit_digit;

    // return the result
    return result;
"
1,1.0,HumanEval_97_multiply,"
long multiply(long a, long b) {
    // Extract the unit digit of both numbers
    long unit_a = abs(a % 10);
    long unit_b = abs(b % 10);

    // Return the product of the unit digits
    return unit_a * unit_b;"
1,1.0,HumanEval_97_multiply,"
long multiply(long a, long b) {
    // Get the unit digits of a and b
    long a_unit = abs(a % 10);
    long b_unit = abs(b % 10);

    // Return the product of the unit digits
    return a_unit * b_unit;"
1,1.0,HumanEval_97_multiply,"

long multiply(long a, long b) {
    // Get the unit digit of each number
    long unit_a = abs(a % 10);
    long unit_b = abs(b % 10);

    // Multiply the unit digits and return the result
    return unit_a * unit_b;"
0,0.0,HumanEval_97_multiply,"
    // Get the unit digits of the numbers
    long unit_digit_a = abs(a % 10);
    long unit_digit_b = abs(b % 10);

    // Return the product of the unit digits
    return unit_digit_a * unit_digit_b;
"
1,1.0,HumanEval_4_mean_absolute_deviation,"

float mean_absolute_deviation(std::vector<float> numbers) {
    float sum = 0.0f;
    for(float num : numbers) {
        sum += num;
    }
    float mean = sum / numbers.size();

    float mad = 0.0f;
    for(float num : numbers) {
        mad += std::abs(num - mean);
    }
    return mad / numbers.size();"
1,1.0,HumanEval_4_mean_absolute_deviation,"
float mean_absolute_deviation(std::vector<float> numbers) {
    assert(!numbers.empty()); // ensure the vector is not empty
    float sum = 0.0f;
    for (float num : numbers) {
        sum += num;
    }
    float mean = sum / numbers.size();
    float mad = 0.0f;
    for (float num : numbers) {
        mad += std::abs(num - mean);
    }
    return mad / numbers.size();"
0,0.0,HumanEval_4_mean_absolute_deviation,"
    // Calculate the mean of the numbers
    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();

    // Calculate the absolute differences from the mean
    std::vector<float> differences(numbers.size());
    std::transform(numbers.begin(), numbers.end(), differences.begin(), [mean](float num) {
        return std::abs(num - mean);
    });

    // Calculate the mean of these differences
    float mad = std::accumulate(differences.begin(), differences.end(), 0.0f) / differences.size();

    return mad;"
1,1.0,HumanEval_4_mean_absolute_deviation,"

float mean_absolute_deviation(std::vector<float> numbers) {
    assert(!numbers.empty());

    float sum = 0.0f;
    for (float num : numbers) {
        sum += num;
    }
    float mean = sum / numbers.size();

    float mad = 0.0f;
    for (float num : numbers) {
        mad += std::abs(num - mean);
    }
    mad /= numbers.size();

    return mad;"
1,1.0,HumanEval_4_mean_absolute_deviation,"

float mean_absolute_deviation(std::vector<float> numbers) {
    assert(!numbers.empty());

    float sum = 0.0f;
    for(float num : numbers) {
        sum += num;
    }

    float mean = sum / numbers.size();

    float mad = 0.0f;
    for(float num : numbers) {
        mad += std::abs(num - mean);
    }

    return mad / numbers.size();"
1,1.0,HumanEval_4_mean_absolute_deviation,"

float mean_absolute_deviation(std::vector<float> numbers) {
    assert(!numbers.empty());  // Check if the vector is not empty

    // Calculate the mean of the numbers
    float sum = 0.0f;
    for(float num : numbers) {
        sum += num;
    }
    float mean = sum / numbers.size();

    // Calculate the Mean Absolute Deviation
    float mad = 0.0f;
    for(float num : numbers) {
        mad += std::abs(num - mean);
    }
    mad /= numbers.size();

    return mad;
"
1,1.0,HumanEval_4_mean_absolute_deviation,"

float mean_absolute_deviation(std::vector<float> numbers) {
    assert(!numbers.empty());
    float sum = 0.0f;
    for (float num : numbers) {
        sum += num;
    }
    float mean = sum / numbers.size();
    float mad = 0.0f;
    for (float num : numbers) {
        mad += std::abs(num - mean);
    }
    return mad / numbers.size();"
1,1.0,HumanEval_4_mean_absolute_deviation,"

float mean_absolute_deviation(std::vector<float> numbers) {
    assert(!numbers.empty());

    float sum = 0.0f;
    for(float num : numbers) {
        sum += num;
    }

    float mean = sum / numbers.size();

    float mad = 0.0f;
    for(float num : numbers) {
        mad += std::abs(num - mean);
    }

    return mad / numbers.size();
"
1,1.0,HumanEval_4_mean_absolute_deviation,"

float mean_absolute_deviation(std::vector<float> numbers) {
    assert(!numbers.empty());

    float sum = 0.0f;
    for (float num : numbers) {
        sum += num;
    }

    float mean = sum / numbers.size();

    float mad = 0.0f;
    for (float num : numbers) {
        mad += std::abs(num - mean);
    }

    return mad / numbers.size();"
1,1.0,HumanEval_4_mean_absolute_deviation,"

float mean_absolute_deviation(std::vector<float> numbers) {
    assert(!numbers.empty());

    float sum = 0.0f;
    for(const auto& num : numbers) {
        sum += num;
    }

    float mean = sum / numbers.size();

    float mad = 0.0f;
    for(const auto& num : numbers) {
        mad += std::abs(num - mean);
    }

    return mad / numbers.size();
"
1,1.0,HumanEval_58_common,"

std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    std::sort(l1.begin(), l1.end());
    std::sort(l2.begin(), l2.end());

    std::vector<long> result;
    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));

    // Remove duplicates
    result.erase(std::unique(result.begin(), result.end()), result.end());

    return result;
"
1,1.0,HumanEval_58_common,"

std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    std::set<long> s1(l1.begin(), l1.end());
    std::set<long> s2(l2.begin(), l2.end());
    std::vector<long> result;

    for(auto& i : s1) {
        if(s2.find(i) != s2.end()) {
            result.push_back(i);
        }
    }

    return result;"
1,1.0,HumanEval_58_common,"

std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    std::vector<long> result;
    std::sort(l1.begin(), l1.end());
    std::sort(l2.begin(), l2.end());
    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));
    std::sort(result.begin(), result.end());
    result.erase(std::unique(result.begin(), result.end()), result.end());
    return result;"
1,1.0,HumanEval_58_common,"
std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    std::vector<long> result;
    std::sort(l1.begin(), l1.end());
    std::sort(l2.begin(), l2.end());
    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));
    std::sort(result.begin(), result.end());
    result.erase(std::unique(result.begin(), result.end()), result.end());
    return result;"
1,1.0,HumanEval_58_common,"

std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    std::set<long> s1(l1.begin(), l1.end());
    std::set<long> s2(l2.begin(), l2.end());

    std::vector<long> result;
    for (long i : s1) {
        if (s2.count(i)) {
            result.push_back(i);
        }
    }

    std::sort(result.begin(), result.end());
    return result;"
1,1.0,HumanEval_58_common,"
std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    // Sort both vectors
    std::sort(l1.begin(), l1.end());
    std::sort(l2.begin(), l2.end());

    // Initialize an empty vector to store the common elements
    std::vector<long> common_elements;

    // Use two pointers to traverse the two vectors
    int i = 0, j = 0;
    while (i < l1.size() && j < l2.size()) {
        // If the elements at the current positions are equal, add it to the common_elements vector
        // and move both pointers
        if (l1[i] == l2[j]) {
            common_elements.push_back(l1[i]);
            i++;
            j++;
        }
        // If l1's element is smaller, move the l1's pointer
        else if (l1[i] < l2[j]) {
            i++;
        }
        // If l2's element is smaller, move the l2's pointer
        else {
            j++;
        }
    }

    // Remove duplicates from the common_elements vector
    common_elements.erase(std::unique(common_elements.begin(), common_elements.end()), common_elements.end());

    // Return the common_elements vector
    return common_elements;
"
1,0.0,HumanEval_58_common,"

std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    // Sort the vectors
    std::sort(l1.begin(), l1.end());
    std::sort(l2.begin(), l2.end());

    // Create a vector to store the result
    std::vector<long> result;

    // Find the common elements
    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));

    // Remove duplicates
    result.erase(std::unique(result.begin(), result.end()), result.end());

    return result;"
1,1.0,HumanEval_58_common,"

std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    std::vector<long> result;
    std::sort(l1.begin(), l1.end());
    std::sort(l2.begin(), l2.end());
    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));
    std::sort(result.begin(), result.end());
    result.erase(std::unique(result.begin(), result.end()), result.end());
    return result;"
1,1.0,HumanEval_58_common,"

std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    std::vector<long> result;
    std::sort(l1.begin(), l1.end());
    std::sort(l2.begin(), l2.end());
    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));
    std::sort(result.begin(), result.end());
    result.erase(std::unique(result.begin(), result.end()), result.end());
    return result;
"
1,1.0,HumanEval_58_common,"

std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    std::sort(l1.begin(), l1.end());
    std::sort(l2.begin(), l2.end());
    std::vector<long> result;
    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));
    result.erase(std::unique(result.begin(), result.end()), result.end());
    return result;"
1,1.0,HumanEval_156_int_to_mini_roman,"
std::string int_to_mini_roman(long number) {
    std::string roman = """";
    std::vector<std::string> symbol = {""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""};
    std::vector<int> value = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    
    for(int i = 0; i < value.size(); i++) {
        while(number >= value[i]) {
            number -= value[i];
            roman += symbol[i];
        }
    }
    
    return roman;
"
1,1.0,HumanEval_156_int_to_mini_roman,"

std::string int_to_mini_roman(long number) {
    std::vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    std::vector<std::string> numerals = {""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""};

    std::string result = """";
    for (int i = 0; i < values.size(); i++) {
        while (number >= values[i]) {
            number -= values[i];
            result += numerals[i];
        }
    }
    return result;"
1,1.0,HumanEval_156_int_to_mini_roman,"
std::string int_to_mini_roman(long number) {
    assert(1 <= number && number <= 1000);

    std::string roman = """";
    std::vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    std::vector<std::string> symbols = {""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""};

    for (int i = 0; i < values.size(); i++) {
        while (number >= values[i]) {
            number -= values[i];
            roman += symbols[i];
        }
    }

    return roman;"
1,1.0,HumanEval_156_int_to_mini_roman,"
std::string int_to_mini_roman(long number) {
    std::map<int, std::string, std::greater<int>> roman_map = {
        {1000, ""m""}, {900, ""cm""}, {500, ""d""}, {400, ""cd""},
        {100, ""c""}, {90, ""xc""}, {50, ""l""}, {40, ""xl""},
        {10, ""x""}, {9, ""ix""}, {5, ""v""}, {4, ""iv""}, {1, ""i""}
    };

    std::string result = """";

    for (auto& pair : roman_map) {
        while (number >= pair.first) {
            number -= pair.first;
            result += pair.second;
        }
    }

    return result;
"
1,1.0,HumanEval_156_int_to_mini_roman,"
std::string int_to_mini_roman(long number) {
    assert(1 <= number && number <= 1000);

    std::vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    std::vector<std::string> numerals = {""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""};

    std::string result = """";
    for (int i = 0; i < values.size(); i++) {
        while (number >= values[i]) {
            number -= values[i];
            result += numerals[i];
        }
    }
    return result;"
1,1.0,HumanEval_156_int_to_mini_roman,"

std::string int_to_mini_roman(long number) {
    assert(1 <= number && number <= 1000);
    std::string roman = """";
    std::vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    std::vector<std::string> symbols = {""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""};

    for (int i = 0; i < values.size(); i++) {
        while (number >= values[i]) {
            number -= values[i];
            roman += symbols[i];
        }
    }

    return roman;"
1,1.0,HumanEval_156_int_to_mini_roman,"
std::string int_to_mini_roman(long number) {
    assert(1 <= number && number <= 1000);

    std::string roman = """";
    std::vector<std::string> symbol = {""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""};
    std::vector<int> value = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};

    for (int i = 0; i < value.size(); i++) {
        while (number >= value[i]) {
            number -= value[i];
            roman += symbol[i];
        }
    }

    return roman;"
1,1.0,HumanEval_156_int_to_mini_roman,"
std::string int_to_mini_roman(long number) {
    assert(1 <= number && number <= 1000);
    std::string roman = """";
    std::vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    std::vector<std::string> symbols = {""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""};

    for (int i = 0; i < values.size(); i++) {
        while (number >= values[i]) {
            number -= values[i];
            roman += symbols[i];
        }
    }

    return roman;
"
1,1.0,HumanEval_156_int_to_mini_roman,"
std::string int_to_mini_roman(long number) {
    std::string roman = """";
    std::vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    std::vector<std::string> symbols = {""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""};

    for (int i = 0; i < values.size(); i++) {
        while (number >= values[i]) {
            number -= values[i];
            roman += symbols[i];
        }
    }

    return roman;"
1,1.0,HumanEval_156_int_to_mini_roman,"
std::string int_to_mini_roman(long number) {
    std::string roman = """";
    int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    std::string symbols[] = {""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""};

    for (int i = 0; i < 13; i++) {
        while (number >= values[i]) {
            number -= values[i];
            roman += symbols[i];
        }
    }

    return roman;
"
0,1.0,HumanEval_67_fruit_distribution,"

long fruit_distribution(std::string s, long n) {
    std::istringstream iss(s);
    long apples, oranges;
    std::string temp;

    // Extract the number of apples and oranges from the string
    iss >> temp;
    apples = std::stol(temp);
    iss >> temp; // ignore ""apples""
    iss >> temp;
    oranges = std::stol(temp);

    // Calculate the number of mangoes
    long mangoes = n - (apples + oranges);

    return mangoes;"
0,1.0,HumanEval_67_fruit_distribution,"
long fruit_distribution(std::string s, long n) {
    std::istringstream iss(s);
    long apples, oranges;
    std::string temp;
    iss >> temp >> apples >> temp >> oranges;

    long mangoes = n - (apples + oranges);
    assert(mangoes >= 0);

    return mangoes;"
0,0.0,HumanEval_67_fruit_distribution,"

long fruit_distribution(std::string s, long n) {
    std::stringstream ss(s);
    long apples, oranges;
    std::string temp;

    ss >> temp >> apples >> temp >> oranges;

    assert(apples >= 0 && oranges >= 0);
    assert(n >= apples + oranges);

    long mangoes = n - (apples + oranges);

    assert(mangoes >= 0);

    return mangoes;"
0,1.0,HumanEval_67_fruit_distribution,"

long fruit_distribution(std::string s, long n) {
    // Parse the string to get the number of apples and oranges
    std::istringstream ss(s);
    std::string temp;
    long apples = 0, oranges = 0;
    while (!ss.eof()) {
        ss >> temp;
        if (stringstream(temp) << apples) apples = stoi(temp);
        else if (temp == ""apples"") break;
        ss >> temp;
        if (stringstream(temp) << oranges) oranges = stoi(temp);
        else if (temp == ""oranges"") break;
    }

    // Calculate the number of mangoes
    long mangoes = n - (apples + oranges);

    // Ensure the number of mangoes is positive
    assert(mangoes >= 0);

    return mangoes;
"
0,1.0,HumanEval_67_fruit_distribution,"
#include<assert.h>
#include<bits/stdc++.h>
using namespace std;

long fruit_distribution(string s, long n) {
    stringstream ss(s);
    long apples, oranges;
    string temp;
    
    ss >> temp >> apples >> temp >> oranges;
    
    long mangoes = n - (apples + oranges);
    
    return mangoes;
"
0,1.0,HumanEval_67_fruit_distribution,"

long fruit_distribution(std::string s, long n) {
    std::stringstream ss(s);
    long apples, oranges;
    std::string temp;

    ss >> temp >> apples >> temp >> oranges;

    long mangoes = n - (apples + oranges);

    assert(mangoes >= 0);

    return mangoes;"
1,1.0,HumanEval_67_fruit_distribution,"

long fruit_distribution(std::string s, long n) {
    std::istringstream iss(s);
    long apples, oranges;
    std::string word;
    iss >> apples >> word >> word >> oranges;

    assert(apples >= 0 && oranges >= 0 && n >= 0);

    return n - apples - oranges;
"
0,1.0,HumanEval_67_fruit_distribution,"

long fruit_distribution(std::string s, long n) {
    std::istringstream ss(s);
    std::string word;
    long apple = 0, orange = 0;
    while (ss >> word) {
        if (word == ""apples"") {
            ss >> apple;
        } else if (word == ""oranges"") {
            ss >> orange;
        }
    }
    long mango = n - (apple + orange);
    assert(mango >= 0);
    return mango;"
1,1.0,HumanEval_67_fruit_distribution,"
long fruit_distribution(std::string s, long n) {
    std::stringstream ss(s);
    long apples, oranges;
    std::string temp;
    std::vector<std::string> tokens;

    while (std::getline(ss, temp, ' ')) {
        tokens.push_back(temp);
    }

    apples = std::stoi(tokens[0]);
    oranges = std::stoi(tokens[3]);

    long mangoes = n - (apples + oranges);

    return mangoes;"
1,0.0,HumanEval_67_fruit_distribution,"

long fruit_distribution(std::string s, long n) {
    std::istringstream ss(s);
    std::string token;
    std::vector<int> fruits;
    while(std::getline(ss, token, ' ')) {
        if(std::isdigit(token[0])) {
            fruits.push_back(std::stoi(token));
        }
    }
    assert(fruits.size() == 2);
    long mangoes = n - fruits[0] - fruits[1];
    assert(mangoes >= 0);
    return mangoes;
"
1,1.0,HumanEval_112_reverse_delete,"

std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
    for (char ch : c) {
        s.erase(std::remove(s.begin(), s.end(), ch), s.end());
    }

    std::string reversed_s = s;
    std::reverse(reversed_s.begin(), reversed_s.end());

    bool is_palindrome = (s == reversed_s);

    return std::make_tuple(s, is_palindrome);"
1,1.0,HumanEval_112_reverse_delete,"
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
    std::string result;
    for (char ch : s) {
        if (c.find(ch) == std::string::npos) {
            result += ch;
        }
    }
    std::string reversed_result = result;
    std::reverse(reversed_result.begin(), reversed_result.end());
    bool is_palindrome = result == reversed_result;
    return std::make_tuple(result, is_palindrome);"
1,0.0,HumanEval_112_reverse_delete,"

std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
    for (char ch : c) {
        s.erase(std::remove(s.begin(), s.end(), ch), s.end());
    }

    std::string s_reversed = s;
    std::reverse(s_reversed.begin(), s_reversed.end());

    bool is_palindrome = (s == s_reversed);

    return std::make_tuple(s, is_palindrome);
"
1,0.0,HumanEval_112_reverse_delete,"
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
    for (char ch : c) {
        s.erase(std::remove(s.begin(), s.end(), ch), s.end());
    }
    
    std::string s_reversed = s;
    std::reverse(s_reversed.begin(), s_reversed.end());
    
    bool is_palindrome = (s == s_reversed);
    
    return std::make_tuple(s, is_palindrome);"
1,1.0,HumanEval_112_reverse_delete,"

std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
    for (char ch : c) {
        s.erase(std::remove(s.begin(), s.end(), ch), s.end());
    }

    std::string s_reversed = s;
    std::reverse(s_reversed.begin(), s_reversed.end());

    bool is_palindrome = (s == s_reversed);

    return std::make_tuple(s, is_palindrome);"
1,0.0,HumanEval_112_reverse_delete,"
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
    for (char ch : c) {
        s.erase(std::remove(s.begin(), s.end(), ch), s.end());
    }
    
    std::string s_reversed = s;
    std::reverse(s_reversed.begin(), s_reversed.end());
    
    bool is_palindrome = (s == s_reversed);
    
    return std::make_tuple(s, is_palindrome);"
1,1.0,HumanEval_112_reverse_delete,"

std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
    for (char ch : c) {
        s.erase(std::remove(s.begin(), s.end(), ch), s.end());
    }

    std::string s_rev = s;
    std::reverse(s_rev.begin(), s_rev.end());
    bool is_palindrome = s == s_rev;

    return std::make_tuple(s, is_palindrome);
"
1,0.0,HumanEval_112_reverse_delete,"
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
    for(char ch : c) {
        s.erase(std::remove(s.begin(), s.end(), ch), s.end());
    }

    std::string s_rev = s;
    std::reverse(s_rev.begin(), s_rev.end());

    bool is_palindrome = s == s_rev;

    return std::make_tuple(s, is_palindrome);"
1,1.0,HumanEval_112_reverse_delete,"
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
    for (char ch : c) {
        s.erase(std::remove(s.begin(), s.end(), ch), s.end());
    }

    std::string reversed_s = s;
    std::reverse(reversed_s.begin(), reversed_s.end());

    bool is_palindrome = s == reversed_s;

    return std::make_tuple(s, is_palindrome);"
1,1.0,HumanEval_112_reverse_delete,"

std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
    for (char ch : c) {
        s.erase(std::remove(s.begin(), s.end(), ch), s.end());
    }

    std::string s_reversed = s;
    std::reverse(s_reversed.begin(), s_reversed.end());

    bool is_palindrome = (s == s_reversed);

    return std::make_tuple(s, is_palindrome);"
1,1.0,HumanEval_13_greatest_common_divisor,"
long greatest_common_divisor(long a, long b) {
    assert(a >= 0 && b >= 0);
    while (b != 0) {
        long t = b;
        b = a % b;
        a = t;
    }
    return a;
"
1,1.0,HumanEval_13_greatest_common_divisor,"
long greatest_common_divisor(long a, long b) {
    while (b != 0) {
        long temp = b;
        b = a % b;
        a = temp;
    }
    return a;"
1,1.0,HumanEval_13_greatest_common_divisor,"
long greatest_common_divisor(long a, long b) {
    // Check if a or b is 0
    if (a == 0)
        return b;
    if (b == 0)
        return a;

    // If a and b are not 0, use Euclidean algorithm to find gcd
    while (a != b) {
        if (a > b)
            a = a - b;
        else
            b = b - a;
    }

    return a;"
1,1.0,HumanEval_13_greatest_common_divisor,"
long greatest_common_divisor(long a, long b) {
    while(b != 0) {
        long temp = b;
        b = a % b;
        a = temp;
    }
    return a;
"
1,1.0,HumanEval_13_greatest_common_divisor,"
long greatest_common_divisor(long a, long b) {
    while(b != 0) {
        long temp = b;
        b = a % b;
        a = temp;
    }
    return a;"
1,1.0,HumanEval_13_greatest_common_divisor,"
long greatest_common_divisor(long a, long b) {
    if (b == 0)
        return a;
    else
        return greatest_common_divisor(b, a % b);
"
1,1.0,HumanEval_13_greatest_common_divisor,"
long greatest_common_divisor(long a, long b) {
    // base case
    if (b == 0)
        return a;
    return greatest_common_divisor(b, a % b);"
1,1.0,HumanEval_13_greatest_common_divisor,"
long greatest_common_divisor(long a, long b) {
    // Euclidean algorithm for gcd
    while (b != 0) {
        long temp = b;
        b = a % b;
        a = temp;
    }
    return a;"
1,1.0,HumanEval_13_greatest_common_divisor,"
long greatest_common_divisor(long a, long b) {
    // Base case
    if (b == 0)
        return a;
    return greatest_common_divisor(b, a % b);
"
1,1.0,HumanEval_13_greatest_common_divisor,"
long greatest_common_divisor(long a, long b) {
    while(b != 0) {
        long temp = b;
        b = a % b;
        a = temp;
    }
    return a;"
0,1.0,HumanEval_125_split_words,"

Union_std_vector_std_string__long split_words(std::string txt) {
    std::vector<std::string> result;
    std::string word;
    for (auto x : txt) {
        if (x == ' ' || x == ',') {
            if (!word.empty()) {
                result.push_back(word);
                word = """";
            }
        } else {
            word += x;
        }
    }
    if (!word.empty()) {
        result.push_back(word);
    }
    
    if (result.size() > 1) {
        return Union_std_vector_std_string__long(result);
    } else {
        int count = 0;
        for (char c : result[0]) {
            if (islower(c) && ((c - 'a') % 2) == 1) {
                count++;
            }
        }
        return Union_std_vector_std_string__long(count);
    }"
0,0.0,HumanEval_125_split_words,"
Union_std_vector_std_string__long split_words(std::string txt) {
    std::vector<std::string> words;
    std::string word;
    for (auto x : txt) {
        if (x == ' ' || x == ',') {
            if (!word.empty()) {
                words.push_back(word);
                word = """";
            }
        } else {
            word += x;
        }
    }
    if (!word.empty()) {
        words.push_back(word);
    }
    if (words.empty()) {
        int count = 0;
        for (char c : txt) {
            if (std::islower(c) && (c - 'a') % 2 == 1) {
                count++;
            }
        }
        return Union_std_vector_std_string__long(count);
    }
    return Union_std_vector_std_string__long(words);
"
1,1.0,HumanEval_125_split_words,"
Union_std_vector_std_string__long split_words(std::string txt) {
    if(txt.find(' ') != std::string::npos) {
        std::vector<std::string> result;
        std::stringstream ss(txt);
        std::string word;
        while(std::getline(ss, word, ' ')) {
            result.push_back(word);
        }
        return Union_std_vector_std_string__long(result);
    } else if(txt.find(',') != std::string::npos) {
        std::vector<std::string> result;
        std::stringstream ss(txt);
        std::string word;
        while(std::getline(ss, word, ',')) {
            result.push_back(word);
        }
        return Union_std_vector_std_string__long(result);
    } else {
        int count = 0;
        for(char c : txt) {
            if(islower(c) && (c - 'a') % 2 == 1) {
                count++;
            }
        }
        return Union_std_vector_std_string__long(count);
    }"
0,0.0,HumanEval_125_split_words,"
Union_std_vector_std_string__long split_words(std::string txt) {
    std::vector<std::string> words;
    std::string word = """";
    for (auto x : txt) {
        if (x == ' ' || x == ',') {
            if (word != """") {
                words.push_back(word);
                word = """";
            }
        } else {
            word += x;
        }
    }
    if (word != """") {
        words.push_back(word);
    }

    if (words.size() > 1) {
        return Union_std_vector_std_string__long(words);
    } else {
        int count = 0;
        for (auto c : words[0]) {
            if (islower(c) && (c - 'a') % 2 == 1) {
                count++;
            }
        }
        return Union_std_vector_std_string__long(count);
    }"
0,0.0,HumanEval_125_split_words,"
Union_std_vector_std_string__long split_words(std::string txt) {
    std::vector<std::string> words;
    std::string word;
    for (auto x : txt) {
        if (x == ' ' || x == ',') {
            if (!word.empty()) {
                words.push_back(word);
                word = """";
            }
        } else {
            word += x;
        }
    }
    if (!word.empty()) {
        words.push_back(word);
    }

    if (words.empty()) {
        int count = 0;
        for (char c : txt) {
            if (islower(c) && (c - 'a') % 2 == 1) {
                count++;
            }
        }
        return Union_std_vector_std_string__long(count);
    } else {
        return Union_std_vector_std_string__long(words);
    }"
0,1.0,HumanEval_125_split_words,"
Union_std_vector_std_string__long split_words(std::string txt) {
    std::vector<std::string> words;
    std::string word;
    for (auto x : txt) {
        if (x == ' ' || x == ',') {
            if (!word.empty()) {
                words.push_back(word);
                word = """";
            }
        } else {
            word += x;
        }
    }
    if (!word.empty()) {
        words.push_back(word);
    }
    if (words.size() > 1) {
        return Union_std_vector_std_string__long(words);
    } else {
        int count = 0;
        for (char c : words[0]) {
            if (islower(c) && (c - 'a') % 2 == 1) {
                count++;
            }
        }
        return Union_std_vector_std_string__long(count);
    }"
1,0.0,HumanEval_125_split_words,"
Union_std_vector_std_string__long split_words(std::string txt) {
    // Check if the string contains whitespace
    if (txt.find(' ') != std::string::npos) {
        std::vector<std::string> words;
        std::stringstream ss(txt);
        std::string word;
        while (std::getline(ss, word, ' ')) {
            words.push_back(word);
        }
        return Union_std_vector_std_string__long(words);
    }
    // Check if the string contains comma
    else if (txt.find(',') != std::string::npos) {
        std::vector<std::string> words;
        std::stringstream ss(txt);
        std::string word;
        while (std::getline(ss, word, ',')) {
            words.push_back(word);
        }
        return Union_std_vector_std_string__long(words);
    }
    // If no whitespace or comma is found, count the number of lower-case letters with odd order in the alphabet
    else {
        int count = 0;
        for (char c : txt) {
            if (std::islower(c) && (c - 'a') % 2 == 1) {
                count++;
            }
        }
        return Union_std_vector_std_string__long(count);
    }
"
1,1.0,HumanEval_125_split_words,"
Union_std_vector_std_string__long split_words(std::string txt) {
    std::vector<std::string> words;
    if(txt.find(' ') != std::string::npos) {
        std::string word;
        for(auto x : txt) {
            if(x == ' ') {
                words.push_back(word);
                word = """";
            } else {
                word += x;
            }
        }
        words.push_back(word);
        return Union_std_vector_std_string__long(words);
    } else if(txt.find(',') != std::string::npos) {
        std::string word;
        for(auto x : txt) {
            if(x == ',') {
                words.push_back(word);
                word = """";
            } else {
                word += x;
            }
        }
        words.push_back(word);
        return Union_std_vector_std_string__long(words);
    } else {
        int count = 0;
        for(auto x : txt) {
            if(islower(x) && (x - 'a') % 2 == 1) {
                count++;
            }
        }
        return Union_std_vector_std_string__long(count);
    }
"
0,0.0,HumanEval_125_split_words,"
Union_std_vector_std_string__long split_words(std::string txt) {
    std::vector<std::string> words;
    std::stringstream ss(txt);
    std::string word;

    if(txt.find(' ') != std::string::npos) {
        while(ss >> word) {
            words.push_back(word);
        }
        return Union_std_vector_std_string__long(words);
    } else if(txt.find(',') != std::string::npos) {
        while(ss >> word) {
            words.push_back(word);
        }
        return Union_std_vector_std_string__long(words);
    } else {
        int count = 0;
        for(char c : txt) {
            if(islower(c) && ((c - 'a') % 2 != 0)) {
                count++;
            }
        }
        return Union_std_vector_std_string__long(count);
    }"
1,1.0,HumanEval_125_split_words,"
Union_std_vector_std_string__long split_words(std::string txt) {
    if (txt.find(' ') != std::string::npos) {
        std::vector<std::string> words;
        std::string word;
        for (char c : txt) {
            if (c == ' ') {
                words.push_back(word);
                word.clear();
            } else {
                word += c;
            }
        }
        words.push_back(word);
        return Union_std_vector_std_string__long(words);
    } else if (txt.find(',') != std::string::npos) {
        std::vector<std::string> words;
        std::string word;
        for (char c : txt) {
            if (c == ',') {
                words.push_back(word);
                word.clear();
            } else {
                word += c;
            }
        }
        words.push_back(word);
        return Union_std_vector_std_string__long(words);
    } else {
        int count = 0;
        for (char c : txt) {
            if (islower(c) && (c - 'a') % 2 == 1) {
                count++;
            }
        }
        return Union_std_vector_std_string__long(count);
    }
"
0,0.0,HumanEval_116_sort_array,"
std::vector<long> sort_array(std::vector<long> arr) {
    // Sort the vector based on the number of ones in the binary representation
    // If the number of ones are the same, then sort based on the decimal value
    std::sort(arr.begin(), arr.end(), [](long a, long b) {
        int countA = countOnes(a);
        int countB = countOnes(b);
        return countA < countB || (countA == countB && a < b);
    });

    return arr;"
0,0.0,HumanEval_116_sort_array,"
std::vector<long> sort_array(std::vector<long> arr) {
    // Using stable_sort to maintain the relative order of equal elements
    std::stable_sort(arr.begin(), arr.end(), [](long a, long b) {
        int countA = countOnes(a);
        int countB = countOnes(b);
        // If the number of ones are equal, sort based on the decimal value
        if (countA == countB) return a < b;
        return countA < countB;
    });
    return arr;
"
0,0.0,HumanEval_116_sort_array,"

std::vector<long> sort_array(std::vector<long> arr) {
    // Create a lambda function to count the number of ones in the binary representation of a number
    auto countOnes = [](long n) {
        int count = 0;
        while (n) {
            count += n & 1;
            n >>= 1;
        }
        return count;
    };

    // Sort the array based on the count of ones in the binary representation of the numbers
    std::stable_sort(arr.begin(), arr.end(), [&](long a, long b) {
        int countA = countOnes(a);
        int countB = countOnes(b);
        return countA < countB || (countA == countB && a < b);
    });

    return arr;
"
0,1.0,HumanEval_116_sort_array,"

std::vector<long> sort_array(std::vector<long> arr) {
    // Use the std::sort function with the custom compare function
    std::sort(arr.begin(), arr.end(), compare);
    return arr;
"
0,0.0,HumanEval_116_sort_array,"

std::vector<long> sort_array(std::vector<long> arr) {
    // Create a lambda function to calculate the number of ones in the binary representation
    auto countOnes = [](long n) {
        int count = 0;
        while (n) {
            count += n % 2;
            n /= 2;
        }
        return count;
    };

    // Sort the array using the lambda function as a comparison function
    std::sort(arr.begin(), arr.end(), [&](long a, long b) {
        int countA = countOnes(a);
        int countB = countOnes(b);
        // If the counts are equal, sort based on decimal value
        if (countA == countB) {
            return a < b;
        }
        // Otherwise, sort based on count of ones
        return countA < countB;
    });

    return arr;"
0,0.0,HumanEval_116_sort_array,"
    // Your code here
    std::sort(arr.begin(), arr.end(), [](long a, long b) {
        int bits_a = __builtin_popcount(abs(a));
        int bits_b = __builtin_popcount(abs(b));
        if (bits_a == bits_b) {
            return a < b;
        }
        return bits_a < bits_b;
    });
    return arr;"
0,0.0,HumanEval_116_sort_array,"

std::vector<long> sort_array(std::vector<long> arr) {
    // Sort the array based on the number of ones in the binary representation of the number
    // If the number of ones are same, sort based on the decimal value of the number
    std::sort(arr.begin(), arr.end(), [](long a, long b) {
        int countA = countOnes(a);
        int countB = countOnes(b);
        return countA < countB || (countA == countB && a < b);
    });
    return arr;"
0,0.0,HumanEval_116_sort_array,"

std::vector<long> sort_array(std::vector<long> arr) {
    std::sort(arr.begin(), arr.end(), [](long a, long b) {
        int bit_count_a = __builtin_popcount(a);
        int bit_count_b = __builtin_popcount(b);
        return bit_count_a < bit_count_b || (bit_count_a == bit_count_b && a < b);
    });
    return arr;"
0,0.0,HumanEval_116_sort_array,"

std::vector<long> sort_array(std::vector<long> arr) {
    std::stable_sort(arr.begin(), arr.end(), [](long a, long b) {
        int countA = countOnes(a);
        int countB = countOnes(b);
        if (countA == countB) {
            return a < b;
        }
        return countA < countB;
    });
    return arr;"
0,0.0,HumanEval_116_sort_array,"
std::vector<long> sort_array(std::vector<long> arr) {
    // A lambda function to count the number of ones in the binary representation of a number
    auto count_ones = [](long num) {
        int count = 0;
        while (num) {
            count += num & 1;
            num >>= 1;
        }
        return count;
    };

    // Sort the array based on the number of ones in the binary representation and the decimal value
    std::stable_sort(arr.begin(), arr.end(), [&](long a, long b) {
        int ones_a = count_ones(a);
        int ones_b = count_ones(b);
        return ones_a < ones_b || (ones_a == ones_b && a < b);
    });

    return arr;"
1,1.0,HumanEval_28_concatenate,"

std::string concatenate(std::vector<std::string> strings) {
    std::string result = """";
    for(auto& str : strings) {
        result += str;
    }
    return result;
"
0,0.0,HumanEval_28_concatenate,"
    std::string result = """";
    for(auto &str : strings) {
        result += str;
    }
    return result;"
0,0.0,HumanEval_28_concatenate,"
    std::string result;
    for(const auto& str : strings) {
        result += str;
    }
    return result;"
0,0.0,HumanEval_28_concatenate,"
    std::string result = """";
    for (const auto& s : strings) {
        result += s;
    }
    return result;
"
1,1.0,HumanEval_28_concatenate,"
std::string concatenate(std::vector<std::string> strings) {
    std::string result = """";
    for(auto &str : strings) {
        result += str;
    }
    return result;"
1,1.0,HumanEval_28_concatenate,"
std::string concatenate(std::vector<std::string> strings) {
    std::string result = """";
    for(auto &str : strings) {
        result += str;
    }
    return result;"
1,1.0,HumanEval_28_concatenate,"
std::string concatenate(std::vector<std::string> strings) {
    std::string result;
    for(const auto& str : strings) {
        result += str;
    }
    return result;"
0,0.0,HumanEval_28_concatenate,"
    std::string result = """";
    for(const auto& str : strings) {
        result += str;
    }
    return result;
"
0,0.0,HumanEval_28_concatenate,"
    std::string result;
    for(const auto& str : strings) {
        result += str;
    }
    return result;"
1,1.0,HumanEval_28_concatenate,"

std::string concatenate(std::vector<std::string> strings) {
    std::string result;
    for(const auto& s : strings) {
        result += s;
    }
    return result;
"
1,0.0,HumanEval_149_sorted_list_sum,"
std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
    // Delete the strings that have odd lengths
    lst.erase(std::remove_if(lst.begin(), lst.end(), [](const std::string& str) { return str.size() % 2 != 0; }), lst.end());

    // Sort the vector by length of each word
    std::sort(lst.begin(), lst.end(), [](const std::string& a, const std::string& b) {
        if (a.size() == b.size()) {
            return a < b;
        }
        return a.size() < b.size();
    });

    return lst;
"
1,0.0,HumanEval_149_sorted_list_sum,"
std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
    // Delete the strings that have odd lengths
    lst.erase(std::remove_if(lst.begin(), lst.end(), [](const std::string& s) { return s.size() % 2 != 0; }), lst.end());

    // Sort the vector by length of each word
    std::sort(lst.begin(), lst.end(), [](const std::string& a, const std::string& b) {
        if (a.size() == b.size()) {
            // If two words have the same length, sort the vector alphabetically
            return a < b;
        }
        return a.size() < b.size();
    });

    return lst;"
0,0.0,HumanEval_149_sorted_list_sum,"
    std::vector<std::string> result;
    for (auto &s : lst) {
        if (s.length() % 2 == 0) {
            result.push_back(s);
        }
    }
    std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {
        if (a.length() == b.length()) {
            return a < b;
        }
        return a.length() < b.length();
    });
    return result;
"
0,1.0,HumanEval_149_sorted_list_sum,"
std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
    // Remove strings with odd lengths
    lst.erase(std::remove_if(lst.begin(), lst.end(), [](const std::string& s) { return s.size() % 2 != 0; }), lst.end());

    // Sort the vector by length of the string and then alphabetically
    std::sort(lst.begin(), lst.end(), [](const std::string& a, const std::string& b) {
        if (a.size() == b.size()) {
            return a < b;
        }
        return a.size() < b.size();
    });

    return lst;
"
0,1.0,HumanEval_149_sorted_list_sum,"
std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
    // Delete the strings that have odd lengths
    lst.erase(std::remove_if(lst.begin(), lst.end(), [](const std::string& s) { return s.size() % 2 != 0; }), lst.end());

    // Sort the vector by length of each word
    std::sort(lst.begin(), lst.end(), [](const std::string& a, const std::string& b) {
        if (a.size() != b.size())
            return a.size() < b.size();
        return a < b;
    });

    return lst;"
1,0.0,HumanEval_149_sorted_list_sum,"
    std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
        std::vector<std::string> result;

        // Remove strings with odd lengths
        for (std::string s : lst) {
            if (s.length() % 2 == 0) {
                result.push_back(s);
            }
        }

        // Sort the vector by length and alphabetically
        std::sort(result.begin(), result.end(), [](const std::string &s1, const std::string &s2) {
            if (s1.size() == s2.size()) {
                return s1 < s2;
            }
            return s1.size() < s2.size();
        });

        return result;
"
1,1.0,HumanEval_149_sorted_list_sum,"
std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
    // Remove strings with odd lengths
    lst.erase(std::remove_if(lst.begin(), lst.end(), [](const std::string& s) { return s.size() % 2 != 0; }), lst.end());

    // Sort the vector by length of each word
    std::sort(lst.begin(), lst.end(), [](const std::string& a, const std::string& b) {
        if (a.size() != b.size()) {
            return a.size() < b.size();
        }
        return a < b;
    });

    return lst;"
1,1.0,HumanEval_149_sorted_list_sum,"
std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
    std::vector<std::string> result;

    // Filter out strings with odd lengths
    for (std::string s : lst) {
        if (s.length() % 2 == 0) {
            result.push_back(s);
        }
    }

    // Sort the vector by length of each word
    std::sort(result.begin(), result.end(), [](const std::string &s1, const std::string &s2) {
        if (s1.size() == s2.size()) {
            return s1 < s2;
        }
        return s1.size() < s2.size();
    });

    return result;"
1,1.0,HumanEval_149_sorted_list_sum,"

std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
    // Remove strings with odd length
    lst.erase(std::remove_if(lst.begin(), lst.end(), [](const std::string& str) { return str.size() % 2 != 0; }), lst.end());

    // Sort the vector by length and then by lexicographical order
    std::sort(lst.begin(), lst.end(), [](const std::string& a, const std::string& b) {
        if (a.size() != b.size()) {
            return a.size() < b.size();
        }
        return a < b;
    });

    return lst;"
0,1.0,HumanEval_149_sorted_list_sum,"
std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
    std::vector<std::string> result;
    for(auto &str: lst) {
        if(str.size() % 2 == 0) {
            result.push_back(str);
        }
    }
    std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {
        if(a.size() == b.size()) {
            return a < b;
        }
        return a.size() < b.size();
    });
    return result;
"
0,1.0,HumanEval_7_filter_by_substring,"

std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.find(substring) != std::string::npos) {
            result.push_back(str);
        }
    }
    return result;
"
1,1.0,HumanEval_7_filter_by_substring,"

std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.find(substring) != std::string::npos) {
            result.push_back(str);
        }
    }
    return result;"
0,0.0,HumanEval_7_filter_by_substring,"
    std::vector<std::string> result;
    for (auto& str : strings) {
        if (str.find(substring) != std::string::npos) {
            result.push_back(str);
        }
    }
    return result;"
0,0.0,HumanEval_7_filter_by_substring,"
    // Create a new vector to store the filtered strings
    std::vector<std::string> filtered_strings;

    // Iterate over each string in the input vector
    for(auto str : strings) {
        // If the current string contains the given substring, add it to the filtered strings vector
        if(str.find(substring) != std::string::npos) {
            filtered_strings.push_back(str);
        }
    }

    // Return the filtered strings vector
    return filtered_strings;"
0,1.0,HumanEval_7_filter_by_substring,"

std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
    std::vector<std::string> result;
    for(const std::string& s : strings) {
        if(s.find(substring) != std::string::npos) {
            result.push_back(s);
        }
    }
    return result;"
0,1.0,HumanEval_7_filter_by_substring,"

std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
    std::vector<std::string> result;
    for(const auto& str : strings) {
        if(str.find(substring) != std::string::npos) {
            result.push_back(str);
        }
    }
    return result;"
1,1.0,HumanEval_7_filter_by_substring,"

std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.find(substring) != std::string::npos) {
            result.push_back(str);
        }
    }
    return result;
"
1,1.0,HumanEval_7_filter_by_substring,"
std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.find(substring) != std::string::npos) {
            result.push_back(str);
        }
    }
    return result;"
1,1.0,HumanEval_7_filter_by_substring,"

std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
    std::vector<std::string> filtered_strings;
    for (const auto& str : strings) {
        if (str.find(substring) != std::string::npos) {
            filtered_strings.push_back(str);
        }
    }
    return filtered_strings;"
1,1.0,HumanEval_7_filter_by_substring,"

std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.find(substring) != std::string::npos) {
            result.push_back(str);
        }
    }
    return result;"
0,0.0,HumanEval_99_closest_integer,"
long closest_integer(std::string value) {
    double num = std::stod(value);
    long rounded_num = std::round(num);
    if (num - rounded_num < 0.5) {
        if (rounded_num > 0) {
            return rounded_num;
        } else {
            return rounded_num - 1;
        }
    } else {
        if (rounded_num > 0) {
            return rounded_num + 1;
        } else {
            return rounded_num;
        }
    }
"
0,0.0,HumanEval_99_closest_integer,"
    // Convert the string to a double
    double num = std::stod(value);

    // Use the std::round function to get the closest integer
    long rounded = std::lround(num);

    // If the rounded number is equidistant from the original number
    // and the original number is positive, return the rounded number + 1
    if (rounded == num && num > 0) {
        return rounded + 1;
    }
    // If the rounded number is equidistant from the original number
    // and the original number is negative, return the rounded number - 1
    else if (rounded == num && num < 0) {
        return rounded - 1;
    }
    // If the rounded number is not equidistant from the original number, return the rounded number
    else {
        return rounded;
    }"
0,0.0,HumanEval_99_closest_integer,"
long closest_integer(std::string value) {
    double num = std::stod(value);
    long roundedNum = std::lround(num);
    if ((num - roundedNum) < 0.5) {
        if (roundedNum > 0) {
            return roundedNum;
        } else {
            return roundedNum - 1;
        }
    } else {
        if (roundedNum > 0) {
            return roundedNum + 1;
        } else {
            return roundedNum;
        }
    }"
0,0.0,HumanEval_99_closest_integer,"
long closest_integer(std::string value) {
    double num = std::stod(value);
    long long_num = std::stol(value);
    
    if (num - long_num < 0.5) {
        return long_num;
    } else {
        return num < 0 ? long_num - 1 : long_num + 1;
    }
"
0,0.0,HumanEval_99_closest_integer,"
long closest_integer(std::string value) {
    double num = std::stod(value);
    long roundedNum = std::lround(num);

    if (num - roundedNum < 0.5 && num - roundedNum > -0.5) {
        if (roundedNum > 0) {
            return roundedNum;
        } else {
            return roundedNum - 1;
        }
    } else {
        return roundedNum;
    }"
0,0.0,HumanEval_99_closest_integer,"
long closest_integer(std::string value) {
    double num = std::stod(value);
    long roundedNum = std::lround(num);
    if ((num - roundedNum) < 0.5) {
        if (roundedNum > 0) {
            return roundedNum;
        } else {
            return roundedNum - 1;
        }
    } else {
        if (roundedNum > 0) {
            return roundedNum + 1;
        } else {
            return roundedNum;
        }
    }"
1,0.0,HumanEval_99_closest_integer,"
long closest_integer(std::string value) {
    double num = std::stod(value);
    long rounded = std::lround(num);
    if (num - rounded >= 0.5 && num > 0) {
        return rounded + 1;
    } else if (rounded - num >= 0.5 && num < 0) {
        return rounded - 1;
    } else {
        return rounded;
    }
"
0,0.0,HumanEval_99_closest_integer,"
long closest_integer(std::string value) {
    double num = std::stod(value);
    long rounded_num = static_cast<long>(num);
    if (num - rounded_num >= 0.5) {
        if (num >= 0) {
            return rounded_num + 1;
        } else {
            return rounded_num - 1;
        }
    } else {
        return rounded_num;
    }
"
1,1.0,HumanEval_99_closest_integer,"
long closest_integer(std::string value) {
    double num = std::stod(value);
    long long_num = static_cast<long>(num);
    if (num > 0) {
        if (num - long_num < 0.5) {
            return long_num;
        } else {
            return long_num + 1;
        }
    } else {
        if (long_num - num < 0.5) {
            return long_num;
        } else {
            return long_num - 1;
        }
    }"
0,0.0,HumanEval_99_closest_integer,"
    // Your code goes here
    double num = std::stod(value);
    return (num > 0) ? static_cast<long>(num + 0.5) : static_cast<long>(num - 0.5);
"
0,0.0,HumanEval_64_vowels_count,"
    long count = 0;
    for(int i = 0; i < s.size(); i++) {
        if(i == s.size()-1 && (s[i] == 'y' || s[i] == 'Y')) {
            count++;
        } else if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' ||
                  s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {
            count++;
        }
    }
    return count;
"
0,0.0,HumanEval_64_vowels_count,"
    long count = 0;
    for (int i = 0; i < s.length(); i++) {
        char c = tolower(s[i]);
        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {
            count++;
        }
    }
    if (tolower(s[s.length() - 1]) == 'y') {
        count++;
    }
    return count;
"
1,0.0,HumanEval_64_vowels_count,"
long vowels_count(std::string s) {
    long count = 0;
    std::string vowels = ""aeiou"";

    // Convert the string to lowercase
    std::transform(s.begin(), s.end(), s.begin(), ::tolower);

    // Count the number of vowels
    for(char& c : s) {
        if(vowels.find(c) != std::string::npos) {
            count++;
        }
    }

    // If the last character is 'y', count it as a vowel
    if(s[s.length() - 1] == 'y') {
        count++;
    }

    return count;
"
0,0.0,HumanEval_64_vowels_count,"
    long vowel_count = 0;
    std::string vowels = ""aeiou"";
    std::transform(s.begin(), s.end(), s.begin(), ::tolower);
    for(int i = 0; i < s.size(); i++) {
        if(vowels.find(s[i]) != std::string::npos) {
            vowel_count++;
        }
    }
    if(s[s.size() - 1] == 'y') {
        vowel_count++;
    }
    return vowel_count;"
0,0.0,HumanEval_64_vowels_count,"
    long vowels = 0;
    std::string vowelString = ""aeiou"";
    for (int i = 0; i < s.size(); i++) {
        if (vowelString.find(tolower(s[i])) != std::string::npos) {
            vowels++;
        }
    }
    if (tolower(s[s.size() - 1]) == 'y') {
        vowels++;
    }
    return vowels;
"
0,0.0,HumanEval_64_vowels_count,"
    long vowels = 0;
    for(int i = 0; i < s.size(); i++) {
        char c = tolower(s[i]);
        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {
            vowels++;
        }
    }
    if(tolower(s[s.size()-1]) == 'y') {
        vowels++;
    }
    return vowels;
"
0,0.0,HumanEval_64_vowels_count,"
    long vowel_count = 0;
    std::string vowels = ""aeiou"";
    for(int i = 0; i < s.size(); i++) {
        if(i == s.size()-1 && (s[i] == 'y' || s[i] == 'Y')) {
            vowel_count++;
        }
        if(vowels.find(s[i]) != std::string::npos) {
            vowel_count++;
        }
    }
    return vowel_count;"
0,0.0,HumanEval_64_vowels_count,"
    long vowels = 0;
    std::string vowels_str = ""aeiou"";
    for(int i=0; i<s.size(); i++){
        if(i == s.size()-1 && (s[i] == 'y' || s[i] == 'Y')){
            vowels++;
        }
        if(vowels_str.find(tolower(s[i])) != std::string::npos){
            vowels++;
        }
    }
    return vowels;"
0,0.0,HumanEval_64_vowels_count,"
    long count = 0;
    for(int i=0; i<s.length(); i++) {
        char c = tolower(s[i]);
        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {
            count++;
        }
    }
    if(tolower(s[s.length()-1]) == 'y') {
        count++;
    }
    return count;
"
0,0.0,HumanEval_64_vowels_count,"
    long vowels = 0;
    for (long i = 0; i < s.size(); i++) {
        char c = tolower(s[i]);
        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {
            vowels++;
        }
    }
    if (tolower(s[s.size() - 1]) == 'y') {
        vowels++;
    }
    return vowels;"
0,0.0,HumanEval_158_find_max,"
    std::string max_word = """";
    int max_unique = 0;

    for (auto word : words) {
        std::set<char> unique_chars(word.begin(), word.end());
        if (unique_chars.size() > max_unique) {
            max_unique = unique_chars.size();
            max_word = word;
        } else if (unique_chars.size() == max_unique) {
            max_word = max_word < word ? max_word : word;
        }
    }

    return max_word;"
1,1.0,HumanEval_158_find_max,"
std::string find_max(std::vector<std::string> words) {
    std::string max_word = """";
    int max_unique = 0;

    for(auto word : words) {
        std::set<char> unique_chars(word.begin(), word.end());
        if(unique_chars.size() > max_unique ||
           (unique_chars.size() == max_unique && word < max_word)) {
            max_word = word;
            max_unique = unique_chars.size();
        }
    }

    return max_word;
"
0,0.0,HumanEval_158_find_max,"
    std::string max_word = """";
    int max_unique = 0;

    for(const std::string& word : words) {
        std::set<char> unique_chars(word.begin(), word.end());
        if(unique_chars.size() > max_unique) {
            max_unique = unique_chars.size();
            max_word = word;
        } else if(unique_chars.size() == max_unique) {
            max_word = max_word < word ? max_word : word;
        }
    }

    return max_word;"
1,1.0,HumanEval_158_find_max,"

std::string find_max(std::vector<std::string> words) {
    std::string max_word = """";
    int max_unique = 0;

    for(auto word : words) {
        std::set<char> unique_chars(word.begin(), word.end());
        if(unique_chars.size() > max_unique) {
            max_unique = unique_chars.size();
            max_word = word;
        }
        else if(unique_chars.size() == max_unique) {
            max_word = max_word < word ? max_word : word;
        }
    }

    return max_word;
"
0,1.0,HumanEval_158_find_max,"
std::string find_max(std::vector<std::string> words) {
    int max_unique_chars = 0;
    std::string max_word = """";

    for (const std::string& word : words) {
        std::set<char> unique_chars(word.begin(), word.end());
        if (unique_chars.size() > max_unique_chars) {
            max_unique_chars = unique_chars.size();
            max_word = word;
        } else if (unique_chars.size() == max_unique_chars) {
            max_word = std::min(max_word, word);
        }
    }

    return max_word;
"
0,1.0,HumanEval_158_find_max,"

std::string find_max(std::vector<std::string> words) {
    std::string max_word = """";
    int max_unique = 0;

    for(auto word : words) {
        std::set<char> unique_chars(word.begin(), word.end());
        if(unique_chars.size() > max_unique) {
            max_unique = unique_chars.size();
            max_word = word;
        }
        else if(unique_chars.size() == max_unique) {
            max_word = max_word < word ? max_word : word;
        }
    }

    return max_word;
"
0,1.0,HumanEval_158_find_max,"

std::string find_max(std::vector<std::string> words) {
    std::string max_word = """";
    int max_unique = 0;

    for (std::string word : words) {
        std::set<char> unique_chars(word.begin(), word.end());
        if (unique_chars.size() > max_unique) {
            max_unique = unique_chars.size();
            max_word = word;
        } else if (unique_chars.size() == max_unique) {
            max_word = max_word < word ? max_word : word;
        }
    }

    return max_word;
"
0,0.0,HumanEval_158_find_max,"
    assert(words.size() > 0);

    std::string max_word = """";
    int max_unique = 0;

    for (const auto& word : words) {
        std::set<char> unique_chars(word.begin(), word.end());
        if (unique_chars.size() > max_unique ||
            (unique_chars.size() == max_unique && word < max_word)) {
            max_unique = unique_chars.size();
            max_word = word;
        }
    }

    return max_word;"
1,1.0,HumanEval_158_find_max,"
std::string find_max(std::vector<std::string> words) {
    std::string max_word = """";
    int max_unique_chars = 0;

    for (const std::string &word : words) {
        std::set<char> unique_chars(word.begin(), word.end());
        if (unique_chars.size() > max_unique_chars) {
            max_unique_chars = unique_chars.size();
            max_word = word;
        } else if (unique_chars.size() == max_unique_chars) {
            max_word = std::min(max_word, word);
        }
    }

    return max_word;
"
1,1.0,HumanEval_158_find_max,"

std::string find_max(std::vector<std::string> words) {
    std::string max_word = """";
    int max_unique = 0;

    for(auto word : words) {
        std::set<char> unique_chars(word.begin(), word.end());
        if(unique_chars.size() > max_unique) {
            max_unique = unique_chars.size();
            max_word = word;
        }
        else if(unique_chars.size() == max_unique) {
            max_word = max_word < word ? max_word : word;
        }
    }

    return max_word;"
0,0.0,HumanEval_162_string_to_md5,"

std::optional<std::string> string_to_md5(std::string text) {
    if(text.empty()) {
        return {};
    }

    unsigned char result[MD5_DIGEST_LENGTH];
    MD5((unsigned char*)text.c_str(), text.length(), result);

    std::stringstream s;
    s << std::hex << std::setfill('0');
    for(unsigned char c : result) {
        s << std::setw(2);
        s << (unsigned int)c;
    }

    return s.str();
"
0,0.0,HumanEval_162_string_to_md5,"

std::optional<std::string> string_to_md5(std::string text) {
    if (text.empty()) {
        return {};
    }

    boost::uuids::detail::md5 hash;
    hash.process_bytes(text.data(), text.size());

    unsigned int digest[4];
    hash.get_digest(digest);

    std::string result;
    boost::algorithm::hex(digest, digest + 4, std::back_inserter(result));

    return {result};
"
0,0.0,HumanEval_162_string_to_md5,"

std::optional<std::string> string_to_md5(std::string text) {
    if(text.empty()) {
        return std::nullopt;
    }

    unsigned char result[MD5_DIGEST_LENGTH];
    MD5((unsigned char*)text.c_str(), text.length(), result);

    std::stringstream ss;
    for(int i = 0; i < MD5_DIGEST_LENGTH; ++i) {
        ss << std::hex << std::setw(2) << std::setfill('0') << (unsigned int)result[i];
    }

    return ss.str();
"
0,0.0,HumanEval_162_string_to_md5,"

std::optional<std::string> string_to_md5(std::string text) {
    if (text.empty()) {
        return {};
    }

    unsigned char result[MD5_DIGEST_LENGTH];
    MD5((unsigned char*)text.c_str(), text.size(), result);

    std::ostringstream sout;
    sout<<std::hex<<std::setfill('0');
    for(long long c: result)
        sout<<std::setw(2)<<(long long)c;
    
    return sout.str();
"
0,0.0,HumanEval_162_string_to_md5,"

std::optional<std::string> string_to_md5(std::string text) {
    if (text.empty()) {
        return {};
    }

    boost::uuids::detail::md5 hash;
    hash.process_bytes(text.data(), text.size());

    unsigned int digest[4];
    hash.get_digest(digest);

    std::stringstream ss;
    for(int i = 0; i < 4; ++i) {
        ss << std::hex << std::setw(8) << std::setfill('0') << digest[i];
    }

    return ss.str();"
0,0.0,HumanEval_162_string_to_md5,"

std::optional<std::string> string_to_md5(std::string text) {
    if (text.empty()) {
        return {};
    }

    unsigned char result[MD5_DIGEST_LENGTH];
    MD5((unsigned char*)text.c_str(), text.length(), result);

    std::stringstream sstream;
    sstream << std::hex << std::setfill('0');
    for(auto byte: result) {
        sstream << std::setw(2) << (int)byte;
    }

    return sstream.str();"
0,0.0,HumanEval_162_string_to_md5,"

std::optional<std::string> string_to_md5(std::string text) {
    if (text.empty()) {
        return {};
    }

    unsigned char result[MD5_DIGEST_LENGTH];
    MD5((unsigned char*)text.c_str(), text.length(), result);

    char md5string[33];
    for(int i = 0; i < 16; i++)
        sprintf(&md5string[i*2], ""%02x"", result[i]);

    return std::string(md5string);
"
0,0.0,HumanEval_162_string_to_md5,"
std::optional<std::string> string_to_md5(std::string text) {
    if(text.empty()) {
        return {};
    }

    unsigned char result[MD5_DIGEST_LENGTH];
    MD5((unsigned char*)text.c_str(), text.size(), result);

    std::stringstream ss;
    for(int i = 0; i < MD5_DIGEST_LENGTH; ++i) {
        ss << std::hex << std::setw(2) << std::setfill('0') << (int)result[i];
    }

    return ss.str();"
0,0.0,HumanEval_162_string_to_md5,"

std::optional<std::string> string_to_md5(std::string text) {
    if (text.empty()) {
        return {};
    }

    unsigned char result[MD5_DIGEST_LENGTH];
    MD5((unsigned char*)text.c_str(), text.size(), result);

    std::ostringstream sout;
    sout<<std::hex<<std::setfill('0');
    for(long long c: result)
        sout<<std::setw(2)<<(long long)c;
    
    return sout.str();
"
0,0.0,HumanEval_162_string_to_md5,"

std::optional<std::string> string_to_md5(std::string text) {
    if (text.empty()) {
        return {};
    }

    unsigned char result[MD5_DIGEST_LENGTH];
    MD5((unsigned char*)text.c_str(), text.length(), result);

    std::ostringstream sout;
    sout<<std::hex<<std::setfill('0');
    for(long long c: result)
        sout<<std::setw(2)<<(long long)c;
    
    return sout.str();
"
1,1.0,HumanEval_44_change_base,"

std::string change_base(long x, long base) {
    assert(2 <= base && base <= 10);

    std::string result;
    while (x) {
        result += std::to_string(x % base);
        x /= base;
    }

    std::reverse(result.begin(), result.end());
    return result;"
1,1.0,HumanEval_44_change_base,"

std::string change_base(long x, long base) {
    assert(2 <= base && base <= 10);
    std::string result = """";
    while (x > 0) {
        result = std::to_string(x % base) + result;
        x /= base;
    }
    return result;"
1,1.0,HumanEval_44_change_base,"

std::string change_base(long x, long base) {
    assert(2 <= base && base <= 10);

    std::string result;
    while (x) {
        result.push_back('0' + x % base);
        x /= base;
    }

    std::reverse(result.begin(), result.end());
    return result;
"
1,1.0,HumanEval_44_change_base,"

std::string change_base(long x, long base) {
    assert(2 <= base && base <= 10);

    std::string result;
    while (x) {
        result += std::to_string(x % base);
        x /= base;
    }

    std::reverse(result.begin(), result.end());
    return result;
"
1,1.0,HumanEval_44_change_base,"

std::string change_base(long x, long base) {
    assert(2 <= base && base <= 10);
    std::string result;
    while (x) {
        result += std::to_string(x % base);
        x /= base;
    }
    std::reverse(result.begin(), result.end());
    return result;
"
1,1.0,HumanEval_44_change_base,"
std::string change_base(long x, long base) {
    assert(2 <= base && base <= 10);
    std::string result;
    while (x) {
        result += std::to_string(x % base);
        x /= base;
    }
    std::reverse(result.begin(), result.end());
    return result;"
1,1.0,HumanEval_44_change_base,"
std::string change_base(long x, long base) {
    std::string result;
    while (x) {
        result += std::to_string(x % base);
        x /= base;
    }
    std::reverse(result.begin(), result.end());
    return result;"
1,1.0,HumanEval_44_change_base,"

std::string change_base(long x, long base) {
    assert(2 <= base && base <= 10);
    std::string result = """";
    while (x > 0) {
        result = std::to_string(x % base) + result;
        x /= base;
    }
    return result;
"
1,1.0,HumanEval_44_change_base,"

std::string change_base(long x, long base) {
    assert(2 <= base && base <= 10);

    std::string result = """";
    while (x > 0) {
        int remainder = x % base;
        x /= base;
        result = std::to_string(remainder) + result;
    }

    return result;"
1,1.0,HumanEval_44_change_base,"

std::string change_base(long x, long base) {
    assert(2 <= base && base <= 10);
    std::string result;
    while (x) {
        result += std::to_string(x % base);
        x /= base;
    }
    std::reverse(result.begin(), result.end());
    return result;
"
1,0.0,HumanEval_157_right_angle_triangle,"
bool right_angle_triangle(long a, long b, long c) {
    // Sort the sides in ascending order
    std::vector<long> sides = {a, b, c};
    std::sort(sides.begin(), sides.end());

    // The square of the hypotenuse should be equal to the sum of the squares of the other two sides
    return (sides[0] * sides[0]) + (sides[1] * sides[1]) == (sides[2] * sides[2]);
"
1,1.0,HumanEval_157_right_angle_triangle,"

bool right_angle_triangle(long a, long b, long c) {
    // Store the sides in a vector
    std::vector<long> sides = {a, b, c};
    // Sort the sides
    std::sort(sides.begin(), sides.end());

    // Check if the square of the largest side is equal to the sum of the squares of the other two sides
    return (sides[2] * sides[2]) == (sides[0] * sides[0]) + (sides[1] * sides[1]);
"
1,1.0,HumanEval_157_right_angle_triangle,"
bool right_angle_triangle(long a, long b, long c) {
    // Sort the sides
    std::vector<long> sides = {a, b, c};
    std::sort(sides.begin(), sides.end());

    // Check if the square of the largest side is equal to the sum of the squares of the other two sides
    return (sides[2]*sides[2]) == (sides[0]*sides[0] + sides[1]*sides[1]);
"
1,1.0,HumanEval_157_right_angle_triangle,"

bool right_angle_triangle(long a, long b, long c) {
    // Store the sides in a vector
    std::vector<long> sides = {a, b, c};
    // Sort the sides
    std::sort(sides.begin(), sides.end());

    // Check if the square of the largest side is equal to the sum of the squares of the other two sides
    return (sides[2] * sides[2]) == (sides[0] * sides[0]) + (sides[1] * sides[1]);"
1,0.0,HumanEval_157_right_angle_triangle,"

bool right_angle_triangle(long a, long b, long c) {
    // Sort the sides in ascending order
    if(a > b) std::swap(a, b);
    if(b > c) std::swap(b, c);
    if(a > b) std::swap(a, b);

    // Check if the triangle is right-angled
    return a*a + b*b == c*c;"
1,1.0,HumanEval_157_right_angle_triangle,"
bool right_angle_triangle(long a, long b, long c) {
    // Create an array to store the sides of the triangle
    long sides[3] = {a, b, c};

    // Sort the array in ascending order
    std::sort(sides, sides + 3);

    // Check if the square of the largest side is equal to the sum of the squares of the other two sides
    return (sides[2] * sides[2]) == (sides[0] * sides[0]) + (sides[1] * sides[1]);"
0,0.0,HumanEval_157_right_angle_triangle,"
    // sort the sides in ascending order
    std::vector<long> sides = {a, b, c};
    std::sort(sides.begin(), sides.end());

    // check if the square of the largest side is equal to the sum of the squares of the other two sides
    return (sides[2]*sides[2]) == (sides[0]*sides[0] + sides[1]*sides[1]);
"
1,0.0,HumanEval_157_right_angle_triangle,"

bool right_angle_triangle(long a, long b, long c) {
    // Create a vector to store the sides
    std::vector<long> sides = {a, b, c};
    
    // Sort the sides
    std::sort(sides.begin(), sides.end());
    
    // Check if the square of the largest side is equal to the sum of the squares of the other two sides
    // This is a property of right-angled triangles
    return (sides[2]*sides[2]) == (sides[0]*sides[0] + sides[1]*sides[1]);"
1,1.0,HumanEval_157_right_angle_triangle,"
bool right_angle_triangle(long a, long b, long c) {
    // Sort the sides in ascending order
    std::vector<long> sides = {a, b, c};
    std::sort(sides.begin(), sides.end());

    // Check if the square of the largest side is equal to the sum of squares of the other two sides
    // This is a direct consequence of the Pythagorean theorem
    return (sides[2]*sides[2]) == (sides[0]*sides[0] + sides[1]*sides[1]);"
0,1.0,HumanEval_157_right_angle_triangle,"
bool right_angle_triangle(long a, long b, long c) {
    // Sort the sides in ascending order
    vector<long> sides = {a, b, c};
    sort(sides.begin(), sides.end());

    // Check if the square of the largest side is equal to the sum of the squares of the other two sides
    return (sides[2]*sides[2]) == (sides[0]*sides[0] + sides[1]*sides[1]);"
0,1.0,HumanEval_81_numerical_letter_grade,"
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
    std::vector<std::string> letter_grades;
    for (float grade : grades) {
        if (grade == 4.0) {
            letter_grades.push_back(""A+"");
        } else if (grade > 3.7) {
            letter_grades.push_back(""A"");
        } else if (grade > 3.3) {
            letter_grades.push_back(""A-"");
        } else if (grade > 3.0) {
            letter_grades.push_back(""B+"");
        } else if (grade > 2.7) {
            letter_grades.push_back(""B"");
        } else if (grade > 2.3) {
            letter_grades.push_back(""B-"");
        } else if (grade > 2.0) {
            letter_grades.push_back(""C+"");
        } else if (grade > 1.7) {
            letter_grades.push_back(""C"");
        } else if (grade > 1.3) {
            letter_grades.push_back(""C-"");
        } else if (grade > 1.0) {
            letter_grades.push_back(""D+"");
        } else if (grade > 0.7) {
            letter_grades.push_back(""D"");
        } else if (grade > 0.0) {
            letter_grades.push_back(""D-"");
        } else {
            letter_grades.push_back(""E"");
        }
    }
    return letter_grades;"
0,1.0,HumanEval_81_numerical_letter_grade,"
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
    std::vector<std::string> letterGrades;
    for (float grade : grades) {
        if (grade == 4.0) {
            letterGrades.push_back(""A+"");
        } else if (grade > 3.7) {
            letterGrades.push_back(""A"");
        } else if (grade > 3.3) {
            letterGrades.push_back(""A-"");
        } else if (grade > 3.0) {
            letterGrades.push_back(""B+"");
        } else if (grade > 2.7) {
            letterGrades.push_back(""B"");
        } else if (grade > 2.3) {
            letterGrades.push_back(""B-"");
        } else if (grade > 2.0) {
            letterGrades.push_back(""C+"");
        } else if (grade > 1.7) {
            letterGrades.push_back(""C"");
        } else if (grade > 1.3) {
            letterGrades.push_back(""C-"");
        } else if (grade > 1.0) {
            letterGrades.push_back(""D+"");
        } else if (grade > 0.7) {
            letterGrades.push_back(""D"");
        } else if (grade > 0.0) {
            letterGrades.push_back(""D-"");
        } else {
            letterGrades.push_back(""E"");
        }
    }
    return letterGrades;"
0,0.0,HumanEval_81_numerical_letter_grade,"
    std::vector<std::string> grades_letter;
    for(auto grade : grades) {
        if(grade == 4.0) {
            grades_letter.push_back(""A+"");
        }
        else if(grade > 3.7) {
            grades_letter.push_back(""A"");
        }
        else if(grade > 3.3) {
            grades_letter.push_back(""A-"");
        }
        else if(grade > 3.0) {
            grades_letter.push_back(""B+"");
        }
        else if(grade > 2.7) {
            grades_letter.push_back(""B"");
        }
        else if(grade > 2.3) {
            grades_letter.push_back(""B-"");
        }
        else if(grade > 2.0) {
            grades_letter.push_back(""C+"");
        }
        else if(grade > 1.7) {
            grades_letter.push_back(""C"");
        }
        else if(grade > 1.3) {
            grades_letter.push_back(""C-"");
        }
        else if(grade > 1.0) {
            grades_letter.push_back(""D+"");
        }
        else if(grade > 0.7) {
            grades_letter.push_back(""D"");
        }
        else if(grade > 0.0) {
            grades_letter.push_back(""D-"");
        }
        else {
            grades_letter.push_back(""E"");
        }
    }
    return grades_letter;
"
0,1.0,HumanEval_81_numerical_letter_grade,"
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
    std::vector<std::string> letter_grades;
    for(float grade : grades) {
        if(grade == 4.0) {
            letter_grades.push_back(""A+"");
        } else if(grade > 3.7) {
            letter_grades.push_back(""A"");
        } else if(grade > 3.3) {
            letter_grades.push_back(""A-"");
        } else if(grade > 3.0) {
            letter_grades.push_back(""B+"");
        } else if(grade > 2.7) {
            letter_grades.push_back(""B"");
        } else if(grade > 2.3) {
            letter_grades.push_back(""B-"");
        } else if(grade > 2.0) {
            letter_grades.push_back(""C+"");
        } else if(grade > 1.7) {
            letter_grades.push_back(""C"");
        } else if(grade > 1.3) {
            letter_grades.push_back(""C-"");
        } else if(grade > 1.0) {
            letter_grades.push_back(""D+"");
        } else if(grade > 0.7) {
            letter_grades.push_back(""D"");
        } else if(grade > 0.0) {
            letter_grades.push_back(""D-"");
        } else {
            letter_grades.push_back(""E"");
        }
    }
    return letter_grades;"
0,1.0,HumanEval_81_numerical_letter_grade,"
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
    std::vector<std::string> letter_grades;
    for (float grade : grades) {
        if (grade == 4.0) {
            letter_grades.push_back(""A+"");
        } else if (grade > 3.7) {
            letter_grades.push_back(""A"");
        } else if (grade > 3.3) {
            letter_grades.push_back(""A-"");
        } else if (grade > 3.0) {
            letter_grades.push_back(""B+"");
        } else if (grade > 2.7) {
            letter_grades.push_back(""B"");
        } else if (grade > 2.3) {
            letter_grades.push_back(""B-"");
        } else if (grade > 2.0) {
            letter_grades.push_back(""C+"");
        } else if (grade > 1.7) {
            letter_grades.push_back(""C"");
        } else if (grade > 1.3) {
            letter_grades.push_back(""C-"");
        } else if (grade > 1.0) {
            letter_grades.push_back(""D+"");
        } else if (grade > 0.7) {
            letter_grades.push_back(""D"");
        } else if (grade > 0.0) {
            letter_grades.push_back(""D-"");
        } else {
            letter_grades.push_back(""E"");
        }
    }
    return letter_grades;"
0,0.0,HumanEval_81_numerical_letter_grade,"
    std::vector<std::string> grade_equation(std::vector<float> grades) {
        std::vector<std::string> letter_grades;
        for (float grade : grades) {
            if (grade == 4.0) {
                letter_grades.push_back(""A+"");
            } else if (grade > 3.7) {
                letter_grades.push_back(""A"");
            } else if (grade > 3.3) {
                letter_grades.push_back(""A-"");
            } else if (grade > 3.0) {
                letter_grades.push_back(""B+"");
            } else if (grade > 2.7) {
                letter_grades.push_back(""B"");
            } else if (grade > 2.3) {
                letter_grades.push_back(""B-"");
            } else if (grade > 2.0) {
                letter_grades.push_back(""C+"");
            } else if (grade > 1.7) {
                letter_grades.push_back(""C"");
            } else if (grade > 1.3) {
                letter_grades.push_back(""C-"");
            } else if (grade > 1.0) {
                letter_grades.push_back(""D+"");
            } else if (grade > 0.7) {
                letter_grades.push_back(""D"");
            } else if (grade > 0.0) {
                letter_grades.push_back(""D-"");
            } else {
                letter_grades.push_back(""E"");
            }
        }
        return letter_grades;
    }"
0,1.0,HumanEval_81_numerical_letter_grade,"

std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
    std::vector<std::string> letter_grades;

    for(float grade : grades) {
        if(grade == 4.0) {
            letter_grades.push_back(""A+"");
        }
        else if(grade > 3.7) {
            letter_grades.push_back(""A"");
        }
        else if(grade > 3.3) {
            letter_grades.push_back(""A-"");
        }
        else if(grade > 3.0) {
            letter_grades.push_back(""B+"");
        }
        else if(grade > 2.7) {
            letter_grades.push_back(""B"");
        }
        else if(grade > 2.3) {
            letter_grades.push_back(""B-"");
        }
        else if(grade > 2.0) {
            letter_grades.push_back(""C+"");
        }
        else if(grade > 1.7) {
            letter_grades.push_back(""C"");
        }
        else if(grade > 1.3) {
            letter_grades.push_back(""C-"");
        }
        else if(grade > 1.0) {
            letter_grades.push_back(""D+"");
        }
        else if(grade > 0.7) {
            letter_grades.push_back(""D"");
        }
        else if(grade > 0.0) {
            letter_grades.push_back(""D-"");
        }
        else {
            letter_grades.push_back(""E"");
        }
    }

    return letter_grades;
"
0,1.0,HumanEval_81_numerical_letter_grade,"
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
    std::vector<std::string> letter_grades;
    for (float grade : grades) {
        if (grade == 4.0) {
            letter_grades.push_back(""A+"");
        } else if (grade > 3.7) {
            letter_grades.push_back(""A"");
        } else if (grade > 3.3) {
            letter_grades.push_back(""A-"");
        } else if (grade > 3.0) {
            letter_grades.push_back(""B+"");
        } else if (grade > 2.7) {
            letter_grades.push_back(""B"");
        } else if (grade > 2.3) {
            letter_grades.push_back(""B-"");
        } else if (grade > 2.0) {
            letter_grades.push_back(""C+"");
        } else if (grade > 1.7) {
            letter_grades.push_back(""C"");
        } else if (grade > 1.3) {
            letter_grades.push_back(""C-"");
        } else if (grade > 1.0) {
            letter_grades.push_back(""D+"");
        } else if (grade > 0.7) {
            letter_grades.push_back(""D"");
        } else if (grade > 0.0) {
            letter_grades.push_back(""D-"");
        } else {
            letter_grades.push_back(""E"");
        }
    }
    return letter_grades;
"
0,1.0,HumanEval_81_numerical_letter_grade,"
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
    std::vector<std::string> letterGrades;
    for (float grade : grades) {
        if (grade == 4.0) {
            letterGrades.push_back(""A+"");
        } else if (grade > 3.7) {
            letterGrades.push_back(""A"");
        } else if (grade > 3.3) {
            letterGrades.push_back(""A-"");
        } else if (grade > 3.0) {
            letterGrades.push_back(""B+"");
        } else if (grade > 2.7) {
            letterGrades.push_back(""B"");
        } else if (grade > 2.3) {
            letterGrades.push_back(""B-"");
        } else if (grade > 2.0) {
            letterGrades.push_back(""C+"");
        } else if (grade > 1.7) {
            letterGrades.push_back(""C"");
        } else if (grade > 1.3) {
            letterGrades.push_back(""C-"");
        } else if (grade > 1.0) {
            letterGrades.push_back(""D+"");
        } else if (grade > 0.7) {
            letterGrades.push_back(""D"");
        } else if (grade > 0.0) {
            letterGrades.push_back(""D-"");
        } else {
            letterGrades.push_back(""E"");
        }
    }
    return letterGrades;
"
0,0.0,HumanEval_81_numerical_letter_grade,"
    std::vector<std::string> letter_grades;
    for(float grade : grades) {
        if(grade == 4.0) {
            letter_grades.push_back(""A+"");
        } else if(grade > 3.7) {
            letter_grades.push_back(""A"");
        } else if(grade > 3.3) {
            letter_grades.push_back(""A-"");
        } else if(grade > 3.0) {
            letter_grades.push_back(""B+"");
        } else if(grade > 2.7) {
            letter_grades.push_back(""B"");
        } else if(grade > 2.3) {
            letter_grades.push_back(""B-"");
        } else if(grade > 2.0) {
            letter_grades.push_back(""C+"");
        } else if(grade > 1.7) {
            letter_grades.push_back(""C"");
        } else if(grade > 1.3) {
            letter_grades.push_back(""C-"");
        } else if(grade > 1.0) {
            letter_grades.push_back(""D+"");
        } else if(grade > 0.7) {
            letter_grades.push_back(""D"");
        } else if(grade > 0.0) {
            letter_grades.push_back(""D-"");
        } else {
            letter_grades.push_back(""E"");
        }
    }
    return letter_grades;
"
1,1.0,HumanEval_5_intersperse,"

std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    std::vector<long> result;
    for(size_t i = 0; i < numbers.size(); ++i) {
        result.push_back(numbers[i]);
        if(i != numbers.size() - 1) {
            result.push_back(delimeter);
        }
    }
    return result;"
0,1.0,HumanEval_5_intersperse,"

std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    std::vector<long> result;
    for (size_t i = 0; i < numbers.size(); ++i) {
        result.push_back(numbers[i]);
        if (i < numbers.size() - 1) {
            result.push_back(delimeter);
        }
    }
    return result;"
0,1.0,HumanEval_5_intersperse,"

std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    std::vector<long> result;
    for(size_t i = 0; i < numbers.size(); ++i) {
        result.push_back(numbers[i]);
        if(i < numbers.size() - 1) {
            result.push_back(delimeter);
        }
    }
    return result;"
1,1.0,HumanEval_5_intersperse,"
std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    for (size_t i = 1; i < numbers.size(); i++) {
        numbers.insert(numbers.begin() + i, delimeter);
        i++;
    }
    return numbers;"
1,1.0,HumanEval_5_intersperse,"

std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    if (numbers.size() == 0) {
        return numbers;
    }

    std::vector<long> result;
    for (size_t i = 0; i < numbers.size() - 1; i++) {
        result.push_back(numbers[i]);
        result.push_back(delimeter);
    }
    result.push_back(numbers.back());

    return result;
"
1,1.0,HumanEval_5_intersperse,"
std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    for (size_t i = 1; i < numbers.size(); i++) {
        numbers.insert(numbers.begin() + i++, delimeter);
    }
    return numbers;
"
1,1.0,HumanEval_5_intersperse,"

std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    for (size_t i = 1; i < numbers.size(); i++) {
        numbers.insert(numbers.begin() + i++, delimeter);
    }
    return numbers;"
1,1.0,HumanEval_5_intersperse,"

std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    std::vector<long> result;
    for (size_t i = 0; i < numbers.size(); i++) {
        result.push_back(numbers[i]);
        if (i != numbers.size() - 1) {
            result.push_back(delimeter);
        }
    }
    return result;
"
1,1.0,HumanEval_5_intersperse,"
std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    if (numbers.size() > 1) {
        for (size_t i = 1; i < numbers.size(); i += 2) {
            numbers.insert(numbers.begin() + i, delimeter);
        }
    }
    return numbers;"
1,1.0,HumanEval_5_intersperse,"

std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    if (numbers.size() == 0) return numbers;

    std::vector<long> result;
    for (size_t i = 0; i < numbers.size() - 1; i++) {
        result.push_back(numbers[i]);
        result.push_back(delimeter);
    }
    result.push_back(numbers.back());

    return result;"
0,0.0,HumanEval_146_specialFilter,"
    long count = 0;
    for(long num : nums) {
        if(num > 10) {
            std::string strNum = std::to_string(num);
            if((strNum[0] - '0') % 2 == 1 && (strNum[strNum.size() - 1] - '0') % 2 == 1) {
                count++;
            }
        }
    }
    return count;
"
1,1.0,HumanEval_146_specialFilter,"

long specialFilter(std::vector<long> nums) {
    long count = 0;
    for(long num : nums) {
        if(num > 10) {
            std::string numStr = std::to_string(std::abs(num));
            if((numStr[0] - '0') % 2 == 1 && (numStr[numStr.size() - 1] - '0') % 2 == 1) {
                count++;
            }
        }
    }
    return count;"
0,1.0,HumanEval_146_specialFilter,"
    long count = 0;
    for (long num : nums) {
        if (num > 10 && std::to_string(std::abs(num))[0] in {'1', '3', '5', '7', '9'} && std::to_string(std::abs(num))[std::to_string(std::abs(num)).size() - 1] in {'1', '3', '5', '7', '9'}) {
            count++;
        }
    }
    return count;"
1,1.0,HumanEval_146_specialFilter,"
long specialFilter(std::vector<long> nums) {
    long count = 0;
    for(long num : nums) {
        if(num > 10) {
            std::string strNum = std::to_string(std::abs(num));
            if((strNum[0] - '0') % 2 == 1 && (strNum[strNum.size() - 1] - '0') % 2 == 1) {
                count++;
            }
        }
    }
    return count;
"
1,1.0,HumanEval_146_specialFilter,"
long specialFilter(std::vector<long> nums) {
    long count = 0;
    for(long num : nums) {
        if(num > 10) {
            long firstDigit = num;
            while(firstDigit >= 10) {
                firstDigit /= 10;
            }
            long lastDigit = num % 10;
            if(firstDigit % 2 == 1 && lastDigit % 2 == 1) {
                count++;
            }
        }
    }
    return count;"
1,1.0,HumanEval_146_specialFilter,"

long specialFilter(std::vector<long> nums) {
    long count = 0;
    for(long num : nums) {
        if(num > 10) {
            std::string strNum = std::to_string(std::abs(num));
            if((strNum[0] - '0') % 2 != 0 && (strNum[strNum.size() - 1] - '0') % 2 != 0) {
                count++;
            }
        }
    }
    return count;
"
1,1.0,HumanEval_146_specialFilter,"

long specialFilter(std::vector<long> nums) {
    long count = 0;
    for(long num : nums) {
        if(num > 10) {
            std::string strNum = std::to_string(std::abs(num));
            if((strNum[0] - '0') % 2 == 1 && (strNum[strNum.length() - 1] - '0') % 2 == 1) {
                count++;
            }
        }
    }
    return count;"
1,1.0,HumanEval_146_specialFilter,"

long specialFilter(std::vector<long> nums) {
    long count = 0;
    for(long num : nums) {
        if(num > 10) {
            long firstDigit = num;
            while(firstDigit >= 10) {
                firstDigit /= 10;
            }
            long lastDigit = num % 10;
            if(firstDigit % 2 == 1 && lastDigit % 2 == 1) {
                count++;
            }
        }
    }
    return count;"
0,0.0,HumanEval_146_specialFilter,"
    long count = 0;
    for(long num : nums) {
        if(num > 10) {
            std::string str_num = std::to_string(abs(num));
            if((str_num[0] - '0') % 2 != 0 && (str_num[str_num.size() - 1] - '0') % 2 != 0) {
                count++;
            }
        }
    }
    return count;
"
1,1.0,HumanEval_146_specialFilter,"

long specialFilter(std::vector<long> nums) {
    long count = 0;
    for(long num : nums) {
        if(num > 10) {
            std::string strNum = std::to_string(num);
            if((strNum[0] == '1' || strNum[0] == '3' || strNum[0] == '5' || strNum[0] == '7' || strNum[0] == '9') &&
               (strNum[strNum.size() - 1] == '1' || strNum[strNum.size() - 1] == '3' || strNum[strNum.size() - 1] == '5' || 
               strNum[strNum.size() - 1] == '7' || strNum[strNum.size() - 1] == '9')) {
                count++;
            }
        }
    }
    return count;
"
1,1.0,HumanEval_60_sum_to_n,"
long sum_to_n(long n) {
    return n * (n + 1) / 2;"
1,1.0,HumanEval_60_sum_to_n,"
long sum_to_n(long n) {
    long sum = 0;
    for(long i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;"
1,1.0,HumanEval_60_sum_to_n,"
long sum_to_n(long n) {
    long sum = 0;
    for(long i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
"
1,1.0,HumanEval_60_sum_to_n,"

long sum_to_n(long n) {
    long sum = 0;
    for(long i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;"
1,1.0,HumanEval_60_sum_to_n,"

long sum_to_n(long n) {
    long sum = 0;
    for(long i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
"
1,1.0,HumanEval_60_sum_to_n,"
long sum_to_n(long n) {
    assert(n >= 0);
    return n * (n + 1) / 2;"
1,1.0,HumanEval_60_sum_to_n,"
long sum_to_n(long n) {
    long sum = 0;
    for(long i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
"
1,1.0,HumanEval_60_sum_to_n,"
long sum_to_n(long n) {
    assert(n >= 0);
    return n * (n + 1) / 2;
"
1,1.0,HumanEval_60_sum_to_n,"
long sum_to_n(long n) {
    assert(n >= 0);
    return n * (n + 1) / 2;
"
1,1.0,HumanEval_60_sum_to_n,"

long sum_to_n(long n) {
    long sum = 0;
    for(long i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;"
0,1.0,HumanEval_26_remove_duplicates,"
std::vector<long> remove_duplicates(std::vector<long> numbers) {
    std::vector<long> result;
    std::unordered_map<long, int> count;
    for (long num : numbers) {
        if (count.find(num) == count.end()) {
            count[num] = 1;
            result.push_back(num);
        }
    }
    return result;
"
0,1.0,HumanEval_26_remove_duplicates,"

std::vector<long> remove_duplicates(std::vector<long> numbers) {
    std::unordered_map<long, int> count;
    std::vector<long> result;

    for (long num : numbers) {
        if (count.find(num) == count.end()) {
            count[num] = 1;
            result.push_back(num);
        }
    }

    return result;
"
0,0.0,HumanEval_26_remove_duplicates,"
    std::map<long, int> count;
    for (long num : numbers) {
        count[num]++;
    }

    std::vector<long> result;
    for (long num : numbers) {
        if (count[num] == 1) {
            result.push_back(num);
        }
    }

    return result;
"
0,1.0,HumanEval_26_remove_duplicates,"

std::vector<long> remove_duplicates(std::vector<long> numbers) {
    std::unordered_map<long, int> count;
    std::vector<long> result;

    for (const auto& num : numbers) {
        if (count.find(num) == count.end()) {
            count[num] = 1;
            result.push_back(num);
        }
    }

    return result;"
0,1.0,HumanEval_26_remove_duplicates,"
std::vector<long> remove_duplicates(std::vector<long> numbers) {
    std::unordered_map<long, int> count;
    std::vector<long> result;

    for (long num : numbers) {
        if (count[num] == 0) {
            result.push_back(num);
        }
        count[num]++;
    }

    return result;
"
0,0.0,HumanEval_26_remove_duplicates,"
    std::unordered_map<long, int> count;
    std::vector<long> result;
    for (long num : numbers) {
        if (count.find(num) == count.end()) {
            count[num] = 1;
            result.push_back(num);
        }
    }
    return result;
"
0,1.0,HumanEval_26_remove_duplicates,"

std::vector<long> remove_duplicates(std::vector<long> numbers) {
    std::unordered_map<long, int> count;
    std::vector<long> result;

    for (long num : numbers) {
        if (count.find(num) == count.end()) {
            count[num] = 1;
            result.push_back(num);
        }
    }

    return result;
"
0,1.0,HumanEval_26_remove_duplicates,"

std::vector<long> remove_duplicates(std::vector<long> numbers) {
    std::unordered_map<long, int> count;
    std::vector<long> result;

    for (long num : numbers) {
        if (count.find(num) == count.end()) {
            count[num] = 1;
            result.push_back(num);
        }
    }

    return result;"
0,1.0,HumanEval_26_remove_duplicates,"
std::vector<long> remove_duplicates(std::vector<long> numbers) {
    std::unordered_map<long, int> count;
    std::vector<long> result;

    for (long num : numbers) {
        if (count.find(num) == count.end()) {
            count[num] = 1;
            result.push_back(num);
        }
    }

    return result;"
1,1.0,HumanEval_26_remove_duplicates,"
std::vector<long> remove_duplicates(std::vector<long> numbers) {
    std::unordered_map<long, int> count;
    for (long num : numbers) {
        count[num]++;
    }
    std::vector<long> result;
    for (long num : numbers) {
        if (count[num] == 1) {
            result.push_back(num);
        }
    }
    return result;"
0,1.0,HumanEval_163_generate_integers,"
std::vector<long> generate_integers(long a, long b) {
    std::vector<long> result;
    // Swap a and b if a is greater than b
    if (a > b) {
        std::swap(a, b);
    }
    // Iterate from a to b and check if the number is even
    for (long i = a; i <= b; i++) {
        if (i % 2 == 0) {
            result.push_back(i);
        }
    }
    return result;"
0,1.0,HumanEval_163_generate_integers,"

std::vector<long> generate_integers(long a, long b) {
    std::vector<long> result;
    if (a > b)
        std::swap(a, b);
    for (long i = a; i <= b; i++) {
        if (i % 2 == 0)
            result.push_back(i);
    }
    return result;"
0,1.0,HumanEval_163_generate_integers,"

std::vector<long> generate_integers(long a, long b) {
    std::vector<long> result;
    if (a > b)
        std::swap(a, b);
    for (long i = a; i <= b; i++) {
        if (i % 2 == 0)
            result.push_back(i);
    }
    return result;
"
0,0.0,HumanEval_163_generate_integers,"

std::vector<long> generate_integers(long a, long b) {
    std::vector<long> result;
    if (a > b) {
        std::swap(a, b);
    }
    for (long i = a; i <= b; i++) {
        if (i % 2 == 0) {
            result.push_back(i);
        }
    }
    return result;"
0,1.0,HumanEval_163_generate_integers,"

std::vector<long> generate_integers(long a, long b) {
    std::vector<long> result;
    if(a > b) std::swap(a, b);
    for(long i = a; i <= b; i++){
        if(i % 2 == 0) result.push_back(i);
    }
    return result;"
0,0.0,HumanEval_163_generate_integers,"
std::vector<long> generate_integers(long a, long b) {
    // Swap if a is greater than b
    if(a > b) {
        std::swap(a, b);
    }

    std::vector<long> result;

    // Check every number between a and b
    for(long i = a; i <= b; i++) {
        // If the number is even, add it to the result
        if(i % 2 == 0) {
            result.push_back(i);
        }
    }

    return result;
"
0,1.0,HumanEval_163_generate_integers,"
std::vector<long> generate_integers(long a, long b) {
    std::vector<long> result;
    if(a > b) {
        std::swap(a, b);
    }
    for(long i = a; i <= b; i++) {
        if(i % 2 == 0) {
            result.push_back(i);
        }
    }
    return result;"
0,0.0,HumanEval_163_generate_integers,"

std::vector<long> generate_integers(long a, long b) {
    // Swap if a is greater than b
    if(a > b) {
        std::swap(a, b);
    }

    std::vector<long> result;
    for(long i = a; i <= b; i++) {
        // Check if the digit is even
        if(i % 2 == 0) {
            result.push_back(i);
        }
    }
    return result;
"
0,1.0,HumanEval_163_generate_integers,"
std::vector<long> generate_integers(long a, long b) {
    std::vector<long> result;
    if (a > b) std::swap(a, b);
    for (long i = a; i <= b; i++) {
        if (i % 2 == 0) {
            result.push_back(i);
        }
    }
    return result;
"
0,0.0,HumanEval_163_generate_integers,"
    std::vector<long> result;
    if (a > b) {
        std::swap(a, b);
    }
    for (long i = a; i <= b; i++) {
        if (i % 2 == 0) {
            result.push_back(i);
        }
    }
    return result;
"
0,1.0,HumanEval_9_rolling_max,"

std::vector<long> rolling_max(std::vector<long> numbers) {
    std::vector<long> result;
    long max_so_far = LONG_MIN;
    for(long num : numbers) {
        max_so_far = std::max(max_so_far, num);
        result.push_back(max_so_far);
    }
    return result;
"
0,1.0,HumanEval_9_rolling_max,"
std::vector<long> rolling_max(std::vector<long> numbers) {
    assert(!numbers.empty());

    std::vector<long> max_numbers;
    max_numbers.reserve(numbers.size());

    long current_max = numbers[0];
    max_numbers.push_back(current_max);

    for (size_t i = 1; i < numbers.size(); ++i) {
        if (numbers[i] > current_max) {
            current_max = numbers[i];
        }
        max_numbers.push_back(current_max);
    }

    return max_numbers;
"
1,1.0,HumanEval_9_rolling_max,"

std::vector<long> rolling_max(std::vector<long> numbers) {
    long max_so_far = LONG_MIN;
    std::vector<long> rolling_max;

    for (long num : numbers) {
        max_so_far = std::max(max_so_far, num);
        rolling_max.push_back(max_so_far);
    }

    return rolling_max;"
1,1.0,HumanEval_9_rolling_max,"
std::vector<long> rolling_max(std::vector<long> numbers) {
    std::vector<long> max_numbers;
    long max_number = LONG_MIN;
    for (long num : numbers) {
        max_number = std::max(max_number, num);
        max_numbers.push_back(max_number);
    }
    return max_numbers;"
1,1.0,HumanEval_9_rolling_max,"

std::vector<long> rolling_max(std::vector<long> numbers) {
    std::vector<long> max_numbers;
    long max_num = LONG_MIN;
    for (long num : numbers) {
        max_num = std::max(max_num, num);
        max_numbers.push_back(max_num);
    }
    return max_numbers;
"
0,0.0,HumanEval_9_rolling_max,"
    // Create a new vector to store the rolling maximums
    std::vector<long> rolling_maxs;

    // If the input vector is empty, return an empty vector
    if (numbers.empty()) {
        return rolling_maxs;
    }

    // Initialize the maximum as the first element
    long max_val = numbers[0];

    // Iterate over the input vector
    for (long num : numbers) {
        // If the current number is greater than the current maximum, update the maximum
        max_val = std::max(max_val, num);
        // Add the current maximum to the rolling maximums vector
        rolling_maxs.push_back(max_val);
    }

    // Return the vector of rolling maximums
    return rolling_maxs;"
0,0.0,HumanEval_9_rolling_max,"
    std::vector<long> rolling_max_values;
    long current_max = LONG_MIN;
    for(long num : numbers) {
        current_max = std::max(current_max, num);
        rolling_max_values.push_back(current_max);
    }
    return rolling_max_values;
"
1,1.0,HumanEval_9_rolling_max,"
std::vector<long> rolling_max(std::vector<long> numbers) {
    std::vector<long> max_numbers;
    long max_num = LONG_MIN;
    for (long num : numbers) {
        max_num = std::max(max_num, num);
        max_numbers.push_back(max_num);
    }
    return max_numbers;
"
1,1.0,HumanEval_9_rolling_max,"

std::vector<long> rolling_max(std::vector<long> numbers) {
    std::vector<long> result;
    long max = LONG_MIN;
    for(long num : numbers) {
        if(num > max) {
            max = num;
        }
        result.push_back(max);
    }
    return result;"
1,1.0,HumanEval_9_rolling_max,"

std::vector<long> rolling_max(std::vector<long> numbers) {
    std::vector<long> max_numbers;
    long current_max = LONG_MIN;

    for (long number : numbers) {
        if (number > current_max) {
            current_max = number;
        }
        max_numbers.push_back(current_max);
    }

    return max_numbers;
"
1,1.0,HumanEval_3_below_zero,"

bool below_zero(std::vector<long> operations) {
    long balance = 0;
    for(long op : operations) {
        balance += op;
        if(balance < 0) {
            return true;
        }
    }
    return false;"
1,1.0,HumanEval_3_below_zero,"
bool below_zero(std::vector<long> operations) {
    long balance = 0;
    for(auto op : operations) {
        balance += op;
        if(balance < 0) {
            return true;
        }
    }
    return false;"
1,1.0,HumanEval_3_below_zero,"
bool below_zero(std::vector<long> operations) {
    long balance = 0;
    for(auto operation : operations) {
        balance += operation;
        if(balance < 0) {
            return true;
        }
    }
    return false;"
1,1.0,HumanEval_3_below_zero,"
bool below_zero(std::vector<long> operations) {
    long balance = 0;
    for(long op : operations) {
        balance += op;
        if(balance < 0) {
            return true;
        }
    }
    return false;"
1,1.0,HumanEval_3_below_zero,"
bool below_zero(std::vector<long> operations) {
    long balance = 0;
    for(long op : operations) {
        balance += op;
        if(balance < 0) {
            return true;
        }
    }
    return false;"
0,0.0,HumanEval_3_below_zero,"
    long balance = 0;
    for(long op : operations) {
        balance += op;
        if(balance < 0) {
            return true;
        }
    }
    return false;"
0,0.0,HumanEval_3_below_zero,"
    long balance = 0;
    for(long op : operations) {
        balance += op;
        if(balance < 0) {
            return true;
        }
    }
    return false;"
0,0.0,HumanEval_3_below_zero,"
    long balance = 0;
    for(auto operation : operations) {
        balance += operation;
        if(balance < 0) {
            return true;
        }
    }
    return false;"
1,1.0,HumanEval_3_below_zero,"
bool below_zero(std::vector<long> operations) {
    long balance = 0;
    for(long op : operations) {
        balance += op;
        if(balance < 0) {
            return true;
        }
    }
    return false;"
1,1.0,HumanEval_3_below_zero,"

bool below_zero(std::vector<long> operations) {
    long balance = 0;
    for(long op : operations) {
        balance += op;
        if(balance < 0) {
            return true;
        }
    }
    return false;
"
0,0.0,HumanEval_69_search,"
    std::unordered_map<long, long> freq;
    for (long num : lst) {
        freq[num]++;
    }
    for (long num : lst) {
        if (freq[num] >= num) {
            return num;
        }
    }
    return -1;
"
1,1.0,HumanEval_69_search,"
long search(std::vector<long> lst) {
    std::map<long, long> freq;
    for (long num : lst) {
        freq[num]++;
    }
    for (long num = lst.size(); num > 0; num--) {
        if (freq[num] >= num) {
            return num;
        }
    }
    return -1;"
0,0.0,HumanEval_69_search,"
    std::map<long, long> freq;
    for (long num : lst) {
        freq[num]++;
    }
    for (long i = lst.size(); i > 0; i--) {
        if (freq[i] >= i) {
            return i;
        }
    }
    return -1;
"
1,1.0,HumanEval_69_search,"
long search(std::vector<long> lst) {
    std::map<long, long> freq;
    for (long num : lst) {
        freq[num]++;
    }
    for (long i = lst.size(); i > 0; i--) {
        if (freq[i] >= i) {
            return i;
        }
    }
    return -1;"
0,1.0,HumanEval_69_search,"
long search(std::vector<long> lst) {
    std::map<long, long> freq;
    for(long num : lst) {
        freq[num]++;
    }
    for(auto it = freq.rbegin(); it != freq.rend(); ++it) {
        if(it->first >= it->second) {
            return it->first;
        }
    }
    return -1;"
0,1.0,HumanEval_69_search,"

long search(std::vector<long> lst) {
    std::map<long, long> freq;
    for (long num : lst) {
        freq[num]++;
    }

    for (auto it = lst.rbegin(); it != lst.rend(); ++it) {
        if (*it > 0 && freq[*it] >= *it) {
            return *it;
        }
    }

    return -1;"
0,1.0,HumanEval_69_search,"
long search(std::vector<long> lst) {
    std::map<long, long> freq;
    for (long num : lst) {
        freq[num]++;
    }
    for (long num = lst.size(); num > 0; num--) {
        if (freq[num] >= num) {
            return num;
        }
    }
    return -1;"
1,1.0,HumanEval_69_search,"
long search(std::vector<long> lst) {
    std::map<long, long> freq;
    for (long num : lst) {
        freq[num]++;
    }
    for (long i = lst.size(); i > 0; i--) {
        if (freq[i] >= i) {
            return i;
        }
    }
    return -1;
"
0,1.0,HumanEval_69_search,"
long search(std::vector<long> lst) {
    std::map<long, long> count;
    for (long num : lst) {
        count[num]++;
    }

    for (auto it = count.rbegin(); it != count.rend(); ++it) {
        if (it->first >= it->second) {
            return it->first;
        }
    }

    return -1;
"
0,1.0,HumanEval_69_search,"
long search(std::vector<long> lst) {
    std::map<long, long> freq;
    for(long num : lst) {
        freq[num]++;
    }
    for(long num = lst.size(); num > 0; num--) {
        if(freq[num] >= num) {
            return num;
        }
    }
    return -1;"
0,0.0,HumanEval_61_correct_bracketing,"
    std::stack<char> stack;
    for(char& c : brackets) {
        if(c == '(') {
            stack.push(c);
        } else if(c == ')') {
            if(stack.empty() || stack.top() != '(') {
                return false;
            }
            stack.pop();
        }
    }
    return stack.empty();"
0,0.0,HumanEval_61_correct_bracketing,"
    std::stack<char> stack;
    for(char& c : brackets) {
        if(c == '(') {
            stack.push(c);
        } else {
            if(stack.empty()) {
                return false;
            }
            if(stack.top() == '(') {
                stack.pop();
            } else {
                return false;
            }
        }
    }
    return stack.empty();
"
1,1.0,HumanEval_61_correct_bracketing,"
bool correct_bracketing(std::string brackets) {
    std::stack<char> stack;
    for (char& c : brackets) {
        if (c == '(') {
            stack.push(c);
        } else if (c == ')') {
            if (stack.empty()) {
                return false;
            } else {
                stack.pop();
            }
        }
    }
    return stack.empty();
"
0,0.0,HumanEval_61_correct_bracketing,"
    std::stack<char> stack;
    for(auto &bracket : brackets) {
        if(bracket == '(') {
            stack.push(bracket);
        } else {
            if(stack.empty()) {
                return false;
            }
            stack.pop();
        }
    }
    return stack.empty();
"
1,1.0,HumanEval_61_correct_bracketing,"
bool correct_bracketing(std::string brackets) {
    std::stack<char> stack;

    for(auto& bracket : brackets) {
        if(bracket == '(') {
            stack.push(bracket);
        } else {
            if(stack.empty()) {
                return false;
            }
            if(stack.top() == '(') {
                stack.pop();
            } else {
                return false;
            }
        }
    }

    return stack.empty();"
1,1.0,HumanEval_61_correct_bracketing,"
bool correct_bracketing(std::string brackets) {
    std::stack<char> stack;
    for(char& c : brackets) {
        if(c == '(') {
            stack.push(c);
        } else if(c == ')') {
            if(stack.empty()) {
                return false;
            }
            if(stack.top() == '(') {
                stack.pop();
            } else {
                return false;
            }
        }
    }
    return stack.empty();"
1,1.0,HumanEval_61_correct_bracketing,"

bool correct_bracketing(std::string brackets) {
    std::stack<char> stack;
    for(char c : brackets) {
        if(c == '(') {
            stack.push(c);
        } else if(c == ')') {
            if(stack.empty()) {
                return false;
            }
            stack.pop();
        }
    }
    return stack.empty();"
0,0.0,HumanEval_61_correct_bracketing,"
    std::stack<char> stack;
    for(char& c : brackets) {
        if(c == '(') {
            stack.push(c);
        } else if(c == ')') {
            if(stack.empty() || stack.top() != '(') {
                return false;
            }
            stack.pop();
        }
    }
    return stack.empty();"
1,1.0,HumanEval_61_correct_bracketing,"

bool correct_bracketing(std::string brackets) {
    std::stack<char> stack;
    for (char bracket : brackets) {
        if (bracket == '(') {
            stack.push(bracket);
        } else if (bracket == ')') {
            if (stack.empty()) {
                return false;
            }
            stack.pop();
        }
    }
    return stack.empty();"
1,1.0,HumanEval_61_correct_bracketing,"

bool correct_bracketing(std::string brackets) {
    std::stack<char> stack;

    for(char& c : brackets) {
        switch(c) {
            case '(':
                stack.push(c);
                break;
            case ')':
                if(stack.empty() || stack.top() != '(') {
                    return false;
                }
                stack.pop();
                break;
        }
    }

    return stack.empty();"
0,0.0,HumanEval_37_sort_even,"
    // Create two vectors to store the values at even and odd indices
    std::vector<long> even_indices;
    std::vector<long> odd_indices;

    // Iterate over the input vector
    for (size_t i = 0; i < l.size(); ++i) {
        // If the index is even, store the value in the even_indices vector
        if (i % 2 == 0) {
            even_indices.push_back(l[i]);
        } else {
            // Otherwise, store the value in the odd_indices vector
            odd_indices.push_back(l[i]);
        }
    }

    // Sort the even_indices vector
    std::sort(even_indices.begin(), even_indices.end());

    // Iterate over the input vector again
    for (size_t i = 0, j = 0; i < l.size(); ++i) {
        // If the index is even, replace the value at that index with the next value from the sorted even_indices vector
        if (i % 2 == 0) {
            l[i] = even_indices[j++];
        }
    }

    // Combine the odd_indices vector and the modified even_indices vector to form the result
    for (auto &value : odd_indices) {
        l.push_back(value);
    }

    return l;
"
1,1.0,HumanEval_37_sort_even,"

std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_indices;
    for (size_t i = 0; i < l.size(); i += 2) {
        even_indices.push_back(l[i]);
    }
    std::sort(even_indices.begin(), even_indices.end());
    for (size_t i = 0, j = 0; i < l.size(); i += 2) {
        l[i] = even_indices[j++];
    }
    return l;"
1,1.0,HumanEval_37_sort_even,"

std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_indices;
    for (int i = 0; i < l.size(); i += 2) {
        even_indices.push_back(l[i]);
    }
    std::sort(even_indices.begin(), even_indices.end());
    for (int i = 0, j = 0; i < l.size(); i += 2, ++j) {
        l[i] = even_indices[j];
    }
    return l;"
1,1.0,HumanEval_37_sort_even,"

std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_indices;
    for(size_t i = 0; i < l.size(); i += 2) {
        even_indices.push_back(l[i]);
    }
    std::sort(even_indices.begin(), even_indices.end());

    for(size_t i = 0, j = 0; i < l.size(); i += 2, ++j) {
        l[i] = even_indices[j];
    }

    return l;"
1,1.0,HumanEval_37_sort_even,"
std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_indices;
    for(int i = 0; i < l.size(); i += 2) {
        even_indices.push_back(l[i]);
    }
    std::sort(even_indices.begin(), even_indices.end());
    for(int i = 0, j = 0; i < l.size(); i += 2, ++j) {
        l[i] = even_indices[j];
    }
    return l;"
1,1.0,HumanEval_37_sort_even,"

std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_indices;
    for (size_t i = 0; i < l.size(); i += 2) {
        even_indices.push_back(l[i]);
    }
    std::sort(even_indices.begin(), even_indices.end());
    for (size_t i = 0, j = 0; i < l.size(); i += 2) {
        l[i] = even_indices[j++];
    }
    return l;"
1,1.0,HumanEval_37_sort_even,"

std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_values;
    for (int i = 0; i < l.size(); i += 2) {
        even_values.push_back(l[i]);
    }
    std::sort(even_values.begin(), even_values.end());
    for (int i = 0, j = 0; i < l.size(); i += 2, ++j) {
        l[i] = even_values[j];
    }
    return l;"
1,1.0,HumanEval_37_sort_even,"
std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_indicies;
    for (size_t i = 0; i < l.size(); i += 2) {
        even_indicies.push_back(l[i]);
    }
    std::sort(even_indicies.begin(), even_indicies.end());
    for (size_t i = 0, j = 0; i < l.size(); i += 2, ++j) {
        l[i] = even_indicies[j];
    }
    return l;
"
1,1.0,HumanEval_37_sort_even,"

std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_indices;
    std::vector<long> sorted_even_indices;

    for(int i = 0; i < l.size(); i+=2){
        even_indices.push_back(l[i]);
    }

    std::sort(even_indices.begin(), even_indices.end());

    int j = 0;
    for(int i = 0; i < l.size(); i++){
        if(i % 2 == 0){
            sorted_even_indices.push_back(even_indices[j]);
            j++;
        }
        else{
            sorted_even_indices.push_back(l[i]);
        }
    }

    return sorted_even_indices;"
1,1.0,HumanEval_37_sort_even,"

std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_indicies;
    for (int i = 0; i < l.size(); i += 2) {
        even_indicies.push_back(l[i]);
    }
    std::sort(even_indicies.begin(), even_indicies.end());
    for (int i = 0, j = 0; i < l.size(); i += 2, ++j) {
        l[i] = even_indicies[j];
    }
    return l;"
0,1.0,HumanEval_54_same_chars,"
bool same_chars(std::string s0, std::string s1) {
    // Create frequency map for each string
    std::map<char, int> freq_map_s0;
    std::map<char, int> freq_map_s1;

    for (char c : s0) {
        freq_map_s0[c]++;
    }

    for (char c : s1) {
        freq_map_s1[c]++;
    }

    // If the frequency maps are not equal, the strings do not have the same characters
    if (freq_map_s0 != freq_map_s1) {
        return false;
    }

    return true;
"
0,0.0,HumanEval_54_same_chars,"
bool same_chars(std::string s0, std::string s1) {
    // Create two count arrays and initialize all values as 0
    int count0[256] = {0}, count1[256] = {0};

    // Count frequency of each character in first string
    for (int i = 0; s0[i] && s1[i]; i++) {
        count0[s0[i]]++;
        count1[s1[i]]++;
    }

    // Compare count arrays
    for (int i = 0; i < 256; i++)
        if (count0[i] != count1[i])
            return false;

    return true;"
0,0.0,HumanEval_54_same_chars,"
bool same_chars(std::string s0, std::string s1) {
    std::map<char, int> count0;
    std::map<char, int> count1;

    for (char c : s0) {
        count0[c]++;
    }

    for (char c : s1) {
        count1[c]++;
    }

    return count0 == count1;"
0,0.0,HumanEval_54_same_chars,"
bool same_chars(std::string s0, std::string s1) {
    // Create frequency maps for both strings.
    std::map<char, int> freq_s0, freq_s1;
    for (char c : s0) {
        freq_s0[c]++;
    }
    for (char c : s1) {
        freq_s1[c]++;
    }

    // Compare the frequency maps.
    return freq_s0 == freq_s1;
"
0,0.0,HumanEval_54_same_chars,"
    // Count the frequency of each character in both strings
    std::vector<int> count0(256, 0), count1(256, 0);
    for (char c : s0) count0[tolower(c)]++;
    for (char c : s1) count1[tolower(c)]++;

    // Compare the frequencies
    for (int i = 0; i < 256; i++) {
        if (count0[i] != count1[i]) {
            return false;
        }
    }

    return true;"
0,0.0,HumanEval_54_same_chars,"

bool same_chars(std::string s0, std::string s1) {
    std::sort(s0.begin(), s0.end());
    std::sort(s1.begin(), s1.end());
    return s0 == s1;"
0,0.0,HumanEval_54_same_chars,"
bool same_chars(std::string s0, std::string s1) {
    std::sort(s0.begin(), s0.end());
    std::sort(s1.begin(), s1.end());
    return s0 == s1;"
0,1.0,HumanEval_54_same_chars,"
bool same_chars(std::string s0, std::string s1) {
    std::sort(s0.begin(), s0.end());
    std::sort(s1.begin(), s1.end());

    return s0 == s1;
"
0,1.0,HumanEval_54_same_chars,"

bool same_chars(std::string s0, std::string s1) {
    std::sort(s0.begin(), s0.end());
    std::sort(s1.begin(), s1.end());
    return s0 == s1;
"
0,0.0,HumanEval_54_same_chars,"
bool same_chars(std::string s0, std::string s1) {
    // Create two count arrays and initialize all values as 0
    int count0[256] = {0};
    int count1[256] = {0};

    // Iterate through every character of both strings and increment the count of character in the count array
    for (int i = 0; s0[i] && s1[i]; i++) {
        count0[s0[i]]++;
        count1[s1[i]]++;
    }

    // If both strings are of different length.
    // Removing this condition will make the program to compare characters that are not present in both strings.
    if (s0.length() != s1.length())
        return false;

    // Compare count arrays
    for (int i = 0; i < 256; i++)
        if (count0[i] != count1[i])
            return false;

    return true;
"
0,0.0,HumanEval_56_correct_bracketing,"
    std::stack<char> stack;
    for (char bracket : brackets) {
        if (bracket == '<') {
            stack.push(bracket);
        } else {
            if (stack.empty()) {
                return false;
            }
            stack.pop();
        }
    }
    return stack.empty();"
1,1.0,HumanEval_56_correct_bracketing,"

bool correct_bracketing(std::string brackets) {
    std::stack<char> stack;
    for(char c : brackets) {
        if(c == '<') {
            stack.push(c);
        } else if(c == '>') {
            if(stack.empty()) {
                return false;
            }
            if(stack.top() == '<') {
                stack.pop();
            } else {
                return false;
            }
        }
    }
    return stack.empty();"
1,1.0,HumanEval_56_correct_bracketing,"
bool correct_bracketing(std::string brackets) {
    std::stack<char> stack;
    for(char bracket : brackets) {
        if(bracket == '<') {
            stack.push(bracket);
        } else {
            if(stack.empty()) {
                return false;
            }
            if(stack.top() == '<') {
                stack.pop();
            } else {
                return false;
            }
        }
    }
    return stack.empty();"
1,1.0,HumanEval_56_correct_bracketing,"

bool correct_bracketing(std::string brackets) {
    std::stack<char> stack;

    for(char bracket : brackets) {
        if(bracket == '<') {
            stack.push(bracket);
        } else {
            if(stack.empty() || stack.top() != '<') {
                return false;
            }
            stack.pop();
        }
    }

    return stack.empty();"
0,0.0,HumanEval_56_correct_bracketing,"
    std::stack<char> stack;
    for(char c : brackets) {
        if(c == '<') {
            stack.push(c);
        } else if(c == '>') {
            if(stack.empty() || stack.top() != '<') {
                return false;
            }
            stack.pop();
        }
    }
    return stack.empty();"
1,1.0,HumanEval_56_correct_bracketing,"
bool correct_bracketing(std::string brackets) {
    std::stack<char> stack;
    for(int i = 0; i < brackets.length(); i++) {
        if(brackets[i] == '<') {
            stack.push('<');
        } else {
            if(stack.empty()) {
                return false;
            } else {
                stack.pop();
            }
        }
    }
    return stack.empty();
"
1,1.0,HumanEval_56_correct_bracketing,"

bool correct_bracketing(std::string brackets) {
    std::stack<char> stack;

    for(char& c : brackets) {
        switch(c) {
            case '<':
                stack.push(c);
                break;
            case '>':
                if(stack.empty() || stack.top() != '<') {
                    return false;
                }
                stack.pop();
                break;
            default:
                return false;
        }
    }

    return stack.empty();
"
1,1.0,HumanEval_56_correct_bracketing,"
bool correct_bracketing(std::string brackets) {
    std::stack<char> stack;
    for(char bracket : brackets) {
        if(bracket == '<') {
            stack.push(bracket);
        } else {
            if(stack.empty()) {
                return false;
            }
            if(stack.top() == '<') {
                stack.pop();
            } else {
                return false;
            }
        }
    }
    return stack.empty();
"
0,0.0,HumanEval_56_correct_bracketing,"
    std::stack<char> stack;
    for(char& c : brackets) {
        if(c == '<') {
            stack.push(c);
        } else if(!stack.empty()) {
            if(stack.top() == '<') {
                stack.pop();
            } else {
                return false;
            }
        } else {
            return false;
        }
    }
    return stack.empty();
"
0,0.0,HumanEval_56_correct_bracketing,"
    std::stack<char> stack;
    for (char c : brackets) {
        if (c == '<') {
            stack.push(c);
        } else if (c == '>') {
            if (stack.empty()) {
                return false;
            }
            stack.pop();
        }
    }
    return stack.empty();
"
